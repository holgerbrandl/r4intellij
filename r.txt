.Rprofile: Setting Goettingen repository
> print(".checkMFClasses"); if(is.function(try(.checkMFClasses))) {.checkMFClasses;} else{ NULL};
[1] ".checkMFClasses"
function (cl, m, ordNotOK = FALSE) 
{
    new <- sapply(m, .MFclass)
    new <- new[names(new) %in% names(cl)]
    if (length(new) == 0L) 
        return()
    old <- cl[names(new)]
    if (!ordNotOK) {
        old[old == "ordered"] <- "factor"
        new[new == "ordered"] <- "factor"
    }
    new[new == "ordered" && old == "factor"] <- "factor"
    if (!identical(old, new)) {
        wrong <- old != new
        if (sum(wrong) == 1) 
            stop(gettextf("variable '%s' was fitted with type \"%s\" but type \"%s\" was supplied", 
                names(old)[wrong], old[wrong], new[wrong]), call. = FALSE, 
                domain = NA)
        else stop(gettextf("variables %s were specified with different types from the fit", 
            paste(sQuote(names(old)[wrong]), collapse = ", ")), 
            call. = FALSE, domain = NA)
    }
}
<environment: namespace:stats>
> print("AIC"); if(is.function(try(AIC))) {AIC;} else{ NULL};
[1] "AIC"
function (object, ..., k = 2) 
UseMethod("AIC")
<environment: namespace:stats>
> print("ARMAacf"); if(is.function(try(ARMAacf))) {ARMAacf;} else{ NULL};
[1] "ARMAacf"
function (ar = numeric(0), ma = numeric(0), lag.max = r, pacf = FALSE) 
{
    p <- length(ar)
    q <- length(ma)
    if (!p && !q) 
        stop("empty model supplied")
    r <- max(p, q + 1)
    if (p > 0) {
        if (r > 1) {
            if (r > p) {
                ar <- c(ar, rep(0, r - p))
                p <- r
            }
            A <- matrix(0, p + 1L, 2L * p + 1L)
            ind <- as.matrix(expand.grid(1L:(p + 1), 1L:(p + 
                1)))[, 2L:1L]
            ind[, 2] <- ind[, 1L] + ind[, 2L] - 1L
            A[ind] <- c(1, -ar)
            A[, 1L:p] <- A[, 1L:p] + A[, (2L * p + 1L):(p + 2L)]
            rhs <- c(1, rep(0, p))
            if (q > 0) {
                psi <- c(1, ARMAtoMA(ar, ma, q))
                theta <- c(1, ma, rep(0, q + 1L))
                for (k in 1 + 0:q) rhs[k] <- sum(psi * theta[k + 
                  0:q])
            }
            ind <- (p + 1):1
            Acf <- solve(A[ind, ind], rhs)
            Acf <- Acf[-1L]/Acf[1L]
        }
        else Acf <- ar
        if (lag.max > p) {
            xx <- rep(0, lag.max - p)
            Acf <- c(Acf, filter(xx, ar, "recursive", init = rev(Acf)))
        }
        Acf <- c(1, Acf[1L:lag.max])
    }
    else if (q > 0) {
        x <- c(1, ma)
        Acf <- filter(c(x, rep(0, q)), rev(x), sides = 1)[-(1L:q)]
        if (lag.max > q) 
            Acf <- c(Acf, rep(0, lag.max - q))
        Acf <- Acf/Acf[1L]
    }
    names(Acf) <- 0:lag.max
    if (pacf) 
        .C(R_uni_pacf, as.double(Acf), pacf = double(lag.max), 
            as.integer(lag.max))$pacf
    else Acf
}
<environment: namespace:stats>
> print("ARMAtoMA"); if(is.function(try(ARMAtoMA))) {ARMAtoMA;} else{ NULL};
[1] "ARMAtoMA"
function (ar = numeric(0), ma = numeric(0), lag.max) 
.Call(R_ARMAtoMA, as.double(ar), as.double(ma), as.integer(lag.max))
<environment: namespace:stats>
> print("Beta"); if(is.function(try(Beta))) {Beta;} else{ NULL};
[1] "Beta"
NULL
> print("Binomial"); if(is.function(try(Binomial))) {Binomial;} else{ NULL};
[1] "Binomial"
NULL
> print("Box.test"); if(is.function(try(Box.test))) {Box.test;} else{ NULL};
[1] "Box.test"
function (x, lag = 1, type = c("Box-Pierce", "Ljung-Box"), fitdf = 0) 
{
    if (NCOL(x) > 1) 
        stop("x is not a vector or univariate time series")
    DNAME <- deparse(substitute(x))
    type <- match.arg(type)
    cor <- acf(x, lag.max = lag, plot = FALSE, na.action = na.pass)
    n <- sum(!is.na(x))
    PARAMETER <- lag - fitdf
    obs <- cor$acf[2:(lag + 1)]
    if (type == "Box-Pierce") {
        METHOD <- "Box-Pierce test"
        STATISTIC <- n * sum(obs^2)
        PVAL <- 1 - pchisq(STATISTIC, lag - fitdf)
    }
    else {
        METHOD <- "Box-Ljung test"
        STATISTIC <- n * (n + 2) * sum(1/seq.int(n - 1, n - lag) * 
            obs^2)
        PVAL <- 1 - pchisq(STATISTIC, lag - fitdf)
    }
    names(STATISTIC) <- "X-squared"
    names(PARAMETER) <- "df"
    structure(list(statistic = STATISTIC, parameter = PARAMETER, 
        p.value = PVAL, method = METHOD, data.name = DNAME), 
        class = "htest")
}
<environment: namespace:stats>
> print("C"); if(is.function(try(C))) {C;} else{ NULL};
[1] "C"
function (object, contr, how.many, ...) 
{
    if (!nlevels(object)) 
        stop("object not interpretable as a factor")
    if (!missing(contr) && is.name(Xcontr <- substitute(contr))) 
        contr <- switch(as.character(Xcontr), poly = "contr.poly", 
            helmert = "contr.helmert", sum = "contr.sum", treatment = "contr.treatment", 
            SAS = "contr.SAS", contr)
    if (missing(contr)) {
        oc <- getOption("contrasts")
        contr <- if (length(oc) < 2L) 
            if (is.ordered(object)) 
                contr.poly
            else contr.treatment
        else oc[1 + is.ordered(object)]
    }
    if (missing(how.many) && !length(list(...))) 
        contrasts(object) <- contr
    else {
        if (is.character(contr)) 
            contr <- get(contr, mode = "function")
        if (is.function(contr)) 
            contr <- contr(nlevels(object), ...)
        contrasts(object, how.many) <- contr
    }
    object
}
<environment: namespace:stats>
> print("Cauchy"); if(is.function(try(Cauchy))) {Cauchy;} else{ NULL};
[1] "Cauchy"
NULL
> print("Chisquare"); if(is.function(try(Chisquare))) {Chisquare;} else{ NULL};
[1] "Chisquare"
NULL
> print("Distributions"); if(is.function(try(Distributions))) {Distributions;} else{ NULL};
[1] "Distributions"
NULL
> print("Exponential"); if(is.function(try(Exponential))) {Exponential;} else{ NULL};
[1] "Exponential"
NULL
> print("FDist"); if(is.function(try(FDist))) {FDist;} else{ NULL};
[1] "FDist"
NULL
> print("GammaDist"); if(is.function(try(GammaDist))) {GammaDist;} else{ NULL};
[1] "GammaDist"
NULL
> print("Geometric"); if(is.function(try(Geometric))) {Geometric;} else{ NULL};
[1] "Geometric"
NULL
> print("HoltWinters"); if(is.function(try(HoltWinters))) {HoltWinters;} else{ NULL};
[1] "HoltWinters"
function (x, alpha = NULL, beta = NULL, gamma = NULL, seasonal = c("additive", 
    "multiplicative"), start.periods = 2, l.start = NULL, b.start = NULL, 
    s.start = NULL, optim.start = c(alpha = 0.3, beta = 0.1, 
        gamma = 0.1), optim.control = list()) 
{
    x <- as.ts(x)
    seasonal <- match.arg(seasonal)
    f <- frequency(x)
    if (!is.null(alpha) && (alpha == 0)) 
        stop("cannot fit models without level ('alpha' must not be 0 or FALSE).")
    if (!all(is.null(c(alpha, beta, gamma))) && any(c(alpha, 
        beta, gamma) < 0 || c(alpha, beta, gamma) > 1)) 
        stop("'alpha', 'beta' and 'gamma' must be within the unit interval.")
    if ((is.null(gamma) || gamma > 0)) {
        if (seasonal == "multiplicative" && any(x == 0)) 
            stop("data must be non-zero for multiplicative Holt-Winters.")
        if (start.periods < 2) 
            stop("need at least 2 periods to compute seasonal start values.")
    }
    if (!is.null(gamma) && is.logical(gamma) && !gamma) {
        expsmooth <- !is.null(beta) && is.logical(beta) && !beta
        if (is.null(l.start)) 
            l.start <- if (expsmooth) 
                x[1L]
            else x[2L]
        if (is.null(b.start)) 
            if (is.null(beta) || !is.logical(beta) || beta) 
                b.start <- x[2L] - x[1L]
        start.time <- 3 - expsmooth
        s.start <- 0
    }
    else {
        start.time <- f + 1
        wind <- start.periods * f
        st <- decompose(ts(x[1L:wind], start = start(x), frequency = f), 
            seasonal)
        dat <- na.omit(st$trend)
        m <- lm(dat ~ seq_along(dat))
        if (is.null(l.start)) 
            l.start <- as.vector(coef(m)[1L])
        if (is.null(b.start)) 
            b.start <- as.vector(coef(m)[2L])
        if (is.null(s.start)) 
            s.start <- st$figure
    }
    len <- length(x) - start.time + 1
    hw <- function(alpha, beta, gamma) .C("HoltWinters", as.double(x), 
        as.integer(length(x)), as.double(alpha), as.double(beta), 
        as.double(gamma), as.integer(start.time), as.integer(!+(seasonal == 
            "multiplicative")), as.integer(f), as.integer(!is.logical(beta) || 
            beta), as.integer(!is.logical(gamma) || gamma), a = as.double(l.start), 
        b = as.double(b.start), s = as.double(s.start), SSE = as.double(0), 
        level = double(len + 1L), trend = double(len + 1L), seasonal = double(len + 
            f), PACKAGE = "stats")
    if (is.null(gamma)) {
        if (is.null(alpha)) {
            if (is.null(beta)) {
                error <- function(p) hw(p[1L], p[2L], p[3L])$SSE
                sol <- optim(optim.start, error, method = "L-BFGS-B", 
                  lower = c(0, 0, 0), upper = c(1, 1, 1), control = optim.control)
                alpha <- sol$par[1L]
                beta <- sol$par[2L]
                gamma <- sol$par[3L]
            }
            else {
                error <- function(p) hw(p[1L], beta, p[2L])$SSE
                sol <- optim(c(optim.start["alpha"], optim.start["gamma"]), 
                  error, method = "L-BFGS-B", lower = c(0, 0), 
                  upper = c(1, 1), control = optim.control)
                alpha <- sol$par[1L]
                gamma <- sol$par[2L]
            }
        }
        else {
            if (is.null(beta)) {
                error <- function(p) hw(alpha, p[1L], p[2L])$SSE
                sol <- optim(c(optim.start["beta"], optim.start["gamma"]), 
                  error, method = "L-BFGS-B", lower = c(0, 0), 
                  upper = c(1, 1), control = optim.control)
                beta <- sol$par[1L]
                gamma <- sol$par[2L]
            }
            else {
                error <- function(p) hw(alpha, beta, p)$SSE
                gamma <- optimize(error, lower = 0, upper = 1)$minimum
            }
        }
    }
    else {
        if (is.null(alpha)) {
            if (is.null(beta)) {
                error <- function(p) hw(p[1L], p[2L], gamma)$SSE
                sol <- optim(c(optim.start["alpha"], optim.start["beta"]), 
                  error, method = "L-BFGS-B", lower = c(0, 0), 
                  upper = c(1, 1), control = optim.control)
                alpha <- sol$par[1L]
                beta <- sol$par[2L]
            }
            else {
                error <- function(p) hw(p, beta, gamma)$SSE
                alpha <- optimize(error, lower = 0, upper = 1)$minimum
            }
        }
        else {
            if (is.null(beta)) {
                error <- function(p) hw(alpha, p, gamma)$SSE
                beta <- optimize(error, lower = 0, upper = 1)$minimum
            }
        }
    }
    final.fit <- hw(alpha, beta, gamma)
    fitted <- ts(cbind(xhat = final.fit$level[-len - 1], level = final.fit$level[-len - 
        1], trend = if (!is.logical(beta) || beta) 
        final.fit$trend[-len - 1], season = if (!is.logical(gamma) || 
        gamma) 
        final.fit$seasonal[1L:len]), start = start(lag(x, k = 1 - 
        start.time)), frequency = frequency(x))
    if (!is.logical(beta) || beta) 
        fitted[, 1] <- fitted[, 1] + fitted[, "trend"]
    if (!is.logical(gamma) || gamma) 
        fitted[, 1] <- if (seasonal == "multiplicative") 
            fitted[, 1] * fitted[, "season"]
        else fitted[, 1] + fitted[, "season"]
    structure(list(fitted = fitted, x = x, alpha = alpha, beta = beta, 
        gamma = gamma, coefficients = c(a = final.fit$level[len + 
            1], b = if (!is.logical(beta) || beta) final.fit$trend[len + 
            1], s = if (!is.logical(gamma) || gamma) final.fit$seasonal[len + 
            1L:f]), seasonal = seasonal, SSE = final.fit$SSE, 
        call = match.call()), class = "HoltWinters")
}
<environment: namespace:stats>
> print("Hypergeometric"); if(is.function(try(Hypergeometric))) {Hypergeometric;} else{ NULL};
[1] "Hypergeometric"
NULL
> print("IQR"); if(is.function(try(IQR))) {IQR;} else{ NULL};
[1] "IQR"
function (x, na.rm = FALSE, type = 7) 
diff(quantile(as.numeric(x), c(0.25, 0.75), na.rm = na.rm, names = FALSE, 
    type = type))
<environment: namespace:stats>
> print("KalmanLike"); if(is.function(try(KalmanLike))) {KalmanLike;} else{ NULL};
[1] "KalmanLike"
function (y, mod, nit = 0, fast = TRUE) 
{
    x <- .Call("KalmanLike", y, mod$Z, mod$a, mod$P, mod$T, mod$V, 
        mod$h, mod$Pn, as.integer(nit), FALSE, fast = fast, PACKAGE = "stats")
    names(x) <- c("ssq", "sumlog")
    s2 <- x[1L]/length(y)
    list(Lik = 0.5 * (log(x[1L]/length(y)) + x[2L]/length(y)), 
        s2 = s2)
}
<environment: namespace:stats>
> print("Logistic"); if(is.function(try(Logistic))) {Logistic;} else{ NULL};
[1] "Logistic"
NULL
> print("Lognormal"); if(is.function(try(Lognormal))) {Lognormal;} else{ NULL};
[1] "Lognormal"
NULL
> print("Multinomial"); if(is.function(try(Multinomial))) {Multinomial;} else{ NULL};
[1] "Multinomial"
NULL
> print("NLSstAsymptotic"); if(is.function(try(NLSstAsymptotic))) {NLSstAsymptotic;} else{ NULL};
[1] "NLSstAsymptotic"
function (xy) 
UseMethod("NLSstAsymptotic")
<environment: namespace:stats>
> print("NLSstClosestX"); if(is.function(try(NLSstClosestX))) {NLSstClosestX;} else{ NULL};
[1] "NLSstClosestX"
function (xy, yval) 
UseMethod("NLSstClosestX")
<environment: namespace:stats>
> print("NLSstLfAsymptote"); if(is.function(try(NLSstLfAsymptote))) {NLSstLfAsymptote;} else{ NULL};
[1] "NLSstLfAsymptote"
function (xy) 
UseMethod("NLSstLfAsymptote")
<environment: namespace:stats>
> print("NLSstRtAsymptote"); if(is.function(try(NLSstRtAsymptote))) {NLSstRtAsymptote;} else{ NULL};
[1] "NLSstRtAsymptote"
function (xy) 
UseMethod("NLSstRtAsymptote")
<environment: namespace:stats>
> print("NegBinomial"); if(is.function(try(NegBinomial))) {NegBinomial;} else{ NULL};
[1] "NegBinomial"
NULL
> print("Normal"); if(is.function(try(Normal))) {Normal;} else{ NULL};
[1] "Normal"
NULL
> print("PP.test"); if(is.function(try(PP.test))) {PP.test;} else{ NULL};
[1] "PP.test"
function (x, lshort = TRUE) 
{
    if (NCOL(x) > 1) 
        stop("x is not a vector or univariate time series")
    DNAME <- deparse(substitute(x))
    z <- embed(x, 2)
    yt <- z[, 1]
    yt1 <- z[, 2]
    n <- length(yt)
    tt <- (1L:n) - n/2
    res <- lm(yt ~ 1 + tt + yt1)
    if (res$rank < 3) 
        stop("singularities in regression")
    res.sum <- summary(res)
    tstat <- (res.sum$coefficients[3, 1] - 1)/res.sum$coefficients[3, 
        2]
    u <- residuals(res)
    ssqru <- sum(u^2)/n
    if (lshort) 
        l <- trunc(4 * (n/100)^0.25)
    else l <- trunc(12 * (n/100)^0.25)
    ssqrtl <- .C("R_pp_sum", as.vector(u, mode = "double"), as.integer(n), 
        as.integer(l), trm = as.double(ssqru), PACKAGE = "stats")
    ssqrtl <- ssqrtl$trm
    n2 <- n^2
    trm1 <- n2 * (n2 - 1) * sum(yt1^2)/12
    trm2 <- n * sum(yt1 * (1L:n))^2
    trm3 <- n * (n + 1) * sum(yt1 * (1L:n)) * sum(yt1)
    trm4 <- (n * (n + 1) * (2 * n + 1) * sum(yt1)^2)/6
    Dx <- trm1 - trm2 + trm3 - trm4
    STAT <- sqrt(ssqru)/sqrt(ssqrtl) * tstat - (n^3)/(4 * sqrt(3) * 
        sqrt(Dx) * sqrt(ssqrtl)) * (ssqrtl - ssqru)
    table <- cbind(c(4.38, 4.15, 4.04, 3.99, 3.98, 3.96), c(3.95, 
        3.8, 3.73, 3.69, 3.68, 3.66), c(3.6, 3.5, 3.45, 3.43, 
        3.42, 3.41), c(3.24, 3.18, 3.15, 3.13, 3.13, 3.12), c(1.14, 
        1.19, 1.22, 1.23, 1.24, 1.25), c(0.8, 0.87, 0.9, 0.92, 
        0.93, 0.94), c(0.5, 0.58, 0.62, 0.64, 0.65, 0.66), c(0.15, 
        0.24, 0.28, 0.31, 0.32, 0.33))
    table <- -table
    tablen <- dim(table)[2L]
    tableT <- c(25, 50, 100, 250, 500, 1e+05)
    tablep <- c(0.01, 0.025, 0.05, 0.1, 0.9, 0.95, 0.975, 0.99)
    tableipl <- numeric(tablen)
    for (i in (1L:tablen)) tableipl[i] <- approx(tableT, table[, 
        i], n, rule = 2)$y
    PVAL <- approx(tableipl, tablep, STAT, rule = 2)$y
    PARAMETER <- l
    METHOD <- "Phillips-Perron Unit Root Test"
    names(STAT) <- "Dickey-Fuller"
    names(PARAMETER) <- "Truncation lag parameter"
    structure(list(statistic = STAT, parameter = PARAMETER, p.value = PVAL, 
        method = METHOD, data.name = DNAME), class = "htest")
}
<environment: namespace:stats>
> print("Poisson"); if(is.function(try(Poisson))) {Poisson;} else{ NULL};
[1] "Poisson"
NULL
> print("SSD"); if(is.function(try(SSD))) {SSD;} else{ NULL};
[1] "SSD"
function (object, ...) 
UseMethod("SSD")
<environment: namespace:stats>
> print("SSasymp"); if(is.function(try(SSasymp))) {SSasymp;} else{ NULL};
[1] "SSasymp"
function (input, Asym, R0, lrc) 
{
    .expr1 <- R0 - Asym
    .expr2 <- exp(lrc)
    .expr5 <- exp(((-.expr2) * input))
    .value <- Asym + (.expr1 * .expr5)
    .actualArgs <- as.list(match.call()[c("Asym", "R0", "lrc")])
    if (all(unlist(lapply(.actualArgs, is.name)))) {
        .grad <- array(0, c(length(.value), 3L), list(NULL, c("Asym", 
            "R0", "lrc")))
        .grad[, "Asym"] <- 1 - .expr5
        .grad[, "R0"] <- .expr5
        .grad[, "lrc"] <- -(.expr1 * (.expr5 * (.expr2 * input)))
        dimnames(.grad) <- list(NULL, .actualArgs)
        attr(.value, "gradient") <- .grad
    }
    .value
}
<environment: namespace:stats>
attr(,"initial")
function (mCall, data, LHS) 
{
    xy <- sortedXyData(mCall[["input"]], LHS, data)
    if (nrow(xy) < 3) {
        stop("too few distinct input values to fit an asymptotic regression model")
    }
    if (nrow(xy) > 3) {
        xy$ydiff <- abs(xy$y - NLSstRtAsymptote(xy))
        xy <- data.frame(xy)
        lrc <- log(-coef(lm(log(ydiff) ~ x, data = xy))[2L])
        names(lrc) <- NULL
        pars <- coef(nls(y ~ cbind(1 - exp(-exp(lrc) * x), exp(-exp(lrc) * 
            x)), data = xy, start = list(lrc = lrc), algorithm = "plinear"))
    }
    else {
        ydiff <- diff(xy$y)
        if (prod(ydiff) <= 0) {
            stop("cannot fit an asymptotic regression model to these data")
        }
        avg.resp <- xy$y
        frac <- (avg.resp[3L] - avg.resp[1L])/(avg.resp[2L] - 
            avg.resp[1L])
        xunique <- unique(xy$x)
        xdiff <- diff(xunique)
        if (xdiff[1L] == xdiff[2L]) {
            expmRd <- frac - 1
            rc <- -log(expmRd)/xdiff[1L]
            lrc <- log(rc)
            expmRx1 <- exp(-rc * xunique[1L])
            bma <- ydiff[1L]/(expmRx1 * (expmRd - 1))
            Asym <- avg.resp[1L] - bma * expmRx1
            pars <- c(lrc = lrc, Asym = Asym, R0 = bma + Asym)
        }
        else {
            stop("too few observations to fit an asymptotic regression model")
        }
    }
    names(pars) <- NULL
    val <- list(pars[2L], pars[3L], pars[1L])
    names(val) <- mCall[c("Asym", "R0", "lrc")]
    val
}
<environment: namespace:stats>
attr(,"pnames")
[1] "Asym" "R0"   "lrc" 
attr(,"class")
[1] "selfStart"
> print("SSasympOff"); if(is.function(try(SSasympOff))) {SSasympOff;} else{ NULL};
[1] "SSasympOff"
function (input, Asym, lrc, c0) 
{
    .expr1 <- exp(lrc)
    .expr3 <- input - c0
    .expr5 <- exp(((-.expr1) * .expr3))
    .expr6 <- 1 - .expr5
    .value <- Asym * .expr6
    .actualArgs <- as.list(match.call()[c("Asym", "lrc", "c0")])
    if (all(unlist(lapply(.actualArgs, is.name)))) {
        .grad <- array(0, c(length(.value), 3L), list(NULL, c("Asym", 
            "lrc", "c0")))
        .grad[, "Asym"] <- .expr6
        .grad[, "lrc"] <- Asym * (.expr5 * (.expr1 * .expr3))
        .grad[, "c0"] <- -(Asym * (.expr5 * .expr1))
        dimnames(.grad) <- list(NULL, .actualArgs)
        attr(.value, "gradient") <- .grad
    }
    .value
}
<environment: namespace:stats>
attr(,"initial")
function (mCall, data, LHS) 
{
    xy <- sortedXyData(mCall[["input"]], LHS, data)
    if (nrow(xy) < 4) {
        stop("too few distinct input values to fit the 'asympOff' model")
    }
    xy$ydiff <- abs(xy$y - NLSstRtAsymptote(xy))
    xy <- data.frame(xy)
    lrc <- log(-coef(lm(log(ydiff) ~ x, data = xy))[2L])
    pars <- as.vector(coef(nls(y ~ cbind(1, exp(-exp(lrc) * x)), 
        data = xy, algorithm = "plinear", start = list(lrc = lrc))))
    val <- list(pars[2L], pars[1L], exp(-pars[1L]) * log(-pars[3L]/pars[2L]))
    names(val) <- mCall[c("Asym", "lrc", "c0")]
    val
}
<environment: namespace:stats>
attr(,"pnames")
[1] "Asym" "lrc"  "c0"  
attr(,"class")
[1] "selfStart"
> print("SSasympOrig"); if(is.function(try(SSasympOrig))) {SSasympOrig;} else{ NULL};
[1] "SSasympOrig"
function (input, Asym, lrc) 
{
    .expr1 <- exp(lrc)
    .expr4 <- exp(((-.expr1) * input))
    .expr5 <- 1 - .expr4
    .value <- Asym * .expr5
    .actualArgs <- as.list(match.call()[c("Asym", "lrc")])
    if (all(unlist(lapply(.actualArgs, is.name)))) {
        .grad <- array(0, c(length(.value), 2L), list(NULL, c("Asym", 
            "lrc")))
        .grad[, "Asym"] <- .expr5
        .grad[, "lrc"] <- Asym * (.expr4 * (.expr1 * input))
        dimnames(.grad) <- list(NULL, .actualArgs)
        attr(.value, "gradient") <- .grad
    }
    .value
}
<environment: namespace:stats>
attr(,"initial")
function (mCall, data, LHS) 
{
    xy <- sortedXyData(mCall[["input"]], LHS, data)
    if (nrow(xy) < 3) {
        stop("too few distinct input values to fit the 'asympOrig' model")
    }
    A0 <- NLSstRtAsymptote(xy)
    lrc <- log(abs(mean(log(1 - xy$y/A0)/xy$x, na.rm = TRUE)))
    xy <- data.frame(xy)
    pars <- as.vector(coef(nls(y ~ 1 - exp(-exp(lrc) * x), data = xy, 
        start = list(lrc = lrc), algorithm = "plinear")))
    value <- c(pars[2L], pars[1L])
    names(value) <- mCall[c("Asym", "lrc")]
    value
}
<environment: namespace:stats>
attr(,"pnames")
[1] "Asym" "lrc" 
attr(,"class")
[1] "selfStart"
> print("SSbiexp"); if(is.function(try(SSbiexp))) {SSbiexp;} else{ NULL};
[1] "SSbiexp"
function (input, A1, lrc1, A2, lrc2) 
{
    .expr1 <- exp(lrc1)
    .expr4 <- exp(((-.expr1) * input))
    .expr6 <- exp(lrc2)
    .expr9 <- exp(((-.expr6) * input))
    .value <- (A1 * .expr4) + (A2 * .expr9)
    .actualArgs <- as.list(match.call()[c("A1", "lrc1", "A2", 
        "lrc2")])
    if (all(unlist(lapply(.actualArgs, is.name)))) {
        .grad <- array(0, c(length(.value), 4L), list(NULL, c("A1", 
            "lrc1", "A2", "lrc2")))
        .grad[, "A1"] <- .expr4
        .grad[, "lrc1"] <- -(A1 * (.expr4 * (.expr1 * input)))
        .grad[, "A2"] <- .expr9
        .grad[, "lrc2"] <- -(A2 * (.expr9 * (.expr6 * input)))
        dimnames(.grad) <- list(NULL, .actualArgs)
        attr(.value, "gradient") <- .grad
    }
    .value
}
<environment: namespace:stats>
attr(,"initial")
function (mCall, data, LHS) 
{
    xy <- data.frame(sortedXyData(mCall[["input"]], LHS, data))
    if (nrow(xy) < 5) {
        stop("too few distinct input values to fit a biexponential")
    }
    ndistinct <- nrow(xy)
    nlast <- max(3, round(ndistinct/2))
    dlast <- xy[(ndistinct + 1 - nlast):ndistinct, ]
    pars2 <- coef(lm(log(y) ~ x, data = dlast))
    lrc2 <- log(abs(pars2[2L]))
    xy[["res"]] <- xy[["y"]] - exp(pars2[1L]) * exp(-exp(lrc2) * 
        xy[["x"]])
    dfirst <- xy[1L:(ndistinct - nlast), ]
    pars1 <- coef(lm(log(abs(res)) ~ x, data = dfirst))
    lrc1 <- log(abs(pars1[2L]))
    pars <- coef(nls(y ~ cbind(exp(-exp(lrc1) * x), exp(-exp(lrc2) * 
        x)), data = xy, start = list(lrc1 = lrc1, lrc2 = lrc2), 
        algorithm = "plinear"))
    value <- c(pars[3L], pars[1L], pars[4L], pars[2L])
    names(value) <- mCall[c("A1", "lrc1", "A2", "lrc2")]
    value
}
<environment: namespace:stats>
attr(,"pnames")
[1] "A1"   "lrc1" "A2"   "lrc2"
attr(,"class")
[1] "selfStart"
> print("SSfol"); if(is.function(try(SSfol))) {SSfol;} else{ NULL};
[1] "SSfol"
function (Dose, input, lKe, lKa, lCl) 
{
    .expr4 <- Dose * exp((lKe + lKa) - lCl)
    .expr5 <- exp(lKe)
    .expr8 <- exp(-.expr5 * input)
    .expr9 <- exp(lKa)
    .expr12 <- exp(-.expr9 * input)
    .expr14 <- .expr4 * (.expr8 - .expr12)
    .expr15 <- .expr9 - .expr5
    .expr16 <- .expr14/.expr15
    .expr23 <- .expr15^2
    .value <- .expr16
    .actualArgs <- as.list(match.call()[c("lKe", "lKa", "lCl")])
    if (all(unlist(lapply(.actualArgs, is.name)))) {
        .grad <- array(0, c(length(.value), 3L), list(NULL, c("lKe", 
            "lKa", "lCl")))
        .grad[, "lKe"] <- (.expr14 - .expr4 * (.expr8 * (.expr5 * 
            input)))/.expr15 + .expr14 * .expr5/.expr23
        .grad[, "lKa"] <- (.expr14 + .expr4 * (.expr12 * (.expr9 * 
            input)))/.expr15 - .expr14 * .expr9/.expr23
        .grad[, "lCl"] <- -.expr16
        dimnames(.grad) <- list(NULL, .actualArgs)
        attr(.value, "gradient") <- .grad
    }
    .value
}
<environment: namespace:stats>
attr(,"initial")
function (mCall, data, LHS) 
{
    data <- data.frame(data)
    resp <- eval(LHS, data)
    input <- eval(mCall[["input"]], data)
    Dose <- eval(mCall[["Dose"]], data)
    n <- length(resp)
    if (length(input) != n) {
        stop("must have length of response = length of second argument to 'SSfol'")
    }
    if (n < 4) {
        stop("must have at least 4 observations to fit an 'SSfol' model")
    }
    rmaxind <- order(resp)[n]
    lresp <- log(resp)
    if (rmaxind == n) {
        lKe <- -2.5
    }
    else {
        lKe <- log((lresp[rmaxind] - lresp[n])/(input[n] - input[rmaxind]))
    }
    cond.lin <- nls(resp ~ (exp(-input * exp(lKe)) - exp(-input * 
        exp(lKa))) * Dose, data = list(resp = resp, input = input, 
        Dose = Dose, lKe = lKe), start = list(lKa = lKe + 1), 
        algorithm = "plinear")
    pars <- coef(cond.lin)
    names(pars) <- NULL
    cond.lin <- nls(resp ~ (Dose * (exp(-input * exp(lKe)) - 
        exp(-input * exp(lKa))))/(exp(lKa) - exp(lKe)), data = data.frame(list(resp = resp, 
        input = input, Dose = Dose)), start = list(lKa = pars[1L], 
        lKe = lKe), algorithm = "plinear")
    pars <- coef(cond.lin)
    names(pars) <- NULL
    lKa <- pars[1L]
    lKe <- pars[2L]
    Ka <- exp(lKa)
    Ke <- exp(lKe)
    value <- list(lKe, lKa, log((Ke * Ka)/(pars[3L])))
    names(value) <- as.character(mCall)[4:6]
    value
}
<environment: namespace:stats>
attr(,"pnames")
[1] "lKe" "lKa" "lCl"
attr(,"class")
[1] "selfStart"
> print("SSfpl"); if(is.function(try(SSfpl))) {SSfpl;} else{ NULL};
[1] "SSfpl"
function (input, A, B, xmid, scal) 
{
    .expr1 <- B - A
    .expr2 <- xmid - input
    .expr4 <- exp(.expr2/scal)
    .expr5 <- 1 + .expr4
    .expr8 <- 1/.expr5
    .expr13 <- .expr5^2
    .value <- A + .expr1/.expr5
    .actualArgs <- as.list(match.call()[c("A", "B", "xmid", "scal")])
    if (all(unlist(lapply(.actualArgs, is.name)))) {
        .grad <- array(0, c(length(.value), 4L), list(NULL, c("A", 
            "B", "xmid", "scal")))
        .grad[, "A"] <- 1 - .expr8
        .grad[, "B"] <- .expr8
        .grad[, "xmid"] <- -(.expr1 * (.expr4 * (1/scal))/.expr13)
        .grad[, "scal"] <- .expr1 * (.expr4 * (.expr2/scal^2))/.expr13
        dimnames(.grad) <- list(NULL, .actualArgs)
        attr(.value, "gradient") <- .grad
    }
    .value
}
<environment: namespace:stats>
attr(,"initial")
function (mCall, data, LHS) 
{
    xy <- sortedXyData(mCall[["input"]], LHS, data)
    if (nrow(xy) < 5) {
        stop("too few distinct input values to fit a four-parameter logistic")
    }
    rng <- range(xy$y)
    drng <- diff(rng)
    xy$prop <- (xy$y - rng[1L] + 0.05 * drng)/(1.1 * drng)
    ir <- as.vector(coef(lm(x ~ I(log(prop/(1 - prop))), data = xy)))
    pars <- as.vector(coef(nls(y ~ cbind(1, 1/(1 + exp((xmid - 
        x)/exp(lscal)))), data = xy, start = list(xmid = ir[1L], 
        lscal = log(abs(ir[2L]))), algorithm = "plinear")))
    value <- c(pars[3L], pars[3L] + pars[4L], pars[1L], exp(pars[2L]))
    names(value) <- mCall[c("A", "B", "xmid", "scal")]
    value
}
<environment: namespace:stats>
attr(,"pnames")
[1] "A"    "B"    "xmid" "scal"
attr(,"class")
[1] "selfStart"
> print("SSgompertz"); if(is.function(try(SSgompertz))) {SSgompertz;} else{ NULL};
[1] "SSgompertz"
function (x, Asym, b2, b3) 
{
    .expr2 <- b3^x
    .expr4 <- exp(-b2 * .expr2)
    .value <- Asym * .expr4
    .actualArgs <- as.list(match.call()[c("Asym", "b2", "b3")])
    if (all(unlist(lapply(.actualArgs, is.name)))) {
        .grad <- array(0, c(length(.value), 3L), list(NULL, c("Asym", 
            "b2", "b3")))
        .grad[, "Asym"] <- .expr4
        .grad[, "b2"] <- -Asym * (.expr4 * .expr2)
        .grad[, "b3"] <- -Asym * (.expr4 * (b2 * (b3^(x - 1) * 
            x)))
        dimnames(.grad) <- list(NULL, .actualArgs)
        attr(.value, "gradient") <- .grad
    }
    .value
}
<environment: namespace:stats>
attr(,"initial")
function (mCall, data, LHS) 
{
    xy <- sortedXyData(mCall[["x"]], LHS, data)
    if (nrow(xy) < 4) {
        stop("too few distinct input values to fit the Gompertz model")
    }
    xyL <- xy
    xyL$y <- log(abs(xyL$y))
    pars <- NLSstAsymptotic(xyL)
    pars <- coef(nls(y ~ exp(-b2 * b3^x), data = xy, algorithm = "plinear", 
        start = c(b2 = pars[["b1"]], b3 = exp(-exp(pars[["lrc"]])))))
    val <- pars[c(3, 1, 2)]
    names(val) <- mCall[c("Asym", "b2", "b3")]
    val
}
<environment: namespace:stats>
attr(,"pnames")
[1] "Asym" "b2"   "b3"  
attr(,"class")
[1] "selfStart"
> print("SSlogis"); if(is.function(try(SSlogis))) {SSlogis;} else{ NULL};
[1] "SSlogis"
function (input, Asym, xmid, scal) 
{
    .expr1 <- xmid - input
    .expr3 <- exp(.expr1/scal)
    .expr4 <- 1 + .expr3
    .expr10 <- .expr4^2
    .value <- Asym/.expr4
    .actualArgs <- as.list(match.call()[c("Asym", "xmid", "scal")])
    if (all(unlist(lapply(.actualArgs, is.name)))) {
        .grad <- array(0, c(length(.value), 3L), list(NULL, c("Asym", 
            "xmid", "scal")))
        .grad[, "Asym"] <- 1/.expr4
        .grad[, "xmid"] <- -(Asym * (.expr3 * (1/scal))/.expr10)
        .grad[, "scal"] <- Asym * (.expr3 * (.expr1/scal^2))/.expr10
        dimnames(.grad) <- list(NULL, .actualArgs)
        attr(.value, "gradient") <- .grad
    }
    .value
}
<environment: namespace:stats>
attr(,"initial")
function (mCall, data, LHS) 
{
    xy <- data.frame(sortedXyData(mCall[["input"]], LHS, data))
    if (nrow(xy) < 4) {
        stop("too few distinct input values to fit a logistic model")
    }
    z <- xy[["y"]]
    if (min(z) <= 0) {
        z <- z - 1.05 * min(z)
    }
    z <- z/(1.05 * max(z))
    xy[["z"]] <- log(z/(1 - z))
    aux <- coef(lm(x ~ z, xy))
    pars <- as.vector(coef(nls(y ~ 1/(1 + exp((xmid - x)/scal)), 
        data = xy, start = list(xmid = aux[1L], scal = aux[2L]), 
        algorithm = "plinear")))
    value <- c(pars[3L], pars[1L], pars[2L])
    names(value) <- mCall[c("Asym", "xmid", "scal")]
    value
}
<environment: namespace:stats>
attr(,"pnames")
[1] "Asym" "xmid" "scal"
attr(,"class")
[1] "selfStart"
> print("SSmicmen"); if(is.function(try(SSmicmen))) {SSmicmen;} else{ NULL};
[1] "SSmicmen"
function (input, Vm, K) 
{
    .expr1 <- Vm * input
    .expr2 <- K + input
    .value <- .expr1/.expr2
    .actualArgs <- as.list(match.call()[c("Vm", "K")])
    if (all(unlist(lapply(.actualArgs, is.name)))) {
        .grad <- array(0, c(length(.value), 2L), list(NULL, c("Vm", 
            "K")))
        .grad[, "Vm"] <- input/.expr2
        .grad[, "K"] <- -(.expr1/.expr2^2)
        dimnames(.grad) <- list(NULL, .actualArgs)
        attr(.value, "gradient") <- .grad
    }
    .value
}
<environment: namespace:stats>
attr(,"initial")
function (mCall, data, LHS) 
{
    xy <- data.frame(sortedXyData(mCall[["input"]], LHS, data))
    if (nrow(xy) < 3) {
        stop("too few distinct input values to fit a Michaelis-Menten model")
    }
    pars <- as.vector(coef(lm(1/y ~ I(1/x), data = xy)))
    pars <- as.vector(coef(nls(y ~ x/(K + x), data = xy, start = list(K = abs(pars[2L]/pars[1L])), 
        algorithm = "plinear")))
    value <- c(pars[2L], pars[1L])
    names(value) <- mCall[c("Vm", "K")]
    value
}
<environment: namespace:stats>
attr(,"pnames")
[1] "Vm" "K" 
attr(,"class")
[1] "selfStart"
> print("SSweibull"); if(is.function(try(SSweibull))) {SSweibull;} else{ NULL};
[1] "SSweibull"
function (x, Asym, Drop, lrc, pwr) 
{
    .expr1 <- exp(lrc)
    .expr3 <- x^pwr
    .expr5 <- exp(-.expr1 * .expr3)
    .value <- Asym - Drop * .expr5
    .actualArgs <- as.list(match.call()[c("Asym", "Drop", "lrc", 
        "pwr")])
    if (all(unlist(lapply(.actualArgs, is.name)))) {
        .grad <- array(0, c(length(.value), 4L), list(NULL, c("Asym", 
            "Drop", "lrc", "pwr")))
        .grad[, "Asym"] <- 1
        .grad[, "Drop"] <- -.expr5
        .grad[, "lrc"] <- Drop * (.expr5 * (.expr1 * .expr3))
        .grad[, "pwr"] <- Drop * (.expr5 * (.expr1 * (.expr3 * 
            log(x))))
        dimnames(.grad) <- list(NULL, .actualArgs)
        attr(.value, "gradient") <- .grad
    }
    .value
}
<environment: namespace:stats>
attr(,"initial")
function (mCall, data, LHS) 
{
    xy <- sortedXyData(mCall[["x"]], LHS, data)
    if (nrow(xy) < 5) {
        stop("too few distinct input values to fit the Weibull growth model")
    }
    if (any(xy[["x"]] < 0)) {
        stop("all 'x' values must be non-negative to fit the Weibull growth model")
    }
    Rasym <- NLSstRtAsymptote(xy)
    Lasym <- NLSstLfAsymptote(xy)
    pars <- coef(lm(log(-log((Rasym - y)/(Rasym - Lasym))) ~ 
        log(x), data = xy, subset = x > 0))
    val <- coef(nls(y ~ cbind(1, -exp(-exp(lrc) * x^pwr)), data = xy, 
        algorithm = "plinear", start = c(lrc = pars[[1L]], pwr = pars[[2L]])))[c(3, 
        4, 1, 2)]
    names(val) <- mCall[c("Asym", "Drop", "lrc", "pwr")]
    val
}
<environment: namespace:stats>
attr(,"pnames")
[1] "Asym" "Drop" "lrc"  "pwr" 
attr(,"class")
[1] "selfStart"
> print("SignRank"); if(is.function(try(SignRank))) {SignRank;} else{ NULL};
[1] "SignRank"
NULL
> print("StructTS"); if(is.function(try(StructTS))) {StructTS;} else{ NULL};
[1] "StructTS"
function (x, type = c("level", "trend", "BSM"), init = NULL, 
    fixed = NULL, optim.control = NULL) 
{
    KalmanLike2 <- function(y, mod, nit = 0) {
        x <- .Call(R_KalmanLike, y, mod$Z, mod$a, mod$P, mod$T, 
            mod$V, mod$h, mod$Pn, as.integer(nit), FALSE, fast = TRUE)
        0.5 * sum(x)/length(y)
    }
    makeLevel <- function(x) {
        T <- matrix(1, 1L, 1L)
        Z <- 1
        xm <- if (is.na(x[1L])) 
            mean(x, na.rm = TRUE)
        else x[1L]
        if (is.na(xm)) 
            stop("the series is entirely NA")
        a <- xm
        P <- Pn <- matrix(0, 1L, 1L)
        h <- 1
        V <- diag(1)
        return(list(Z = Z, a = a, P = P, T = T, V = V, h = h, 
            Pn = Pn))
    }
    makeTrend <- function(x) {
        T <- matrix(c(1, 0, 1, 1), 2L, 2L)
        Z <- c(1, 0)
        xm <- if (is.na(x[1L])) 
            mean(x, na.rm = TRUE)
        else x[1L]
        if (is.na(xm)) 
            stop("the series is entirely NA")
        a <- c(xm, 0)
        P <- Pn <- matrix(0, 2L, 2L)
        h <- 1
        V <- diag(2)
        return(list(Z = Z, a = a, P = P, T = T, V = V, h = h, 
            Pn = Pn))
    }
    makeBSM <- function(x, nf) {
        if (nf <= 1L) 
            stop("frequency must be a positive integer >= 2 for BSM")
        T <- matrix(0, nf + 1L, nf + 1L)
        T[1L:2L, 1L:2L] <- c(1, 0, 1, 1)
        T[3L, ] <- c(0, 0, rep(-1, nf - 1L))
        if (nf >= 3L) {
            ind <- 3:nf
            T[cbind(ind + 1L, ind)] <- 1
        }
        Z <- c(1, 0, 1, rep(0, nf - 2L))
        xm <- if (is.na(x[1L])) 
            mean(x, na.rm = TRUE)
        else x[1L]
        if (is.na(xm)) 
            stop("the series is entirely NA")
        a <- c(xm, rep(0, nf))
        P <- Pn <- matrix(0, nf + 1L, nf + 1L)
        h <- 1
        V <- diag(c(1, 1, 1, rep(0, nf - 2L)))
        return(list(Z = Z, a = a, P = P, T = T, V = V, h = h, 
            Pn = Pn))
    }
    getLike <- function(par) {
        p <- cf
        p[mask] <- par
        if (all(p == 0)) 
            return(1000)
        Z$V[cbind(1L:np, 1L:np)] <- p[-(np + 1L)] * vx
        Z$h <- p[np + 1] * vx
        Z$P[] <- 1e+06 * vx
        Z$a <- a0
        KalmanLike2(y, Z, -1)
    }
    series <- deparse(substitute(x))
    if (NCOL(x) > 1L) 
        stop("only implemented for univariate time series")
    x <- as.ts(x)
    if (!is.numeric(x)) 
        stop("'x' must be numeric")
    storage.mode(x) <- "double"
    if (is.na(x[1L])) 
        stop("the first value of the time series must not be missing")
    type <- if (missing(type)) 
        if (frequency(x) > 1) 
            "BSM"
        else "trend"
    else match.arg(type)
    dim(x) <- NULL
    xtsp <- tsp(x)
    nf <- frequency(x)
    Z <- switch(type, level = makeLevel(x), trend = makeTrend(x), 
        BSM = makeBSM(x, nf))
    a0 <- Z$a
    vx <- var(x, na.rm = TRUE)/100
    np <- switch(type, level = 1L, trend = 2L, BSM = 3L)
    if (is.null(fixed)) 
        fixed <- rep(NA_real_, np + 1L)
    mask <- is.na(fixed)
    if (!any(mask)) 
        stop("all parameters were fixed")
    cf <- fixed/vx
    if (is.null(init)) 
        init <- rep(1, np + 1)
    else init <- init/vx
    y <- x
    res <- optim(init[mask], getLike, method = "L-BFGS-B", lower = rep(0, 
        np + 1L), upper = rep(Inf, np + 1L), control = optim.control)
    if (res$convergence > 0) 
        warning("possible convergence problem: optim gave code=", 
            res$convergence, " ", res$message)
    coef <- cf
    coef[mask] <- res$par
    Z$V[cbind(1L:np, 1L:np)] <- coef[1L:np] * vx
    Z$h <- coef[np + 1] * vx
    Z$P[] <- 1e+06 * vx
    Z$a <- a0
    z <- KalmanRun(y, Z, -1)
    resid <- ts(z$resid)
    tsp(resid) <- xtsp
    Z0 <- Z
    Z0$P[] <- 1e+06 * vx
    Z0$a <- a0
    cn <- switch(type, level = c("level"), trend = c("level", 
        "slope"), BSM = c("level", "slope", "sea"))
    states <- z$states
    if (type == "BSM") 
        states <- states[, 1L:3L]
    dimnames(states) <- list(time(x), cn)
    states <- ts(states, start = xtsp[1L], frequency = nf)
    coef <- pmax(coef * vx, 0)
    names(coef) <- switch(type, level = c("level", "epsilon"), 
        trend = c("level", "slope", "epsilon"), BSM = c("level", 
            "slope", "seas", "epsilon"))
    loglik <- -length(y) * res$value + length(y) * log(2 * pi)
    res <- list(coef = coef, loglik = loglik, data = y, residuals = resid, 
        fitted = states, call = match.call(), series = series, 
        code = res$convergence, model = Z, model0 = Z0, xtsp = xtsp)
    class(res) <- "StructTS"
    res
}
<environment: namespace:stats>
> print("TDist"); if(is.function(try(TDist))) {TDist;} else{ NULL};
[1] "TDist"
NULL
> print("Tukey"); if(is.function(try(Tukey))) {Tukey;} else{ NULL};
[1] "Tukey"
NULL
> print("TukeyHSD"); if(is.function(try(TukeyHSD))) {TukeyHSD;} else{ NULL};
[1] "TukeyHSD"
function (x, which, ordered = FALSE, conf.level = 0.95, ...) 
UseMethod("TukeyHSD")
<environment: namespace:stats>
> print("Uniform"); if(is.function(try(Uniform))) {Uniform;} else{ NULL};
[1] "Uniform"
NULL
> print("Weibull"); if(is.function(try(Weibull))) {Weibull;} else{ NULL};
[1] "Weibull"
NULL
> print("Wilcoxon"); if(is.function(try(Wilcoxon))) {Wilcoxon;} else{ NULL};
[1] "Wilcoxon"
NULL
> print("acf"); if(is.function(try(acf))) {acf;} else{ NULL};
[1] "acf"
function (x, lag.max = NULL, type = c("correlation", "covariance", 
    "partial"), plot = TRUE, na.action = na.fail, demean = TRUE, 
    ...) 
{
    type <- match.arg(type)
    if (type == "partial") {
        m <- match.call()
        m[[1L]] <- as.name("pacf")
        m$type <- NULL
        return(eval(m, parent.frame()))
    }
    series <- deparse(substitute(x))
    x <- na.action(as.ts(x))
    x.freq <- frequency(x)
    x <- as.matrix(x)
    if (!is.numeric(x)) 
        stop("'x' must be numeric")
    sampleT <- nrow(x)
    nser <- ncol(x)
    if (is.null(lag.max)) 
        lag.max <- floor(10 * (log10(sampleT) - log10(nser)))
    lag.max <- min(lag.max, sampleT - 1)
    if (lag.max < 0) 
        stop("'lag.max' must be at least 0")
    if (demean) 
        x <- sweep(x, 2, colMeans(x, na.rm = TRUE), check.margin = FALSE)
    lag <- matrix(1, nser, nser)
    lag[lower.tri(lag)] <- -1
    acf <- array(.C(R_acf, as.double(x), as.integer(sampleT), 
        as.integer(nser), as.integer(lag.max), as.integer(type == 
            "correlation"), acf = double((lag.max + 1L) * nser * 
            nser), NAOK = TRUE)$acf, c(lag.max + 1L, nser, nser))
    lag <- outer(0:lag.max, lag/x.freq)
    acf.out <- structure(.Data = list(acf = acf, type = type, 
        n.used = sampleT, lag = lag, series = series, snames = colnames(x)), 
        class = "acf")
    if (plot) {
        plot.acf(acf.out, ...)
        return(invisible(acf.out))
    }
    else return(acf.out)
}
<environment: namespace:stats>
> print("acf2AR"); if(is.function(try(acf2AR))) {acf2AR;} else{ NULL};
[1] "acf2AR"
function (acf) 
{
    r <- as.double(drop(acf))
    order.max <- length(r) - 1
    if (order.max <= 0) 
        stop("'acf' must be of length two or more")
    z <- .Fortran(R_eureka, as.integer(order.max), r, r, coefs = double(order.max^2), 
        vars = double(order.max), double(order.max))
    nm <- paste("ar(", 1L:order.max, ")", sep = "")
    matrix(z$coefs, order.max, order.max, dimnames = list(nm, 
        1L:order.max))
}
<environment: namespace:stats>
> print("add1"); if(is.function(try(add1))) {add1;} else{ NULL};
[1] "add1"
function (object, scope, ...) 
UseMethod("add1")
<environment: namespace:stats>
> print("addmargins"); if(is.function(try(addmargins))) {addmargins;} else{ NULL};
[1] "addmargins"
function (A, margin = seq_along(dim(A)), FUN = sum, quiet = FALSE) 
{
    if (is.null(dim(A))) 
        stop("'A' must be an array or table")
    n.sid <- length(margin)
    miss.FUN <- missing(FUN)
    if (length(FUN) == 1 && !is.list(FUN)) {
        fname <- if (!miss.FUN) 
            deparse(substitute(FUN))
        else "Sum"
        FUN <- list(FUN)
        names(FUN) <- fname
    }
    if (!miss.FUN) {
        add.names <- function(thelist) {
            n <- names(thelist)
            if (is.null(n)) 
                n <- rep("", length(thelist))
            for (i in seq_along(thelist)[-1L]) {
                if (!is.call(thelist[[i]])) {
                  if (n[i] == "") 
                    n[i] <- as.character(thelist[[i]])
                }
                else if (as.character(thelist[[i]][[1L]]) == 
                  "list") 
                  thelist[[i]] <- add.names(thelist[[i]])
            }
            names(thelist) <- n
            thelist
        }
        if (mode(substitute(FUN)) == "call") 
            FUN <- eval(add.names(substitute(FUN)))
        if (is.null(names(FUN))) 
            names(FUN) <- rep("", length(FUN))
    }
    if (length(FUN) != n.sid) {
        if (length(FUN) == 1L) 
            FUN <- rep(FUN, n.sid)
        else stop(gettextf("length of FUN, %d,\n does not match the length of the margins, %d", 
            length(FUN), n.sid), domain = NA)
    }
    fnames <- vector("list", n.sid)
    for (i in seq_along(FUN)) {
        fnames[[i]] <- names(FUN)[i]
        if (is.list(FUN[[i]])) {
            topname <- fnames[[i]]
            fnames[[i]] <- names(FUN[[i]])
            blank <- fnames[[i]] == ""
            fnames[[i]][blank] <- seq_along(blank)[blank]
            if (topname == "") {
                fnames[[i]][blank] <- paste("Margin ", margin[i], 
                  ".", fnames[[i]][blank], sep = "")
            }
            else {
                fnames[[i]] <- paste(topname, ".", fnames[[i]], 
                  sep = "")
            }
        }
        else if (fnames[[i]] == "") 
            fnames[[i]] <- paste("Margin", margin[i])
    }
    expand.one <- function(A, margin, FUN, fnames) {
        if (class(FUN) != "list") 
            FUN <- list(FUN)
        d <- dim(A)
        n.dim <- length(d)
        n.mar <- length(FUN)
        newdim <- d
        newdim[margin] <- newdim[margin] + n.mar
        newdimnames <- dimnames(A)
        newdimnames[[margin]] <- c(newdimnames[[margin]], fnames)
        n.new <- prod(newdim)
        skip <- prod(d[1L:margin])
        runl <- skip/d[margin]
        apos <- rep(c(rep(TRUE, skip), rep(FALSE, n.mar * runl)), 
            n.new/(skip + n.mar * runl))
        values <- double(length(apos))
        values[apos] <- as.vector(A)
        for (i in 1L:n.mar) {
            mtab <- if (n.dim > 1) {
                apply(A, (1L:n.dim)[-margin], FUN[[i]])
            }
            else FUN[[i]](A)
            select <- rep(FALSE, n.mar)
            select[i] <- TRUE
            mpos <- rep(c(rep(FALSE, skip), rep(select, each = runl)), 
                prod(dim(A))/skip)
            values[mpos] <- as.vector(mtab)
        }
        new.A <- array(values, dim = newdim, dimnames = newdimnames)
        if (inherits(A, "table")) 
            class(new.A) <- c("table", class(new.A))
        new.A
    }
    new.A <- A
    for (i in 1L:n.sid) new.A <- expand.one(A = new.A, margin = margin[i], 
        FUN = FUN[[i]], fnames = fnames[[i]])
    if (!quiet && !miss.FUN && n.sid > 1) {
        cat("Margins computed over dimensions\nin the following order:\n")
        for (i in 1L:n.sid) cat(paste(i), ": ", names(dimnames(A))[margin[i]], 
            "\n", sep = "")
    }
    new.A
}
<environment: namespace:stats>
> print("aggregate"); if(is.function(try(aggregate))) {aggregate;} else{ NULL};
[1] "aggregate"
function (x, ...) 
UseMethod("aggregate")
<environment: namespace:stats>
> print("alias"); if(is.function(try(alias))) {alias;} else{ NULL};
[1] "alias"
function (object, ...) 
UseMethod("alias")
<environment: namespace:stats>
> print("anova"); if(is.function(try(anova))) {anova;} else{ NULL};
[1] "anova"
function (object, ...) 
UseMethod("anova")
<environment: namespace:stats>
> print("anova.glm"); if(is.function(try(anova.glm))) {anova.glm;} else{ NULL};
[1] "anova.glm"
function (object, ..., dispersion = NULL, test = NULL) 
{
    dotargs <- list(...)
    named <- if (is.null(names(dotargs))) 
        rep(FALSE, length(dotargs))
    else (names(dotargs) != "")
    if (any(named)) 
        warning("the following arguments to 'anova.glm' are invalid and dropped: ", 
            paste(deparse(dotargs[named]), collapse = ", "))
    dotargs <- dotargs[!named]
    is.glm <- unlist(lapply(dotargs, function(x) inherits(x, 
        "glm")))
    dotargs <- dotargs[is.glm]
    if (length(dotargs)) 
        return(anova.glmlist(c(list(object), dotargs), dispersion = dispersion, 
            test = test))
    varlist <- attr(object$terms, "variables")
    x <- if (n <- match("x", names(object), 0L)) 
        object[[n]]
    else model.matrix(object)
    varseq <- attr(x, "assign")
    nvars <- max(0, varseq)
    resdev <- resdf <- NULL
    if (nvars > 1) {
        method <- object$method
        y <- object$y
        if (is.null(y)) {
            mu.eta <- object$family$mu.eta
            eta <- object$linear.predictors
            y <- object$fitted.values + object$residuals * mu.eta(eta)
        }
        for (i in seq_len(nvars - 1L)) {
            fit <- eval(call(if (is.function(method)) "method" else method, 
                x = x[, varseq <= i, drop = FALSE], y = y, weights = object$prior.weights, 
                start = object$start, offset = object$offset, 
                family = object$family, control = object$control))
            resdev <- c(resdev, fit$deviance)
            resdf <- c(resdf, fit$df.residual)
        }
    }
    resdf <- c(object$df.null, resdf, object$df.residual)
    resdev <- c(object$null.deviance, resdev, object$deviance)
    table <- data.frame(c(NA, -diff(resdf)), c(NA, pmax(0, -diff(resdev))), 
        resdf, resdev)
    tl <- attr(object$terms, "term.labels")
    if (length(tl) == 0L) 
        table <- table[1, , drop = FALSE]
    dimnames(table) <- list(c("NULL", tl), c("Df", "Deviance", 
        "Resid. Df", "Resid. Dev"))
    title <- paste("Analysis of Deviance Table", "\n\nModel: ", 
        object$family$family, ", link: ", object$family$link, 
        "\n\nResponse: ", as.character(varlist[-1L])[1L], "\n\nTerms added sequentially (first to last)\n\n", 
        sep = "")
    df.dispersion <- Inf
    if (is.null(dispersion)) {
        dispersion <- summary(object, dispersion = dispersion)$dispersion
        df.dispersion <- if (dispersion == 1) 
            Inf
        else object$df.residual
    }
    if (!is.null(test)) {
        if (test == "F" && df.dispersion == Inf) {
            fam <- object$family$family
            if (fam == "binomial" || fam == "poisson") 
                warning(gettextf("using F test with a %s family is inappropriate", 
                  fam), domain = NA)
            else warning("using F test with a fixed dispersion is inappropriate")
        }
        table <- stat.anova(table = table, test = test, scale = dispersion, 
            df.scale = df.dispersion, n = NROW(x))
    }
    structure(table, heading = title, class = c("anova", "data.frame"))
}
<environment: namespace:stats>
> print("anova.lm"); if(is.function(try(anova.lm))) {anova.lm;} else{ NULL};
[1] "anova.lm"
function (object, ...) 
{
    if (length(list(object, ...)) > 1L) 
        return(anova.lmlist(object, ...))
    if (!inherits(object, "lm")) 
        warning("calling anova.lm(<fake-lm-object>) ...")
    w <- object$weights
    ssr <- sum(if (is.null(w)) object$residuals^2 else w * object$residuals^2)
    mss <- sum(if (is.null(w)) object$fitted.values^2 else w * 
        object$fitted.values^2)
    if (ssr < 1e-10 * mss) 
        warning("ANOVA F-tests on an essentially perfect fit are unreliable")
    dfr <- df.residual(object)
    p <- object$rank
    if (p > 0L) {
        p1 <- 1L:p
        comp <- object$effects[p1]
        asgn <- object$assign[qr.lm(object)$pivot][p1]
        nmeffects <- c("(Intercept)", attr(object$terms, "term.labels"))
        tlabels <- nmeffects[1 + unique(asgn)]
        ss <- c(unlist(lapply(split(comp^2, asgn), sum)), ssr)
        df <- c(unlist(lapply(split(asgn, asgn), length)), dfr)
    }
    else {
        ss <- ssr
        df <- dfr
        tlabels <- character()
    }
    ms <- ss/df
    f <- ms/(ssr/dfr)
    P <- pf(f, df, dfr, lower.tail = FALSE)
    table <- data.frame(df, ss, ms, f, P)
    table[length(P), 4:5] <- NA
    dimnames(table) <- list(c(tlabels, "Residuals"), c("Df", 
        "Sum Sq", "Mean Sq", "F value", "Pr(>F)"))
    if (attr(object$terms, "intercept")) 
        table <- table[-1, ]
    structure(table, heading = c("Analysis of Variance Table\n", 
        paste("Response:", deparse(formula(object)[[2L]]))), 
        class = c("anova", "data.frame"))
}
<environment: namespace:stats>
> print("anova.mlm"); if(is.function(try(anova.mlm))) {anova.mlm;} else{ NULL};
[1] "anova.mlm"
function (object, ..., test = c("Pillai", "Wilks", "Hotelling-Lawley", 
    "Roy", "Spherical"), Sigma = diag(nrow = p), T = Thin.row(proj(M) - 
    proj(X)), M = diag(nrow = p), X = ~0, idata = data.frame(index = seq_len(p)), 
    tol = 1e-07) 
{
    if (length(list(object, ...)) > 1) {
        cl <- match.call()
        cl[[1L]] <- anova.mlmlist
        return(eval.parent(cl))
    }
    else {
        p <- ncol(SSD(object)$SSD)
        Xmis <- missing(X)
        Mmis <- missing(M)
        if (missing(T)) {
            orig.M <- M
            orig.X <- X
            if (class(M) == "formula") 
                M <- model.matrix(M, idata)
            if (class(X) == "formula") 
                X <- model.matrix(X, idata)
            if (Rank(cbind(M, X)) != Rank(M)) 
                stop("X does not define a subspace of M")
        }
        title <- "Analysis of Variance Table\n"
        transformnote <- if (!missing(T)) 
            c("\nContrast matrix", apply(format(T), 1L, paste, 
                collapse = " "))
        else c(if (!Xmis) c("\nContrasts orthogonal to", if (is.matrix(orig.X)) apply(format(X), 
            2L, paste, collapse = " ") else deparse(formula(orig.X)), 
            "", if (!Mmis) c("\nContrasts spanned by", if (is.matrix(orig.M)) apply(format(M), 
                2L, paste, collapse = " ") else deparse(formula(orig.M)), 
                "")))
        epsnote <- NULL
        ssd <- SSD(object)
        rk <- object$rank
        pp <- nrow(T)
        if (rk > 0) {
            p1 <- 1L:rk
            comp <- object$effects[p1, , drop = FALSE]
            asgn <- object$assign[object$qr$pivot][p1]
            nmeffects <- c("(Intercept)", attr(object$terms, 
                "term.labels"))
            tlabels <- nmeffects[1 + unique(asgn)]
            ix <- split(seq_len(nrow(comp)), asgn)
            ss <- lapply(ix, function(i) crossprod(comp[i, , 
                drop = FALSE]))
            df <- sapply(split(asgn, asgn), length)
        }
        else {
        }
        test <- match.arg(test)
        nmodels <- length(ss)
        if (test == "Spherical") {
            df.res <- ssd$df
            sph <- sphericity(ssd, T = T, Sigma = Sigma)
            epsnote <- c(paste(format(c("Greenhouse-Geisser epsilon:", 
                "Huynh-Feldt epsilon:")), format(c(sph$GG.eps, 
                sph$HF.eps), digits = 4)), "")
            Psi <- T %*% Sigma %*% t(T)
            stats <- matrix(NA, nmodels + 1, 6L)
            colnames(stats) <- c("F", "num Df", "den Df", "Pr(>F)", 
                "G-G Pr", "H-F Pr")
            for (i in 1L:nmodels) {
                s2 <- Tr(solve(Psi, T %*% ss[[i]] %*% t(T)))/pp/df[i]
                Fval <- s2/sph$sigma
                stats[i, 1L:3L] <- abs(c(Fval, df[i] * pp, df.res * 
                  pp))
            }
            stats[, 4] <- pf(stats[, 1L], stats[, 2L], stats[, 
                3L], lower.tail = FALSE)
            stats[, 5] <- pf(stats[, 1L], stats[, 2L] * sph$GG.eps, 
                stats[, 3L] * sph$GG.eps, lower.tail = FALSE)
            stats[, 6] <- pf(stats[, 1L], stats[, 2L] * min(1, 
                sph$HF.eps), stats[, 3L] * min(1, sph$HF.eps), 
                lower.tail = FALSE)
        }
        else {
            sc <- sqrt(diag(T %*% ssd$SSD %*% t(T)))
            D <- sqrt(sc^2 + rowSums(as.matrix(sapply(ss, function(X) diag(T %*% 
                X %*% t(T))))))
            sc <- ifelse(sc/D < 1e-06, 1, 1/sc)
            scm <- tcrossprod(sc)
            df.res <- ssd$df
            rss.qr <- qr((T %*% ssd$SSD %*% t(T)) * scm, tol = tol)
            if (rss.qr$rank < pp) 
                stop("residuals have rank ", rss.qr$rank, " < ", 
                  pp)
            eigs <- array(NA, c(nmodels, pp))
            stats <- matrix(NA, nmodels + 1L, 5L)
            colnames(stats) <- c(test, "approx F", "num Df", 
                "den Df", "Pr(>F)")
            for (i in 1L:nmodels) {
                eigs[i, ] <- Re(eigen(qr.coef(rss.qr, (T %*% 
                  ss[[i]] %*% t(T)) * scm), symmetric = FALSE)$values)
                stats[i, 1L:4L] <- switch(test, Pillai = Pillai(eigs[i, 
                  ], df[i], df.res), Wilks = Wilks(eigs[i, ], 
                  df[i], df.res), `Hotelling-Lawley` = HL(eigs[i, 
                  ], df[i], df.res), Roy = Roy(eigs[i, ], df[i], 
                  df.res))
                ok <- stats[, 2L] >= 0 & stats[, 3L] > 0 & stats[, 
                  4L] > 0
                ok <- !is.na(ok) & ok
                stats[ok, 5L] <- pf(stats[ok, 2], stats[ok, 3L], 
                  stats[ok, 4L], lower.tail = FALSE)
            }
        }
        table <- data.frame(Df = c(df, ssd$df), stats, check.names = FALSE)
        row.names(table) <- c(tlabels, "Residuals")
        structure(table, heading = c(title, transformnote, epsnote), 
            class = c("anova", "data.frame"))
    }
}
<environment: namespace:stats>
> print("ansari.test"); if(is.function(try(ansari.test))) {ansari.test;} else{ NULL};
[1] "ansari.test"
function (x, ...) 
UseMethod("ansari.test")
<environment: namespace:stats>
> print("aov"); if(is.function(try(aov))) {aov;} else{ NULL};
[1] "aov"
function (formula, data = NULL, projections = FALSE, qr = TRUE, 
    contrasts = NULL, ...) 
{
    Terms <- if (missing(data)) 
        terms(formula, "Error")
    else terms(formula, "Error", data = data)
    indError <- attr(Terms, "specials")$Error
    if (length(indError) > 1L) 
        stop(sprintf(ngettext(length(indError), "there are %d Error terms: only 1 is allowed", 
            "there are %d Error terms: only 1 is allowed"), length(indError)), 
            domain = NA)
    lmcall <- Call <- match.call()
    lmcall[[1L]] <- as.name("lm")
    lmcall$singular.ok <- TRUE
    if (projections) 
        qr <- lmcall$qr <- TRUE
    lmcall$projections <- NULL
    if (is.null(indError)) {
        fit <- eval(lmcall, parent.frame())
        if (projections) 
            fit$projections <- proj(fit)
        class(fit) <- if (inherits(fit, "mlm")) 
            c("maov", "aov", oldClass(fit))
        else c("aov", oldClass(fit))
        fit$call <- Call
        return(fit)
    }
    else {
        if (pmatch("weights", names(match.call()), 0L)) 
            stop("weights are not supported in a multistratum aov() fit")
        opcons <- options("contrasts")
        options(contrasts = c("contr.helmert", "contr.poly"))
        on.exit(options(opcons))
        allTerms <- Terms
        errorterm <- attr(Terms, "variables")[[1 + indError]]
        eTerm <- deparse(errorterm[[2L]], width.cutoff = 500L, 
            backtick = TRUE)
        intercept <- attr(Terms, "intercept")
        ecall <- lmcall
        ecall$formula <- as.formula(paste(deparse(formula[[2L]], 
            width.cutoff = 500L, backtick = TRUE), "~", eTerm, 
            if (!intercept) 
                "- 1"), env = environment(formula))
        ecall$method <- "qr"
        ecall$qr <- TRUE
        ecall$contrasts <- NULL
        er.fit <- eval(ecall, parent.frame())
        options(opcons)
        nmstrata <- attr(terms(er.fit), "term.labels")
        nmstrata <- sub("^`(.*)`$", "\\1", nmstrata)
        nmstrata <- c("(Intercept)", nmstrata)
        qr.e <- er.fit$qr
        rank.e <- er.fit$rank
        if (rank.e < length(er.fit$coefficients)) 
            warning("Error() model is singular")
        qty <- er.fit$residuals
        maov <- is.matrix(qty)
        asgn.e <- er.fit$assign[qr.e$pivot[1L:rank.e]]
        maxasgn <- length(nmstrata) - 1L
        nobs <- NROW(qty)
        if (nobs > rank.e) {
            result <- vector("list", maxasgn + 2L)
            asgn.e[(rank.e + 1):nobs] <- maxasgn + 1L
            nmstrata <- c(nmstrata, "Within")
        }
        else result <- vector("list", maxasgn + 1L)
        names(result) <- nmstrata
        lmcall$formula <- form <- update(formula, paste(". ~ .-", 
            deparse(errorterm, width.cutoff = 500L, backtick = TRUE)))
        Terms <- terms(form)
        lmcall$method <- "model.frame"
        mf <- eval(lmcall, parent.frame())
        xvars <- as.character(attr(Terms, "variables"))[-1L]
        if ((yvar <- attr(Terms, "response")) > 0L) 
            xvars <- xvars[-yvar]
        if (length(xvars)) {
            xlev <- lapply(mf[xvars], levels)
            xlev <- xlev[!sapply(xlev, is.null)]
        }
        else xlev <- NULL
        resp <- model.response(mf)
        qtx <- model.matrix(Terms, mf, contrasts)
        cons <- attr(qtx, "contrasts")
        dnx <- colnames(qtx)
        asgn.t <- attr(qtx, "assign")
        if (length(wts <- model.weights(mf))) {
            wts <- sqrt(wts)
            resp <- resp * wts
            qtx <- qtx * wts
        }
        qty <- as.matrix(qr.qty(qr.e, resp))
        if ((nc <- ncol(qty)) > 1) {
            dny <- colnames(resp)
            if (is.null(dny)) 
                dny <- paste("Y", 1L:nc, sep = "")
            dimnames(qty) <- list(seq(nrow(qty)), dny)
        }
        else dimnames(qty) <- list(seq(nrow(qty)), NULL)
        qtx <- qr.qty(qr.e, qtx)
        dimnames(qtx) <- list(seq(nrow(qtx)), dnx)
        for (i in seq_along(nmstrata)) {
            select <- asgn.e == (i - 1)
            ni <- sum(select)
            if (!ni) 
                next
            xi <- qtx[select, , drop = FALSE]
            cols <- colSums(xi^2) > 1e-05
            if (any(cols)) {
                xi <- xi[, cols, drop = FALSE]
                attr(xi, "assign") <- asgn.t[cols]
                fiti <- lm.fit(xi, qty[select, , drop = FALSE])
                fiti$terms <- Terms
            }
            else {
                y <- qty[select, , drop = FALSE]
                fiti <- list(coefficients = numeric(), residuals = y, 
                  fitted.values = 0 * y, weights = wts, rank = 0L, 
                  df.residual = NROW(y))
            }
            if (projections) 
                fiti$projections <- proj(fiti)
            class(fiti) <- c(if (maov) "maov", "aov", oldClass(er.fit))
            result[[i]] <- fiti
        }
        result <- result[!sapply(result, is.null)]
        class(result) <- c("aovlist", "listof")
        if (qr) 
            attr(result, "error.qr") <- qr.e
        attr(result, "call") <- Call
        if (length(wts)) 
            attr(result, "weights") <- wts
        attr(result, "terms") <- allTerms
        attr(result, "contrasts") <- cons
        attr(result, "xlevels") <- xlev
        result
    }
}
<environment: namespace:stats>
> print("approxfun"); if(is.function(try(approxfun))) {approxfun;} else{ NULL};
[1] "approxfun"
function (x, y = NULL, method = "linear", yleft, yright, rule = 1, 
    f = 0, ties = mean) 
{
    method <- pmatch(method, c("linear", "constant"))
    if (is.na(method)) 
        stop("invalid interpolation method")
    stopifnot(is.numeric(rule), (lenR <- length(rule)) >= 1L, 
        lenR <= 2L)
    if (lenR == 1) 
        rule <- rule[c(1, 1)]
    x <- regularize.values(x, y, ties)
    y <- x$y
    x <- x$x
    n <- length(x)
    if (n <= 1) {
        if (method == 1) 
            stop("need at least two non-NA values to interpolate")
        if (n == 0) 
            stop("zero non-NA points")
    }
    if (missing(yleft)) 
        yleft <- if (rule[1L] == 1) 
            NA
        else y[1L]
    if (missing(yright)) 
        yright <- if (rule[2L] == 1) 
            NA
        else y[length(y)]
    force(f)
    stopifnot(length(yleft) == 1L, length(yright) == 1L, length(f) == 
        1L)
    rm(rule, ties, lenR)
    .C("R_approxtest", as.double(x), as.double(y), as.integer(n), 
        as.integer(method), as.double(f), NAOK = TRUE, PACKAGE = "stats")
    function(v) .C("R_approxfun", as.double(x), as.double(y), 
        as.integer(n), xout = as.double(v), as.integer(length(v)), 
        as.integer(method), as.double(yleft), as.double(yright), 
        as.double(f), NAOK = TRUE, PACKAGE = "stats")$xout
}
<environment: namespace:stats>
> print("ar"); if(is.function(try(ar))) {ar;} else{ NULL};
[1] "ar"
function (x, aic = TRUE, order.max = NULL, method = c("yule-walker", 
    "burg", "ols", "mle", "yw"), na.action = na.fail, series = deparse(substitute(x)), 
    ...) 
{
    res <- switch(match.arg(method), `yule-walker` = ar.yw(x, 
        aic = aic, order.max = order.max, na.action = na.action, 
        series = series, ...), burg = ar.burg(x, aic = aic, order.max = order.max, 
        na.action = na.action, series = series, ...), ols = ar.ols(x, 
        aic = aic, order.max = order.max, na.action = na.action, 
        series = series, ...), mle = ar.mle(x, aic = aic, order.max = order.max, 
        na.action = na.action, series = series, ...), yw = ar.yw(x, 
        aic = aic, order.max = order.max, na.action = na.action, 
        series = series, ...))
    res$call <- match.call()
    res
}
<environment: namespace:stats>
> print("ar.ols"); if(is.function(try(ar.ols))) {ar.ols;} else{ NULL};
[1] "ar.ols"
function (x, aic = TRUE, order.max = NULL, na.action = na.fail, 
    demean = TRUE, intercept = demean, series = NULL, ...) 
{
    if (is.null(series)) 
        series <- deparse(substitute(x))
    rescale <- TRUE
    ists <- is.ts(x)
    x <- na.action(as.ts(x))
    if (any(is.na(x))) 
        stop("NAs in 'x'")
    if (ists) 
        xtsp <- tsp(x)
    xfreq <- frequency(x)
    x <- as.matrix(x)
    if (!is.numeric(x)) 
        stop("'x' must be numeric")
    n.used <- nrow(x)
    nser <- ncol(x)
    iser <- seq_len(nser)
    if (rescale) {
        sc <- sqrt(drop(apply(x, 2L, var)))
        x <- x/rep.int(sc, rep.int(n.used, nser))
    }
    else sc <- rep.int(1, nser)
    order.max <- if (is.null(order.max)) 
        min(n.used - 1L, floor(10 * log10(n.used)))
    else round(order.max)
    if (order.max < 0L) 
        stop("'order.max' must be >= 0")
    if (order.max >= n.used) 
        stop("'order.max' must be < 'n.used'")
    order.min <- if (aic) 
        0L
    else order.max
    varE <- seA <- A <- vector("list", order.max - order.min + 
        1L)
    xaic <- rep.int(Inf, order.max - order.min + 1L)
    det <- function(x) max(0, prod(diag(qr(x)$qr)) * (-1)^(ncol(x) - 
        1))
    if (demean) {
        xm <- colMeans(x)
        x <- sweep(x, 2L, xm, check.margin = FALSE)
    }
    else xm <- rep.int(0, nser)
    for (m in order.min:order.max) {
        y <- embed(x, m + 1L)
        if (intercept) {
            if (m) 
                X <- cbind(rep.int(1, nrow(y)), y[, (nser + 1L):ncol(y)])
            else X <- as.matrix(rep.int(1, nrow(y)))
        }
        else {
            if (m) 
                X <- y[, (nser + 1L):ncol(y)]
            else X <- matrix(0, nrow(y), 0)
        }
        Y <- t(y[, iser])
        N <- ncol(Y)
        XX <- t(X) %*% X
        rank <- qr(XX)$rank
        if (rank != nrow(XX)) {
            warning(paste("model order: ", m, "singularities in the computation of the projection matrix", 
                "results are only valid up to model order", m - 
                  1L), domain = NA)
            break
        }
        P <- if (ncol(XX) > 0) 
            solve(XX)
        else XX
        A[[m - order.min + 1L]] <- Y %*% X %*% P
        YH <- A[[m - order.min + 1L]] %*% t(X)
        E <- (Y - YH)
        varE[[m - order.min + 1L]] <- tcrossprod(E)/N
        varA <- P %x% (varE[[m - order.min + 1L]])
        seA[[m - order.min + 1L]] <- if (ncol(varA) > 0) 
            sqrt(diag(varA))
        else numeric()
        xaic[m - order.min + 1L] <- n.used * log(det(varE[[m - 
            order.min + 1L]])) + 2 * nser * (nser * m + intercept)
    }
    m <- if (aic) 
        which(xaic == min(xaic))[1L] + order.min - 1L
    else order.max
    y <- embed(x, m + 1L)
    AA <- A[[m - order.min + 1L]]
    if (intercept) {
        xint <- AA[, 1L]
        ar <- AA[, -1L]
        X <- if (m) 
            cbind(rep.int(1, nrow(y)), y[, (nser + 1L):ncol(y)])
        else as.matrix(rep.int(1, nrow(y)))
    }
    else {
        X <- if (m) 
            y[, (nser + 1L):ncol(y)]
        else matrix(0, nrow(y), 0L)
        xint <- NULL
        ar <- AA
    }
    Y <- t(y[, iser, drop = FALSE])
    YH <- AA %*% t(X)
    E <- drop(rbind(matrix(NA, m, nser), t(Y - YH)))
    maic <- min(aic)
    xaic <- if (is.finite(maic)) 
        xaic - min(xaic)
    else ifelse(xaic == maic, 0, Inf)
    names(xaic) <- order.min:order.max
    dim(ar) <- c(nser, nser, m)
    ar <- aperm(ar, c(3L, 1L, 2L))
    ses <- seA[[m - order.min + 1L]]
    if (intercept) {
        sem <- ses[iser]
        ses <- ses[-iser]
    }
    else sem <- rep.int(0, nser)
    dim(ses) <- c(nser, nser, m)
    ses <- aperm(ses, c(3, 1, 2))
    var.pred <- varE[[m - order.min + 1L]]
    if (nser > 1L) {
        snames <- colnames(x)
        dimnames(ses) <- dimnames(ar) <- list(seq_len(m), snames, 
            snames)
        dimnames(var.pred) <- list(snames, snames)
        names(sem) <- colnames(E) <- snames
    }
    if (ists) {
        attr(E, "tsp") <- xtsp
        attr(E, "class") <- "ts"
    }
    if (rescale) {
        xm <- xm * sc
        if (!is.null(xint)) 
            xint <- xint * sc
        aa <- outer(sc, 1/sc)
        if (nser > 1L && m) 
            for (i in seq_len(m)) ar[i, , ] <- ar[i, , ] * aa
        var.pred <- var.pred * drop(outer(sc, sc))
        E <- E * rep.int(sc, rep.int(NROW(E), nser))
        sem <- sem * sc
        if (m) 
            for (i in seq_len(m)) ses[i, , ] <- ses[i, , ] * 
                aa
    }
    res <- list(order = m, ar = ar, var.pred = var.pred, x.mean = xm, 
        x.intercept = xint, aic = xaic, n.used = n.used, order.max = order.max, 
        partialacf = NULL, resid = E, method = "Unconstrained LS", 
        series = series, frequency = xfreq, call = match.call(), 
        asy.se.coef = list(x.mean = sem, ar = drop(ses)))
    class(res) <- "ar"
    res
}
<environment: namespace:stats>
> print("arima"); if(is.function(try(arima))) {arima;} else{ NULL};
[1] "arima"
function (x, order = c(0, 0, 0), seasonal = list(order = c(0, 
    0, 0), period = NA), xreg = NULL, include.mean = TRUE, transform.pars = TRUE, 
    fixed = NULL, init = NULL, method = c("CSS-ML", "ML", "CSS"), 
    n.cond, optim.method = "BFGS", optim.control = list(), kappa = 1e+06) 
{
    "%+%" <- function(a, b) .Call(R_TSconv, a, b)
    upARIMA <- function(mod, phi, theta) {
        p <- length(phi)
        q <- length(theta)
        mod$phi <- phi
        mod$theta <- theta
        r <- max(p, q + 1L)
        if (p > 0) 
            mod$T[1L:p, 1L] <- phi
        if (r > 1L) 
            mod$Pn[1L:r, 1L:r] <- .Call(R_getQ0, phi, theta)
        else if (p > 0) 
            mod$Pn[1L, 1L] <- 1/(1 - phi^2)
        else mod$Pn[1, 1] <- 1
        mod$a[] <- 0
        mod
    }
    arimaSS <- function(y, mod) {
        .Call(R_ARIMA_Like, y, mod$phi, mod$theta, mod$Delta, 
            mod$a, mod$P, mod$Pn, 0L, TRUE)
    }
    armafn <- function(p, trans) {
        par <- coef
        par[mask] <- p
        trarma <- .Call(R_ARIMA_transPars, par, arma, trans)
        Z <- upARIMA(mod, trarma[[1L]], trarma[[2L]])
        if (ncxreg > 0) 
            x <- x - xreg %*% par[narma + (1L:ncxreg)]
        res <- .Call(R_ARIMA_Like, x, Z$phi, Z$theta, Z$Delta, 
            Z$a, Z$P, Z$Pn, 0L, FALSE)
        s2 <- res[1L]/res[3L]
        0.5 * (log(s2) + res[2L]/res[3L])
    }
    armaCSS <- function(p) {
        par <- as.double(fixed)
        par[mask] <- p
        trarma <- .Call(R_ARIMA_transPars, par, arma, FALSE)
        if (ncxreg > 0) 
            x <- x - xreg %*% par[narma + (1L:ncxreg)]
        res <- .Call(R_ARIMA_CSS, x, arma, trarma[[1L]], trarma[[2L]], 
            as.integer(ncond), FALSE)
        0.5 * log(res)
    }
    arCheck <- function(ar) {
        p <- max(which(c(1, -ar) != 0)) - 1
        if (!p) 
            return(TRUE)
        all(Mod(polyroot(c(1, -ar[1L:p]))) > 1)
    }
    maInvert <- function(ma) {
        q <- length(ma)
        q0 <- max(which(c(1, ma) != 0)) - 1L
        if (!q0) 
            return(ma)
        roots <- polyroot(c(1, ma[1L:q0]))
        ind <- Mod(roots) < 1
        if (all(!ind)) 
            return(ma)
        if (q0 == 1) 
            return(c(1/ma[1L], rep(0, q - q0)))
        roots[ind] <- 1/roots[ind]
        x <- 1
        for (r in roots) x <- c(x, 0) - c(0, x)/r
        c(Re(x[-1L]), rep(0, q - q0))
    }
    series <- deparse(substitute(x))
    if (NCOL(x) > 1L) 
        stop("only implemented for univariate time series")
    method <- match.arg(method)
    x <- as.ts(x)
    if (!is.numeric(x)) 
        stop("'x' must be numeric")
    storage.mode(x) <- "double"
    dim(x) <- NULL
    n <- length(x)
    if (!missing(order)) 
        if (!is.numeric(order) || length(order) != 3L || any(order < 
            0)) 
            stop("'order' must be a non-negative numeric vector of length 3")
    if (!missing(seasonal)) 
        if (is.list(seasonal)) {
            if (is.null(seasonal$order)) 
                stop("'seasonal' must be a list with component 'order'")
            if (!is.numeric(seasonal$order) || length(seasonal$order) != 
                3L || any(seasonal$order < 0L)) 
                stop("'seasonal$order' must be a non-negative numeric vector of length 3")
        }
        else if (is.numeric(order)) {
            if (length(order) == 3L) 
                seasonal <- list(order = seasonal)
            else ("'seasonal' is of the wrong length")
        }
        else stop("'seasonal' must be a list with component 'order'")
    if (is.null(seasonal$period) || is.na(seasonal$period) || 
        seasonal$period == 0) 
        seasonal$period <- frequency(x)
    arma <- as.integer(c(order[-2L], seasonal$order[-2L], seasonal$period, 
        order[2L], seasonal$order[2L]))
    narma <- sum(arma[1L:4L])
    xtsp <- tsp(x)
    tsp(x) <- NULL
    Delta <- 1
    for (i in seq_len(order[2L])) Delta <- Delta %+% c(1, -1)
    for (i in seq_len(seasonal$order[2L])) Delta <- Delta %+% 
        c(1, rep(0, seasonal$period - 1), -1)
    Delta <- -Delta[-1L]
    nd <- order[2L] + seasonal$order[2L]
    n.used <- sum(!is.na(x)) - length(Delta)
    if (is.null(xreg)) {
        ncxreg <- 0L
    }
    else {
        nmxreg <- deparse(substitute(xreg))
        if (NROW(xreg) != n) 
            stop("lengths of 'x' and 'xreg' do not match")
        ncxreg <- NCOL(xreg)
        xreg <- as.matrix(xreg)
        storage.mode(xreg) <- "double"
    }
    class(xreg) <- NULL
    if (ncxreg > 0L && is.null(colnames(xreg))) 
        colnames(xreg) <- if (ncxreg == 1L) 
            nmxreg
        else paste(nmxreg, 1L:ncxreg, sep = "")
    if (include.mean && (nd == 0L)) {
        xreg <- cbind(intercept = rep(1, n), xreg = xreg)
        ncxreg <- ncxreg + 1L
    }
    if (method == "CSS-ML") {
        anyna <- any(is.na(x))
        if (ncxreg) 
            anyna <- anyna || any(is.na(xreg))
        if (anyna) 
            method <- "ML"
    }
    if (method == "CSS" || method == "CSS-ML") {
        ncond <- order[2L] + seasonal$order[2L] * seasonal$period
        ncond1 <- order[1L] + seasonal$period * seasonal$order[1L]
        ncond <- if (!missing(n.cond)) 
            ncond + max(n.cond, ncond1)
        else ncond + ncond1
    }
    else ncond <- 0
    if (is.null(fixed)) 
        fixed <- rep(NA_real_, narma + ncxreg)
    else if (length(fixed) != narma + ncxreg) 
        stop("wrong length for 'fixed'")
    mask <- is.na(fixed)
    no.optim <- !any(mask)
    if (no.optim) 
        transform.pars <- FALSE
    if (transform.pars) {
        ind <- arma[1L] + arma[2L] + seq_len(arma[3L])
        if (any(!mask[seq_len(arma[1L])]) || any(!mask[ind])) {
            warning("some AR parameters were fixed: setting transform.pars = FALSE")
            transform.pars <- FALSE
        }
    }
    init0 <- rep(0, narma)
    parscale <- rep(1, narma)
    if (ncxreg) {
        cn <- colnames(xreg)
        orig.xreg <- (ncxreg == 1L) || any(!mask[narma + 1L:ncxreg])
        if (!orig.xreg) {
            S <- svd(na.omit(xreg))
            xreg <- xreg %*% S$v
        }
        fit <- lm(x ~ xreg - 1, na.action = na.omit)
        n.used <- sum(!is.na(resid(fit))) - length(Delta)
        init0 <- c(init0, coef(fit))
        ses <- summary(fit)$coefficients[, 2L]
        parscale <- c(parscale, 10 * ses)
    }
    if (n.used <= 0) 
        stop("too few non-missing observations")
    if (!is.null(init)) {
        if (length(init) != length(init0)) 
            stop("'init' is of the wrong length")
        if (any(ind <- is.na(init))) 
            init[ind] <- init0[ind]
        if (method == "ML") {
            if (arma[1L] > 0) 
                if (!arCheck(init[1L:arma[1L]])) 
                  stop("non-stationary AR part")
            if (arma[3L] > 0) 
                if (!arCheck(init[sum(arma[1L:2L]) + 1L:arma[3L]])) 
                  stop("non-stationary seasonal AR part")
            if (transform.pars) 
                init <- .Call(R_ARIMA_Invtrans, as.double(init), 
                  arma)
        }
    }
    else init <- init0
    coef <- as.double(fixed)
    if (!("parscale" %in% names(optim.control))) 
        optim.control$parscale <- parscale[mask]
    if (method == "CSS") {
        res <- if (no.optim) 
            list(convergence = 0L, par = numeric(), value = armaCSS(numeric()))
        else optim(init[mask], armaCSS, method = optim.method, 
            hessian = TRUE, control = optim.control)
        if (res$convergence > 0) 
            warning("possible convergence problem: optim gave code=", 
                res$convergence)
        coef[mask] <- res$par
        trarma <- .Call(R_ARIMA_transPars, coef, arma, FALSE)
        mod <- makeARIMA(trarma[[1L]], trarma[[2L]], Delta, kappa)
        if (ncxreg > 0) 
            x <- x - xreg %*% coef[narma + (1L:ncxreg)]
        arimaSS(x, mod)
        val <- .Call(R_ARIMA_CSS, x, arma, trarma[[1L]], trarma[[2L]], 
            as.integer(ncond), TRUE)
        sigma2 <- val[[1L]]
        var <- if (no.optim) 
            numeric()
        else solve(res$hessian * n.used)
    }
    else {
        if (method == "CSS-ML") {
            res <- if (no.optim) 
                list(convergence = 0L, par = numeric(), value = armaCSS(numeric()))
            else optim(init[mask], armaCSS, method = optim.method, 
                hessian = FALSE, control = optim.control)
            if (res$convergence == 0) 
                init[mask] <- res$par
            if (arma[1L] > 0) 
                if (!arCheck(init[1L:arma[1L]])) 
                  stop("non-stationary AR part from CSS")
            if (arma[3L] > 0) 
                if (!arCheck(init[sum(arma[1L:2L]) + 1L:arma[3L]])) 
                  stop("non-stationary seasonal AR part from CSS")
            ncond <- 0L
        }
        if (transform.pars) {
            init <- .Call(R_ARIMA_Invtrans, init, arma)
            if (arma[2L] > 0) {
                ind <- arma[1L] + 1L:arma[2L]
                init[ind] <- maInvert(init[ind])
            }
            if (arma[4L] > 0) {
                ind <- sum(arma[1L:3L]) + 1L:arma[4L]
                init[ind] <- maInvert(init[ind])
            }
        }
        trarma <- .Call(R_ARIMA_transPars, init, arma, transform.pars)
        mod <- makeARIMA(trarma[[1L]], trarma[[2L]], Delta, kappa)
        res <- if (no.optim) 
            list(convergence = 0, par = numeric(), value = armafn(numeric(), 
                as.logical(transform.pars)))
        else optim(init[mask], armafn, method = optim.method, 
            hessian = TRUE, control = optim.control, trans = as.logical(transform.pars))
        if (res$convergence > 0) 
            warning("possible convergence problem: optim gave code=", 
                res$convergence)
        coef[mask] <- res$par
        if (transform.pars) {
            if (arma[2L] > 0L) {
                ind <- arma[1L] + 1L:arma[2L]
                if (all(mask[ind])) 
                  coef[ind] <- maInvert(coef[ind])
            }
            if (arma[4L] > 0L) {
                ind <- sum(arma[1L:3L]) + 1L:arma[4L]
                if (all(mask[ind])) 
                  coef[ind] <- maInvert(coef[ind])
            }
            if (any(coef[mask] != res$par)) {
                oldcode <- res$convergence
                res <- optim(coef[mask], armafn, method = optim.method, 
                  hessian = TRUE, control = list(maxit = 0, parscale = optim.control$parscale), 
                  trans = TRUE)
                res$convergence <- oldcode
                coef[mask] <- res$par
            }
            A <- .Call(R_ARIMA_Gradtrans, as.double(coef), arma)
            A <- A[mask, mask]
            var <- t(A) %*% solve(res$hessian * n.used) %*% A
            coef <- .Call(R_ARIMA_undoPars, coef, arma)
        }
        else var <- if (no.optim) 
            numeric()
        else solve(res$hessian * n.used)
        trarma <- .Call(R_ARIMA_transPars, coef, arma, FALSE)
        mod <- makeARIMA(trarma[[1L]], trarma[[2L]], Delta, kappa)
        val <- if (ncxreg > 0L) 
            arimaSS(x - xreg %*% coef[narma + (1L:ncxreg)], mod)
        else arimaSS(x, mod)
        sigma2 <- val[[1L]][1L]/n.used
    }
    value <- 2 * n.used * res$value + n.used + n.used * log(2 * 
        pi)
    aic <- if (method != "CSS") 
        value + 2 * sum(mask) + 2
    else NA
    nm <- NULL
    if (arma[1L] > 0L) 
        nm <- c(nm, paste("ar", 1L:arma[1L], sep = ""))
    if (arma[2L] > 0L) 
        nm <- c(nm, paste("ma", 1L:arma[2L], sep = ""))
    if (arma[3L] > 0L) 
        nm <- c(nm, paste("sar", 1L:arma[3L], sep = ""))
    if (arma[4L] > 0L) 
        nm <- c(nm, paste("sma", 1L:arma[4L], sep = ""))
    if (ncxreg > 0L) {
        nm <- c(nm, cn)
        if (!orig.xreg) {
            ind <- narma + 1L:ncxreg
            coef[ind] <- S$v %*% coef[ind]
            A <- diag(narma + ncxreg)
            A[ind, ind] <- S$v
            A <- A[mask, mask]
            var <- A %*% var %*% t(A)
        }
    }
    names(coef) <- nm
    if (!no.optim) 
        dimnames(var) <- list(nm[mask], nm[mask])
    resid <- val[[2L]]
    tsp(resid) <- xtsp
    class(resid) <- "ts"
    res <- list(coef = coef, sigma2 = sigma2, var.coef = var, 
        mask = mask, loglik = -0.5 * value, aic = aic, arma = arma, 
        residuals = resid, call = match.call(), series = series, 
        code = res$convergence, n.cond = ncond, model = mod)
    class(res) <- "Arima"
    res
}
<environment: namespace:stats>
> print("arima.sim"); if(is.function(try(arima.sim))) {arima.sim;} else{ NULL};
[1] "arima.sim"
function (model, n, rand.gen = rnorm, innov = rand.gen(n, ...), 
    n.start = NA, start.innov = rand.gen(n.start, ...), ...) 
{
    if (!is.list(model)) 
        stop("'model' must be list")
    p <- length(model$ar)
    if (p) {
        minroots <- min(Mod(polyroot(c(1, -model$ar))))
        if (minroots <= 1) 
            stop("'ar' part of model is not stationary")
    }
    q <- length(model$ma)
    if (is.na(n.start)) 
        n.start <- p + q + ifelse(p > 0, ceiling(6/log(minroots)), 
            0)
    if (n.start < p + q) 
        stop("burn-in 'n.start' must be as long as 'ar + ma'")
    d <- 0
    if (!is.null(ord <- model$order)) {
        if (length(ord) != 3L) 
            stop("'model$order' must be of length 3")
        if (p != ord[1L]) 
            stop("inconsistent specification of 'ar' order")
        if (q != ord[3L]) 
            stop("inconsistent specification of 'ma' order")
        d <- ord[2L]
        if (d != round(d) || d < 0) 
            stop("number of differences must be a positive integer")
    }
    if (!missing(start.innov) && length(start.innov) < n.start) 
        stop(gettextf("'start.innov' is too short: need %d points", 
            n.start), domain = NA)
    x <- ts(c(start.innov[1L:n.start], innov[1L:n]), start = 1 - 
        n.start)
    if (length(model$ma)) 
        x <- filter(x, c(1, model$ma), sides = 1)
    if (length(model$ar)) 
        x <- filter(x, model$ar, method = "recursive")
    if (n.start > 0) 
        x <- x[-(1L:n.start)]
    if (d > 0) 
        x <- diffinv(x, differences = d)
    as.ts(x)
}
<environment: namespace:stats>
> print("arima0"); if(is.function(try(arima0))) {arima0;} else{ NULL};
[1] "arima0"
function (x, order = c(0, 0, 0), seasonal = list(order = c(0, 
    0, 0), period = NA), xreg = NULL, include.mean = TRUE, delta = 0.01, 
    transform.pars = TRUE, fixed = NULL, init = NULL, method = c("ML", 
        "CSS"), n.cond, optim.control = list()) 
{
    arma0f <- function(p) {
        par <- as.double(fixed)
        par[mask] <- p
        .Call(R_arma0fa, G, par)
    }
    arCheck <- function(ar) {
        p <- max(which(c(1, -ar) != 0)) - 1
        if (!p) 
            return(TRUE)
        all(Mod(polyroot(c(1, -ar[1L:p]))) > 1)
    }
    maInvert <- function(ma) {
        q <- length(ma)
        q0 <- max(which(c(1, ma) != 0)) - 1
        if (!q0) 
            return(ma)
        roots <- polyroot(c(1, ma[1L:q0]))
        ind <- Mod(roots) < 1
        if (all(!ind)) 
            return(ma)
        warning("converting non-invertible initial MA values")
        if (q0 == 1) 
            return(c(1/ma[1L], rep(0, q - q0)))
        roots[ind] <- 1/roots[ind]
        x <- 1
        for (r in roots) x <- c(x, 0) - c(0, x)/r
        c(Re(x[-1L]), rep(0, q - q0))
    }
    series <- deparse(substitute(x))
    if (NCOL(x) > 1) 
        stop("only implemented for univariate time series")
    method <- match.arg(method)
    x <- as.ts(x)
    if (!is.numeric(x)) 
        stop("'x' must be numeric")
    dim(x) <- NULL
    n <- length(x)
    if (!missing(order)) 
        if (!is.numeric(order) || length(order) != 3L || any(order < 
            0)) 
            stop("'order' must be a non-negative numeric vector of length 3")
    if (!missing(seasonal)) 
        if (is.list(seasonal)) {
            if (is.null(seasonal$order)) 
                stop("'seasonal' must be a list with component 'order'")
            if (!is.numeric(seasonal$order) || length(seasonal$order) != 
                3L || any(seasonal$order < 0)) 
                stop("'seasonal$order' must be a non-negative numeric vector of length 3")
        }
        else if (is.numeric(order)) {
            if (length(order) == 3) 
                seasonal <- list(order = seasonal)
            else ("'seasonal' is of the wrong length")
        }
        else stop("'seasonal' must be a list with component 'order'")
    if (is.null(seasonal$period) || is.na(seasonal$period) || 
        seasonal$period == 0) 
        seasonal$period <- frequency(x)
    arma <- c(order[-2L], seasonal$order[-2L], seasonal$period, 
        order[2L], seasonal$order[2L])
    narma <- sum(arma[1L:4L])
    if (d <- order[2L]) 
        x <- diff(x, 1, d)
    if (d <- seasonal$order[2L]) 
        x <- diff(x, seasonal$period, d)
    xtsp <- tsp(x)
    tsp(x) <- NULL
    nd <- order[2L] + seasonal$order[2L]
    n.used <- length(x)
    ncond <- n - n.used
    if (method == "CSS") {
        ncond1 <- order[1L] + seasonal$period * seasonal$order[1L]
        ncond <- if (!missing(n.cond)) 
            ncond + max(n.cond, ncond1)
        else ncond + ncond1
    }
    if (is.null(xreg)) {
        ncxreg <- 0
    }
    else {
        if (NROW(xreg) != n) 
            stop("lengths of 'x' and 'xreg' do not match")
        ncxreg <- NCOL(xreg)
    }
    class(xreg) <- NULL
    if (include.mean && (nd == 0)) {
        if (is.matrix(xreg) && is.null(colnames(xreg))) 
            colnames(xreg) <- paste("xreg", 1L:ncxreg, sep = "")
        xreg <- cbind(intercept = rep(1, n), xreg = xreg)
        ncxreg <- ncxreg + 1
    }
    if (is.null(fixed)) 
        fixed <- rep(NA_real_, narma + ncxreg)
    else if (length(fixed) != narma + ncxreg) 
        stop("wrong length for 'fixed'")
    mask <- is.na(fixed)
    if (!any(mask)) 
        stop("all parameters were fixed")
    if (transform.pars && any(!mask[1L:narma])) {
        warning("some ARMA parameters were fixed: setting transform.pars = FALSE")
        transform.pars <- FALSE
    }
    if (ncxreg) {
        if (d <- order[2L]) 
            xreg <- diff(xreg, 1, d)
        if (d <- seasonal$order[2L]) 
            xreg <- diff(xreg, seasonal$period, d)
        xreg <- as.matrix(xreg)
        if (qr(na.omit(xreg))$rank < ncol(xreg)) 
            stop("'xreg' is collinear")
        if (is.null(cn <- colnames(xreg))) 
            cn <- paste("xreg", 1L:ncxreg, sep = "")
    }
    if (any(is.na(x)) || (ncxreg && any(is.na(xreg)))) 
        if (method == "ML" && delta >= 0) {
            warning("NAs present: setting 'delta' to -1")
            delta <- -1
        }
    init0 <- rep(0, narma)
    parscale <- rep(1, narma)
    if (ncxreg) {
        orig.xreg <- (ncxreg == 1) || any(!mask[narma + 1L:ncxreg])
        if (!orig.xreg) {
            S <- svd(na.omit(xreg))
            xreg <- xreg %*% S$v
        }
        fit <- lm(x ~ xreg - 1, na.action = na.omit)
        init0 <- c(init0, coef(fit))
        ses <- summary(fit)$coefficients[, 2]
        parscale <- c(parscale, ses)
    }
    storage.mode(x) <- storage.mode(xreg) <- "double"
    if (method == "CSS") 
        transform.pars <- 0
    G <- .Call(R_setup_starma, as.integer(arma), x, n.used, xreg, 
        ncxreg, delta, transform.pars > 0, ncond - (n - n.used))
    on.exit(.Call(R_free_starma, G))
    if (!is.null(init)) {
        if (length(init) != length(init0)) 
            stop("'init' is of the wrong length")
        if (any(ind <- is.na(init))) 
            init[ind] <- init0[ind]
        if (transform.pars) {
            if (any(!mask[1L:narma])) 
                warning("transformed ARMA parameters were fixed")
            if (arma[1L] > 0) 
                if (!arCheck(init[1L:arma[1L]])) 
                  stop("non-stationary AR part")
            if (arma[3L] > 0) 
                if (!arCheck(init[sum(arma[1L:2]) + 1L:arma[3L]])) 
                  stop("non-stationary seasonal AR part")
            if (arma[2L] > 0) {
                ind <- arma[1L] + 1L:arma[2L]
                init[ind] <- maInvert(init[ind])
            }
            if (arma[4L] > 0) {
                ind <- sum(arma[1L:3]) + 1L:arma[4L]
                init[ind] <- maInvert(init[ind])
            }
            init <- .Call(R_Invtrans, G, as.double(init))
        }
    }
    else init <- init0
    .Call(R_Starma_method, G, method == "CSS")
    if (!("parscale" %in% names(optim.control))) 
        optim.control$parscale <- parscale[mask]
    res <- optim(init[mask], arma0f, method = "BFGS", hessian = TRUE, 
        control = optim.control)
    if ((code <- res$convergence) > 0) 
        warning("possible convergence problem: optim gave code=", 
            code)
    coef <- res$par
    if (transform.pars) {
        cf <- fixed
        cf[mask] <- coef
        A <- .Call(R_Gradtrans, G, as.double(cf))[mask, mask]
        var <- t(A) %*% solve(res$hessian * length(x)) %*% A
        coef <- .Call(R_Dotrans, G, as.double(cf))[mask]
        .Call(R_set_trans, G, 0)
    }
    else var <- solve(res$hessian * length(x))
    arma0f(coef)
    sigma2 <- .Call(R_get_s2, G)
    resid <- .Call(R_get_resid, G)
    tsp(resid) <- xtsp
    class(resid) <- "ts"
    n.used <- sum(!is.na(resid))
    nm <- NULL
    if (arma[1L] > 0) 
        nm <- c(nm, paste("ar", 1L:arma[1L], sep = ""))
    if (arma[2L] > 0) 
        nm <- c(nm, paste("ma", 1L:arma[2L], sep = ""))
    if (arma[3L] > 0) 
        nm <- c(nm, paste("sar", 1L:arma[3L], sep = ""))
    if (arma[4L] > 0) 
        nm <- c(nm, paste("sma", 1L:arma[4L], sep = ""))
    fixed[mask] <- coef
    if (ncxreg > 0) {
        nm <- c(nm, cn)
        if (!orig.xreg) {
            ind <- narma + 1L:ncxreg
            fixed[ind] <- S$v %*% fixed[ind]
            A <- diag(narma + ncxreg)
            A[ind, ind] <- S$v
            A <- A[mask, mask]
            var <- A %*% var %*% t(A)
        }
    }
    names(fixed) <- nm
    names(arma) <- c("ar", "ma", "sar", "sma", "period", "diff", 
        "sdiff")
    dimnames(var) <- list(nm[mask], nm[mask])
    value <- 2 * n.used * res$value + n.used + n.used * log(2 * 
        pi)
    aic <- if (method != "CSS") 
        value + 2 * length(coef) + 2
    else NA
    res <- list(coef = fixed, sigma2 = sigma2, var.coef = var, 
        mask = mask, loglik = -0.5 * value, aic = aic, arma = arma, 
        residuals = resid, call = match.call(), series = series, 
        code = code, n.cond = ncond)
    class(res) <- "arima0"
    res
}
<environment: namespace:stats>
> print("as.hclust"); if(is.function(try(as.hclust))) {as.hclust;} else{ NULL};
[1] "as.hclust"
function (x, ...) 
UseMethod("as.hclust")
<environment: namespace:stats>
> print("asOneSidedFormula"); if(is.function(try(asOneSidedFormula))) {asOneSidedFormula;} else{ NULL};
[1] "asOneSidedFormula"
function (object) 
{
    if ((mode(object) == "call") && (object[[1L]] == "~")) {
        object <- eval(object)
    }
    if (inherits(object, "formula")) {
        if (length(object) != 2L) {
            stop(gettextf("formula '%s' must be of the form '~expr'", 
                deparse(as.vector(object))), domain = NA)
        }
        return(object)
    }
    do.call("~", list(switch(mode(object), name = , numeric = , 
        call = object, character = as.name(object), expression = object[[1L]], 
        stop(gettextf("'%s' cannot be of mode '%s'", substitute(object), 
            mode(object)), domain = NA))))
}
<environment: namespace:stats>
> print("ave"); if(is.function(try(ave))) {ave;} else{ NULL};
[1] "ave"
function (x, ..., FUN = mean) 
{
    n <- length(list(...))
    if (n) {
        g <- interaction(...)
        split(x, g) <- lapply(split(x, g), FUN)
    }
    else x[] <- FUN(x)
    x
}
<environment: namespace:stats>
> print("bartlett.test"); if(is.function(try(bartlett.test))) {bartlett.test;} else{ NULL};
[1] "bartlett.test"
function (x, ...) 
UseMethod("bartlett.test")
<environment: namespace:stats>
> print("binom.test"); if(is.function(try(binom.test))) {binom.test;} else{ NULL};
[1] "binom.test"
function (x, n, p = 0.5, alternative = c("two.sided", "less", 
    "greater"), conf.level = 0.95) 
{
    DNAME <- deparse(substitute(x))
    xr <- round(x)
    if (any(is.na(x) | (x < 0)) || max(abs(x - xr)) > 1e-07) 
        stop("'x' must be nonnegative and integer")
    x <- xr
    if (length(x) == 2L) {
        n <- sum(x)
        x <- x[1L]
    }
    else if (length(x) == 1L) {
        nr <- round(n)
        if ((length(n) > 1L) || is.na(n) || (n < 1) || abs(n - 
            nr) > 1e-07 || (x > nr)) 
            stop("'n' must be a positive integer >= 'x'")
        DNAME <- paste(DNAME, "and", deparse(substitute(n)))
        n <- nr
    }
    else stop("incorrect length of 'x'")
    if (!missing(p) && (length(p) > 1L || is.na(p) || p < 0 || 
        p > 1)) 
        stop("'p' must be a single number between 0 and 1")
    alternative <- match.arg(alternative)
    if (!((length(conf.level) == 1L) && is.finite(conf.level) && 
        (conf.level > 0) && (conf.level < 1))) 
        stop("'conf.level' must be a single number between 0 and 1")
    PVAL <- switch(alternative, less = pbinom(x, n, p), greater = pbinom(x - 
        1, n, p, lower.tail = FALSE), two.sided = {
        if (p == 0) (x == 0) else if (p == 1) (x == n) else {
            relErr <- 1 + 1e-07
            d <- dbinom(x, n, p)
            m <- n * p
            if (x == m) 1 else if (x < m) {
                i <- seq.int(from = ceiling(m), to = n)
                y <- sum(dbinom(i, n, p) <= d * relErr)
                pbinom(x, n, p) + pbinom(n - y, n, p, lower.tail = FALSE)
            } else {
                i <- seq.int(from = 0, to = floor(m))
                y <- sum(dbinom(i, n, p) <= d * relErr)
                pbinom(y - 1, n, p) + pbinom(x - 1, n, p, lower.tail = FALSE)
            }
        }
    })
    p.L <- function(x, alpha) {
        if (x == 0) 
            0
        else qbeta(alpha, x, n - x + 1)
    }
    p.U <- function(x, alpha) {
        if (x == n) 
            1
        else qbeta(1 - alpha, x + 1, n - x)
    }
    CINT <- switch(alternative, less = c(0, p.U(x, 1 - conf.level)), 
        greater = c(p.L(x, 1 - conf.level), 1), two.sided = {
            alpha <- (1 - conf.level)/2
            c(p.L(x, alpha), p.U(x, alpha))
        })
    attr(CINT, "conf.level") <- conf.level
    ESTIMATE <- x/n
    names(x) <- "number of successes"
    names(n) <- "number of trials"
    names(ESTIMATE) <- names(p) <- "probability of success"
    structure(list(statistic = x, parameter = n, p.value = PVAL, 
        conf.int = CINT, estimate = ESTIMATE, null.value = p, 
        alternative = alternative, method = "Exact binomial test", 
        data.name = DNAME), class = "htest")
}
<environment: namespace:stats>
> print("biplot"); if(is.function(try(biplot))) {biplot;} else{ NULL};
[1] "biplot"
function (x, ...) 
UseMethod("biplot")
<environment: namespace:stats>
> print("biplot.princomp"); if(is.function(try(biplot.princomp))) {biplot.princomp;} else{ NULL};
[1] "biplot.princomp"
NULL
> print("bw.nrd0"); if(is.function(try(bw.nrd0))) {bw.nrd0;} else{ NULL};
[1] "bw.nrd0"
function (x) 
{
    if (length(x) < 2L) 
        stop("need at least 2 data points")
    hi <- sd(x)
    if (!(lo <- min(hi, IQR(x)/1.34))) 
        (lo <- hi) || (lo <- abs(x[1L])) || (lo <- 1)
    0.9 * lo * length(x)^(-0.2)
}
<environment: namespace:stats>
> print("cancor"); if(is.function(try(cancor))) {cancor;} else{ NULL};
[1] "cancor"
function (x, y, xcenter = TRUE, ycenter = TRUE) 
{
    x <- as.matrix(x)
    y <- as.matrix(y)
    if ((nr <- nrow(x)) != nrow(y)) 
        stop("unequal number of rows in 'cancor'")
    ncx <- ncol(x)
    ncy <- ncol(y)
    if (!nr || !ncx || !ncy) 
        stop("dimension 0 in 'x' or 'y'")
    if (is.logical(xcenter)) {
        if (xcenter) {
            xcenter <- colMeans(x, )
            x <- x - rep(xcenter, rep.int(nr, ncx))
        }
        else xcenter <- rep.int(0, ncx)
    }
    else {
        xcenter <- rep(xcenter, length.out = ncx)
        x <- x - rep(xcenter, rep.int(nr, ncx))
    }
    if (is.logical(ycenter)) {
        if (ycenter) {
            ycenter <- colMeans(y)
            y <- y - rep(ycenter, rep.int(nr, ncy))
        }
        else ycenter <- rep.int(0, ncy)
    }
    else {
        ycenter <- rep(ycenter, length.out = ncy)
        y <- y - rep(ycenter, rep.int(nr, ncy))
    }
    qx <- qr(x)
    qy <- qr(y)
    dx <- qx$rank
    if (!dx) 
        stop("'x' has rank 0")
    dy <- qy$rank
    if (!dy) 
        stop("'y' has rank 0")
    z <- svd(qr.qty(qx, qr.qy(qy, diag(1, nr, dy)))[1L:dx, , 
        drop = FALSE], dx, dy)
    xcoef <- backsolve((qx$qr)[1L:dx, 1L:dx, drop = FALSE], z$u)
    rownames(xcoef) <- colnames(x)[qx$pivot][1L:dx]
    ycoef <- backsolve((qy$qr)[1L:dy, 1L:dy, drop = FALSE], z$v)
    rownames(ycoef) <- colnames(y)[qy$pivot][1L:dy]
    list(cor = z$d, xcoef = xcoef, ycoef = ycoef, xcenter = xcenter, 
        ycenter = ycenter)
}
<environment: namespace:stats>
> print("case.names"); if(is.function(try(case.names))) {case.names;} else{ NULL};
[1] "case.names"
function (object, ...) 
UseMethod("case.names")
<environment: namespace:stats>
> print("chisq.test"); if(is.function(try(chisq.test))) {chisq.test;} else{ NULL};
[1] "chisq.test"
function (x, y = NULL, correct = TRUE, p = rep(1/length(x), length(x)), 
    rescale.p = FALSE, simulate.p.value = FALSE, B = 2000) 
{
    DNAME <- deparse(substitute(x))
    if (is.data.frame(x)) 
        x <- as.matrix(x)
    if (is.matrix(x)) {
        if (min(dim(x)) == 1L) 
            x <- as.vector(x)
    }
    if (!is.matrix(x) && !is.null(y)) {
        if (length(x) != length(y)) 
            stop("'x' and 'y' must have the same length")
        DNAME2 <- deparse(substitute(y))
        xname <- if (length(DNAME) > 1L || nchar(DNAME, "w") > 
            30) 
            ""
        else DNAME
        yname <- if (length(DNAME2) > 1L || nchar(DNAME2, "w") > 
            30) 
            ""
        else DNAME2
        OK <- complete.cases(x, y)
        x <- factor(x[OK])
        y <- factor(y[OK])
        if ((nlevels(x) < 2L) || (nlevels(y) < 2L)) 
            stop("'x' and 'y' must have at least 2 levels")
        x <- table(x, y)
        names(dimnames(x)) <- c(xname, yname)
        DNAME <- paste(paste(DNAME, collapse = "\n"), "and", 
            paste(DNAME2, collapse = "\n"))
    }
    if (any(x < 0) || any(is.na(x))) 
        stop("all entries of 'x' must be nonnegative and finite")
    if ((n <- sum(x)) == 0) 
        stop("at least one entry of 'x' must be positive")
    if (simulate.p.value) {
        setMETH <- function() METHOD <<- paste(METHOD, "with simulated p-value\n\t (based on", 
            B, "replicates)")
        almost.1 <- 1 - 64 * .Machine$double.eps
    }
    if (is.matrix(x)) {
        METHOD <- "Pearson's Chi-squared test"
        nr <- nrow(x)
        nc <- ncol(x)
        sr <- rowSums(x)
        sc <- colSums(x)
        E <- outer(sr, sc, "*")/n
        v <- function(r, c, n) c * r * (n - r) * (n - c)/n^3
        V <- outer(sr, sc, v, n)
        dimnames(E) <- dimnames(x)
        if (simulate.p.value && all(sr > 0) && all(sc > 0)) {
            setMETH()
            tmp <- .C(R_chisqsim, as.integer(nr), as.integer(nc), 
                as.integer(sr), as.integer(sc), as.integer(n), 
                as.integer(B), as.double(E), integer(nr * nc), 
                double(n + 1), integer(nc), results = double(B))
            STATISTIC <- sum(sort((x - E)^2/E, decreasing = TRUE))
            PARAMETER <- NA
            PVAL <- (1 + sum(tmp$results >= almost.1 * STATISTIC))/(B + 
                1)
        }
        else {
            if (simulate.p.value) 
                warning("cannot compute simulated p-value with zero marginals")
            if (correct && nrow(x) == 2 && ncol(x) == 2) {
                YATES <- 0.5
                METHOD <- paste(METHOD, "with Yates' continuity correction")
            }
            else YATES <- 0
            STATISTIC <- sum((abs(x - E) - YATES)^2/E)
            PARAMETER <- (nr - 1) * (nc - 1)
            PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
        }
    }
    else {
        if (length(x) == 1L) 
            stop("'x' must at least have 2 elements")
        if (length(x) != length(p)) 
            stop("'x' and 'p' must have the same number of elements")
        if (any(p < 0)) 
            stop("probabilities must be non-negative.")
        if (abs(sum(p) - 1) > sqrt(.Machine$double.eps)) {
            if (rescale.p) 
                p <- p/sum(p)
            else stop("probabilities must sum to 1.")
        }
        METHOD <- "Chi-squared test for given probabilities"
        E <- n * p
        V <- n * p * (1 - p)
        names(E) <- names(x)
        STATISTIC <- sum((x - E)^2/E)
        if (simulate.p.value) {
            setMETH()
            nx <- length(x)
            sm <- matrix(sample.int(nx, B * n, TRUE, prob = p), 
                nrow = n)
            ss <- apply(sm, 2L, function(x, E, k) {
                sum((table(factor(x, levels = 1L:k)) - E)^2/E)
            }, E = E, k = nx)
            PARAMETER <- NA
            PVAL <- (1 + sum(ss >= almost.1 * STATISTIC))/(B + 
                1)
        }
        else {
            PARAMETER <- length(x) - 1
            PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
        }
    }
    names(STATISTIC) <- "X-squared"
    names(PARAMETER) <- "df"
    if (any(E < 5) && is.finite(PARAMETER)) 
        warning("Chi-squared approximation may be incorrect")
    structure(list(statistic = STATISTIC, parameter = PARAMETER, 
        p.value = PVAL, method = METHOD, data.name = DNAME, observed = x, 
        expected = E, residuals = (x - E)/sqrt(E), stdres = (x - 
            E)/sqrt(V)), class = "htest")
}
<environment: namespace:stats>
> print("cmdscale"); if(is.function(try(cmdscale))) {cmdscale;} else{ NULL};
[1] "cmdscale"
function (d, k = 2, eig = FALSE, add = FALSE, x.ret = FALSE) 
{
    if (any(is.na(d))) 
        stop("NA values not allowed in 'd'")
    if (is.null(n <- attr(d, "Size"))) {
        if (add) 
            d <- as.matrix(d)
        x <- as.matrix(d^2)
        if ((n <- nrow(x)) != ncol(x)) 
            stop("distances must be result of 'dist' or a square matrix")
        rn <- rownames(x)
    }
    else {
        rn <- attr(d, "Labels")
        x <- matrix(0, n, n)
        if (add) 
            d0 <- x
        x[row(x) > col(x)] <- d^2
        x <- x + t(x)
        if (add) {
            d0[row(x) > col(x)] <- d
            d <- d0 + t(d0)
        }
    }
    if ((k <- as.integer(k)) > n - 1 || k < 1) 
        stop("'k' must be in {1, 2, ..  n - 1}")
    storage.mode(x) <- "double"
    .C(R_dblcen, x, as.integer(n), DUP = FALSE)
    if (add) {
        i2 <- n + (i <- 1L:n)
        Z <- matrix(0, 2L * n, 2L * n)
        Z[cbind(i2, i)] <- -1
        Z[i, i2] <- -x
        Z[i2, i2] <- .C(R_dblcen, x = 2 * d, as.integer(n))$x
        e <- eigen(Z, symmetric = FALSE, only.values = TRUE)$values
        add.c <- max(Re(e))
        x <- matrix(double(n * n), n, n)
        non.diag <- row(d) != col(d)
        x[non.diag] <- (d[non.diag] + add.c)^2
        .C(R_dblcen, x, as.integer(n), DUP = FALSE)
    }
    e <- eigen(-x/2, symmetric = TRUE)
    ev <- e$values[seq_len(k)]
    evec <- e$vectors[, seq_len(k), drop = FALSE]
    k1 <- sum(ev > 0)
    if (k1 < k) {
        warning(gettextf("only %d of the first %d eigenvalues are > 0", 
            k1, k), domain = NA)
        evec <- evec[, ev > 0, drop = FALSE]
        ev <- ev[ev > 0]
    }
    points <- evec * rep(sqrt(ev), each = n)
    dimnames(points) <- list(rn, NULL)
    if (eig || x.ret || add) {
        evalus <- e$values
        list(points = points, eig = if (eig) evalus, x = if (x.ret) x, 
            ac = if (add) add.c else 0, GOF = sum(ev)/c(sum(abs(evalus)), 
                sum(pmax(evalus, 0))))
    }
    else points
}
<environment: namespace:stats>
> print("coef"); if(is.function(try(coef))) {coef;} else{ NULL};
[1] "coef"
function (object, ...) 
UseMethod("coef")
<environment: namespace:stats>
> print("complete.cases"); if(is.function(try(complete.cases))) {complete.cases;} else{ NULL};
[1] "complete.cases"
function (...) 
.Internal(complete.cases(...))
<environment: namespace:stats>
> print("confint"); if(is.function(try(confint))) {confint;} else{ NULL};
[1] "confint"
function (object, parm, level = 0.95, ...) 
UseMethod("confint")
<environment: namespace:stats>
> print("constrOptim"); if(is.function(try(constrOptim))) {constrOptim;} else{ NULL};
[1] "constrOptim"
function (theta, f, grad, ui, ci, mu = 1e-04, control = list(), 
    method = if (is.null(grad)) "Nelder-Mead" else "BFGS", outer.iterations = 100, 
    outer.eps = 1e-05, ..., hessian = FALSE) 
{
    if (!is.null(control$fnscale) && control$fnscale < 0) 
        mu <- -mu
    R <- function(theta, theta.old, ...) {
        ui.theta <- ui %*% theta
        gi <- ui.theta - ci
        if (any(gi < 0)) 
            return(NaN)
        gi.old <- ui %*% theta.old - ci
        bar <- sum(gi.old * log(gi) - ui.theta)
        if (!is.finite(bar)) 
            bar <- -Inf
        f(theta, ...) - mu * bar
    }
    dR <- function(theta, theta.old, ...) {
        ui.theta <- ui %*% theta
        gi <- drop(ui.theta - ci)
        gi.old <- drop(ui %*% theta.old - ci)
        dbar <- colSums(ui * gi.old/gi - ui)
        grad(theta, ...) - mu * dbar
    }
    if (any(ui %*% theta - ci <= 0)) 
        stop("initial value is not in the interior of the feasible region")
    obj <- f(theta, ...)
    r <- R(theta, theta, ...)
    fun <- function(theta, ...) R(theta, theta.old, ...)
    gradient <- if (method == "SANN") {
        if (missing(grad)) 
            NULL
        else grad
    }
    else function(theta, ...) dR(theta, theta.old, ...)
    totCounts <- 0
    s.mu <- sign(mu)
    for (i in seq_len(outer.iterations)) {
        obj.old <- obj
        r.old <- r
        theta.old <- theta
        a <- optim(theta.old, fun, gradient, control = control, 
            method = method, hessian = hessian, ...)
        r <- a$value
        if (is.finite(r) && is.finite(r.old) && abs(r - r.old) < 
            (0.001 + abs(r)) * outer.eps) 
            break
        theta <- a$par
        totCounts <- totCounts + a$counts
        obj <- f(theta, ...)
        if (s.mu * obj > s.mu * obj.old) 
            break
    }
    if (i == outer.iterations) {
        a$convergence <- 7
        a$message <- gettext("Barrier algorithm ran out of iterations and did not converge")
    }
    if (mu > 0 && obj > obj.old) {
        a$convergence <- 11
        a$message <- gettextf("Objective function increased at outer iteration %d", 
            i)
    }
    if (mu < 0 && obj < obj.old) {
        a$convergence <- 11
        a$message <- gettextf("Objective function decreased at outer iteration %d", 
            i)
    }
    a$outer.iterations <- i
    a$counts <- totCounts
    a$barrier.value <- a$value
    a$value <- f(a$par, ...)
    a$barrier.value <- a$barrier.value - a$value
    a
}
<environment: namespace:stats>
> print("contr.helmert"); if(is.function(try(contr.helmert))) {contr.helmert;} else{ NULL};
[1] "contr.helmert"
function (n, contrasts = TRUE, sparse = FALSE) 
{
    if (length(n) <= 1L) {
        if (is.numeric(n) && length(n) == 1L && n > 1L) 
            levels <- seq_len(n)
        else stop("not enough degrees of freedom to define contrasts")
    }
    else levels <- n
    levels <- as.character(levels)
    if (contrasts) {
        n <- length(levels)
        cont <- array(-1, c(n, n - 1L), list(levels, NULL))
        cont[col(cont) <= row(cont) - 2L] <- 0
        cont[col(cont) == row(cont) - 1L] <- seq_len(n - 1L)
        colnames(cont) <- NULL
        if (sparse) 
            .asSparse(cont)
        else cont
    }
    else .Diag(levels, sparse = sparse)
}
<environment: namespace:stats>
> print("contrasts"); if(is.function(try(contrasts))) {contrasts;} else{ NULL};
[1] "contrasts"
function (x, contrasts = TRUE, sparse = FALSE) 
{
    if (is.logical(x)) 
        x <- factor(x, levels = c(FALSE, TRUE))
    if (!is.factor(x)) 
        stop("contrasts apply only to factors")
    if (!contrasts) 
        return(.Diag(levels(x), sparse = sparse))
    ctr <- attr(x, "contrasts")
    if ((NL <- is.null(ctr)) || is.character(ctr)) {
        if (NL) 
            ctr <- getOption("contrasts")[[if (is.ordered(x)) 
                2L
            else 1L]]
        ctrfn <- get(ctr, mode = "function", envir = parent.frame())
        if (useSparse <- isTRUE(sparse)) {
            if (!(useSparse <- any("sparse" == names(formals(ctrfn))))) 
                warning(sprintf("contrast function '%s' does not support 'sparse = TRUE'", 
                  ctr), domain = NA)
        }
        ctr <- if (useSparse) 
            ctrfn(levels(x), contrasts = contrasts, sparse = sparse)
        else ctrfn(levels(x), contrasts = contrasts)
    }
    ctr
}
<environment: namespace:stats>
> print("convolve"); if(is.function(try(convolve))) {convolve;} else{ NULL};
[1] "convolve"
function (x, y, conj = TRUE, type = c("circular", "open", "filter")) 
{
    type <- match.arg(type)
    n <- length(x)
    ny <- length(y)
    Real <- is.numeric(x) && is.numeric(y)
    if (type == "circular") {
        if (ny != n) 
            stop("length mismatch in convolution")
    }
    else {
        n1 <- ny - 1
        x <- c(rep.int(0, n1), x)
        n <- length(y <- c(y, rep.int(0, n - 1)))
    }
    x <- fft(fft(x) * (if (conj) 
        Conj(fft(y))
    else fft(y)), inverse = TRUE)
    if (type == "filter") 
        (if (Real) 
            Re(x)
        else x)[-c(1L:n1, (n - n1 + 1L):n)]/n
    else (if (Real) 
        Re(x)
    else x)/n
}
<environment: namespace:stats>
> print("cophenetic"); if(is.function(try(cophenetic))) {cophenetic;} else{ NULL};
[1] "cophenetic"
function (x) 
UseMethod("cophenetic")
<environment: namespace:stats>
> print("cor"); if(is.function(try(cor))) {cor;} else{ NULL};
[1] "cor"
function (x, y = NULL, use = "everything", method = c("pearson", 
    "kendall", "spearman")) 
{
    na.method <- pmatch(use, c("all.obs", "complete.obs", "pairwise.complete.obs", 
        "everything", "na.or.complete"))
    if (is.na(na.method)) 
        stop("invalid 'use' argument")
    method <- match.arg(method)
    if (is.data.frame(y)) 
        y <- as.matrix(y)
    if (is.data.frame(x)) 
        x <- as.matrix(x)
    if (!is.matrix(x) && is.null(y)) 
        stop("supply both 'x' and 'y' or a matrix-like 'x'")
    if (!(is.numeric(x) || is.logical(x))) 
        stop("'x' must be numeric")
    stopifnot(is.atomic(x))
    if (!is.null(y)) {
        if (!(is.numeric(y) || is.logical(y))) 
            stop("'y' must be numeric")
        stopifnot(is.atomic(y))
    }
    Rank <- function(u) {
        if (length(u) == 0L) 
            u
        else if (is.matrix(u)) {
            if (nrow(u) > 1L) 
                apply(u, 2L, rank, na.last = "keep")
            else row(u)
        }
        else rank(u, na.last = "keep")
    }
    if (method == "pearson") 
        .Internal(cor(x, y, na.method, FALSE))
    else if (na.method %in% c(2L, 5L)) {
        if (is.null(y)) {
            .Internal(cor(Rank(na.omit(x)), NULL, na.method, 
                method == "kendall"))
        }
        else {
            nas <- attr(na.omit(cbind(x, y)), "na.action")
            dropNA <- function(x, nas) {
                if (length(nas)) {
                  if (is.matrix(x)) 
                    x[-nas, , drop = FALSE]
                  else x[-nas]
                }
                else x
            }
            .Internal(cor(Rank(dropNA(x, nas)), Rank(dropNA(y, 
                nas)), na.method, method == "kendall"))
        }
    }
    else if (na.method != 3L) {
        x <- Rank(x)
        if (!is.null(y)) 
            y <- Rank(y)
        .Internal(cor(x, y, na.method, method == "kendall"))
    }
    else {
        if (is.null(y)) {
            ncy <- ncx <- ncol(x)
            if (ncx == 0) 
                stop("'x' is empty")
            r <- matrix(0, nrow = ncx, ncol = ncy)
            for (i in seq_len(ncx)) {
                for (j in seq_len(i)) {
                  x2 <- x[, i]
                  y2 <- x[, j]
                  ok <- complete.cases(x2, y2)
                  x2 <- rank(x2[ok])
                  y2 <- rank(y2[ok])
                  r[i, j] <- if (any(ok)) 
                    .Internal(cor(x2, y2, 1L, method == "kendall"))
                  else NA
                }
            }
            r <- r + t(r) - diag(diag(r))
            rownames(r) <- colnames(x)
            colnames(r) <- colnames(x)
            r
        }
        else {
            if (length(x) == 0L || length(y) == 0L) 
                stop("both 'x' and 'y' must be non-empty")
            matrix_result <- is.matrix(x) || is.matrix(y)
            if (!is.matrix(x)) 
                x <- matrix(x, ncol = 1L)
            if (!is.matrix(y)) 
                y <- matrix(y, ncol = 1L)
            ncx <- ncol(x)
            ncy <- ncol(y)
            r <- matrix(0, nrow = ncx, ncol = ncy)
            for (i in seq_len(ncx)) {
                for (j in seq_len(ncy)) {
                  x2 <- x[, i]
                  y2 <- y[, j]
                  ok <- complete.cases(x2, y2)
                  x2 <- rank(x2[ok])
                  y2 <- rank(y2[ok])
                  r[i, j] <- if (any(ok)) 
                    .Internal(cor(x2, y2, 1L, method == "kendall"))
                  else NA
                }
            }
            rownames(r) <- colnames(x)
            colnames(r) <- colnames(y)
            if (matrix_result) 
                r
            else drop(r)
        }
    }
}
<environment: namespace:stats>
> print("cor.test"); if(is.function(try(cor.test))) {cor.test;} else{ NULL};
[1] "cor.test"
function (x, ...) 
UseMethod("cor.test")
<environment: namespace:stats>
> print("cov.wt"); if(is.function(try(cov.wt))) {cov.wt;} else{ NULL};
[1] "cov.wt"
function (x, wt = rep(1/nrow(x), nrow(x)), cor = FALSE, center = TRUE, 
    method = c("unbiased", "ML")) 
{
    if (is.data.frame(x)) 
        x <- as.matrix(x)
    else if (!is.matrix(x)) 
        stop("'x' must be a matrix or a data frame")
    if (!all(is.finite(x))) 
        stop("'x' must contain finite values only")
    n <- nrow(x)
    if (with.wt <- !missing(wt)) {
        if (length(wt) != n) 
            stop("length of 'wt' must equal the number of rows in 'x'")
        if (any(wt < 0) || (s <- sum(wt)) == 0) 
            stop("weights must be non-negative and not all zero")
        wt <- wt/s
    }
    if (is.logical(center)) {
        center <- if (center) 
            colSums(wt * x)
        else 0
    }
    else {
        if (length(center) != ncol(x)) 
            stop("length of 'center' must equal the number of columns in 'x'")
    }
    x <- sqrt(wt) * sweep(x, 2, center, check.margin = FALSE)
    cov <- switch(match.arg(method), unbiased = crossprod(x)/(1 - 
        sum(wt^2)), ML = crossprod(x))
    y <- list(cov = cov, center = center, n.obs = n)
    if (with.wt) 
        y$wt <- wt
    if (cor) {
        Is <- 1/sqrt(diag(cov))
        R <- cov
        R[] <- Is * cov * rep(Is, each = nrow(cov))
        y$cor <- R
    }
    y
}
<environment: namespace:stats>
> print("cpgram"); if(is.function(try(cpgram))) {cpgram;} else{ NULL};
[1] "cpgram"
function (ts, taper = 0.1, main = paste("Series: ", deparse(substitute(ts))), 
    ci.col = "blue") 
{
    main
    if (NCOL(ts) > 1) 
        stop("only implemented for univariate time series")
    x <- as.vector(ts)
    x <- x[!is.na(x)]
    x <- spec.taper(scale(x, TRUE, FALSE), p = taper)
    y <- Mod(fft(x))^2/length(x)
    y[1L] <- 0
    n <- length(x)
    x <- (0:(n/2)) * frequency(ts)/n
    if (length(x)%%2 == 0) {
        n <- length(x) - 1
        y <- y[1L:n]
        x <- x[1L:n]
    }
    else y <- y[seq_along(x)]
    xm <- frequency(ts)/2
    mp <- length(x) - 1
    crit <- 1.358/(sqrt(mp) + 0.12 + 0.11/sqrt(mp))
    oldpty <- par(pty = "s")
    on.exit(par(oldpty))
    plot(x, cumsum(y)/sum(y), type = "s", xlim = c(0, xm), ylim = c(0, 
        1), xaxs = "i", yaxs = "i", xlab = "frequency", ylab = "")
    lines(c(0, xm * (1 - crit)), c(crit, 1), col = ci.col, lty = 2)
    lines(c(xm * crit, xm), c(0, 1 - crit), col = ci.col, lty = 2)
    title(main = main)
    invisible()
}
<environment: namespace:stats>
> print("cutree"); if(is.function(try(cutree))) {cutree;} else{ NULL};
[1] "cutree"
function (tree, k = NULL, h = NULL) 
{
    if (is.null(n1 <- nrow(tree$merge)) || n1 < 1) 
        stop("invalid 'tree' (merge component)")
    n <- n1 + 1
    if (is.null(k) && is.null(h)) 
        stop("either 'k' or 'h' must be specified")
    if (is.null(k)) {
        if (is.unsorted(tree$height)) 
            stop("the 'height' component of 'tree' is not sorted\n(increasingly); consider applying as.hclust() first")
        k <- n + 1L - apply(outer(c(tree$height, Inf), h, ">"), 
            2, which.max)
        if (getOption("verbose")) 
            message("cutree(): k(h) = ", k, domain = NA)
    }
    else {
        k <- as.integer(k)
        if (min(k) < 1 || max(k) > n) 
            stop(gettextf("elements of 'k' must be between 1 and %d", 
                n), domain = NA)
    }
    ans <- .Call("R_cutree", tree$merge, k, PACKAGE = "stats")
    if (length(k) == 1L) {
        ans <- as.vector(ans)
        names(ans) <- tree$labels
    }
    else {
        colnames(ans) <- if (!is.null(h)) 
            h
        else k
        rownames(ans) <- tree$labels
    }
    return(ans)
}
<environment: namespace:stats>
> print("decompose"); if(is.function(try(decompose))) {decompose;} else{ NULL};
[1] "decompose"
function (x, type = c("additive", "multiplicative"), filter = NULL) 
{
    type <- match.arg(type)
    l <- length(x)
    f <- frequency(x)
    if (f <= 1 || length(na.omit(x)) < 2 * f) 
        stop("time series has no or less than 2 periods")
    if (is.null(filter)) 
        filter <- if (!f%%2) 
            c(0.5, rep(1, f - 1), 0.5)/f
        else rep(1, f)/f
    trend <- filter(x, filter)
    season <- if (type == "additive") 
        x - trend
    else x/trend
    season <- na.omit(c(as.numeric(window(season, start(x) + 
        c(1, 0), end(x))), as.numeric(window(season, start(x), 
        start(x) + c(0, f)))))
    periods <- l%/%f
    index <- c(0, cumsum(rep(f, periods - 2)))
    figure <- numeric(f)
    for (i in 1L:f) figure[i] <- mean(season[index + i])
    figure <- if (type == "additive") 
        figure - mean(figure)
    else figure/mean(figure)
    seasonal <- ts(rep(figure, periods + 1)[seq_len(l)], start = start(x), 
        frequency = f)
    structure(list(seasonal = seasonal, trend = trend, random = if (type == 
        "additive") x - seasonal - trend else x/seasonal/trend, 
        figure = figure, type = type), class = "decomposed.ts")
}
<environment: namespace:stats>
> print("delete.response"); if(is.function(try(delete.response))) {delete.response;} else{ NULL};
[1] "delete.response"
function (termobj) 
{
    a <- attributes(termobj)
    y <- a$response
    if (!is.null(y) && y) {
        termobj[[2L]] <- NULL
        a$response <- 0
        a$variables <- a$variables[-(1 + y)]
        a$predvars <- a$predvars[-(1 + y)]
        if (length(a$factors)) 
            a$factors <- a$factors[-y, , drop = FALSE]
        if (length(a$offset)) 
            a$offset <- ifelse(a$offset > y, a$offset - 1, a$offset)
        if (length(a$specials)) 
            for (i in seq_along(a$specials)) {
                b <- a$specials[[i]]
                a$specials[[i]] <- ifelse(b > y, b - 1, b)
            }
        attributes(termobj) <- a
    }
    termobj
}
<environment: namespace:stats>
> print("dendrapply"); if(is.function(try(dendrapply))) {dendrapply;} else{ NULL};
[1] "dendrapply"
function (X, FUN, ...) 
{
    FUN <- match.fun(FUN)
    if (!inherits(X, "dendrogram")) 
        stop("'X' is not a dendrogram")
    Napply <- function(d) {
        r <- FUN(d, ...)
        if (!is.leaf(d)) {
            if (!is.list(r)) 
                r <- as.list(r)
            if (length(r) < (n <- length(d))) 
                r[seq_len(n)] <- vector("list", n)
            r[] <- lapply(d, Napply)
        }
        r
    }
    Napply(X)
}
<environment: namespace:stats>
> print("dendrogram"); if(is.function(try(dendrogram))) {dendrogram;} else{ NULL};
[1] "dendrogram"
NULL
> print("density"); if(is.function(try(density))) {density;} else{ NULL};
[1] "density"
function (x, ...) 
UseMethod("density")
<environment: namespace:stats>
> print("deriv"); if(is.function(try(deriv))) {deriv;} else{ NULL};
[1] "deriv"
function (expr, ...) 
UseMethod("deriv")
<environment: namespace:stats>
> print("deviance"); if(is.function(try(deviance))) {deviance;} else{ NULL};
[1] "deviance"
function (object, ...) 
UseMethod("deviance")
<environment: namespace:stats>
> print("df.residual"); if(is.function(try(df.residual))) {df.residual;} else{ NULL};
[1] "df.residual"
function (object, ...) 
UseMethod("df.residual")
<environment: namespace:stats>
> print("diff.ts"); if(is.function(try(diff.ts))) {diff.ts;} else{ NULL};
[1] "diff.ts"
function (x, lag = 1, differences = 1, ...) 
{
    if (lag < 1 | differences < 1) 
        stop("bad value for 'lag' or 'differences'")
    if (lag * differences >= NROW(x)) 
        return(x[0L])
    tsLag <- function(x, k = 1) {
        p <- tsp(x)
        tsp(x) <- p - (k/p[3L]) * c(1, 1, 0)
        x
    }
    r <- x
    for (i in 1L:differences) {
        r <- r - tsLag(r, -lag)
    }
    xtsp <- attr(x, "tsp")
    if (is.matrix(x)) 
        colnames(r) <- colnames(x)
    ts(r, end = xtsp[2L], frequency = xtsp[3L])
}
<environment: namespace:stats>
> print("diffinv"); if(is.function(try(diffinv))) {diffinv;} else{ NULL};
[1] "diffinv"
function (x, ...) 
{
    UseMethod("diffinv")
}
<environment: namespace:stats>
> print("dist"); if(is.function(try(dist))) {dist;} else{ NULL};
[1] "dist"
function (x, method = "euclidean", diag = FALSE, upper = FALSE, 
    p = 2) 
{
    if (!is.na(pmatch(method, "euclidian"))) 
        method <- "euclidean"
    METHODS <- c("euclidean", "maximum", "manhattan", "canberra", 
        "binary", "minkowski")
    method <- pmatch(method, METHODS)
    if (is.na(method)) 
        stop("invalid distance method")
    if (method == -1) 
        stop("ambiguous distance method")
    N <- nrow(x <- as.matrix(x))
    d <- .C("R_distance", x = as.double(x), nr = N, nc = ncol(x), 
        d = double(N * (N - 1)/2), diag = as.integer(FALSE), 
        method = as.integer(method), p = as.double(p), DUP = FALSE, 
        NAOK = TRUE, PACKAGE = "stats")$d
    attr(d, "Size") <- N
    attr(d, "Labels") <- dimnames(x)[[1L]]
    attr(d, "Diag") <- diag
    attr(d, "Upper") <- upper
    attr(d, "method") <- METHODS[method]
    if (method == 6) 
        attr(d, "p") <- p
    attr(d, "call") <- match.call()
    class(d) <- "dist"
    return(d)
}
<environment: namespace:stats>
> print("dummy.coef"); if(is.function(try(dummy.coef))) {dummy.coef;} else{ NULL};
[1] "dummy.coef"
function (object, ...) 
UseMethod("dummy.coef")
<environment: namespace:stats>
> print("ecdf"); if(is.function(try(ecdf))) {ecdf;} else{ NULL};
[1] "ecdf"
function (x) 
{
    x <- sort(x)
    n <- length(x)
    if (n < 1) 
        stop("'x' must have 1 or more non-missing values")
    vals <- unique(x)
    rval <- approxfun(vals, cumsum(tabulate(match(x, vals)))/n, 
        method = "constant", yleft = 0, yright = 1, f = 0, ties = "ordered")
    class(rval) <- c("ecdf", "stepfun", class(rval))
    assign("nobs", n, envir = environment(rval))
    attr(rval, "call") <- sys.call()
    rval
}
<environment: namespace:stats>
> print("eff.aovlist"); if(is.function(try(eff.aovlist))) {eff.aovlist;} else{ NULL};
[1] "eff.aovlist"
function (aovlist) 
{
    Terms <- terms(aovlist)
    if (names(aovlist)[[1L]] == "(Intercept)") 
        aovlist <- aovlist[-1L]
    pure.error.strata <- sapply(aovlist, function(x) is.null(x$qr))
    aovlist <- aovlist[!pure.error.strata]
    s.labs <- names(aovlist)
    s.terms <- lapply(aovlist, function(x) {
        asgn <- x$assign[x$qr$pivot[1L:x$rank]]
        attr(terms(x), "term.labels")[asgn]
    })
    t.labs <- attr(Terms, "term.labels")
    t.labs <- t.labs[t.labs %in% unlist(s.terms)]
    eff <- matrix(0, ncol = length(t.labs), nrow = length(s.labs), 
        dimnames = list(s.labs, t.labs))
    for (i in names(s.terms)) eff[i, s.terms[[i]]] <- 1
    cs <- colSums(eff)
    if (all(cs <= 1)) 
        return(eff[, cs > 0, drop = FALSE])
    nm <- t.labs[cs > 1]
    pl <- lapply(aovlist, function(x) {
        asgn <- x$assign[x$qr$pivot[1L:x$rank]]
        sp <- split(seq_along(asgn), attr(terms(x), "term.labels")[asgn])
        sp <- sp[names(sp) %in% nm]
        sapply(sp, function(x, y) {
            y <- y[x, x, drop = FALSE]
            res <- sum(diag(y)^2)
            if (nrow(y) > 1 && sum(y^2) > 1.01 * res) 
                stop("eff.aovlist: non-orthogonal contrasts would give an incorrect answer")
            res
        }, y = x$qr$qr)
    })
    for (i in names(pl)) eff[i, names(pl[[i]])] <- pl[[i]]
    cs <- colSums(eff)
    eff <- eff/rep(cs, each = nrow(eff))
    eff[, cs != 0, drop = FALSE]
}
<environment: namespace:stats>
> print("effects"); if(is.function(try(effects))) {effects;} else{ NULL};
[1] "effects"
function (object, ...) 
UseMethod("effects")
<environment: namespace:stats>
> print("embed"); if(is.function(try(embed))) {embed;} else{ NULL};
[1] "embed"
function (x, dimension = 1) 
{
    if (is.matrix(x)) {
        n <- nrow(x)
        m <- ncol(x)
        if ((dimension < 1) | (dimension > n)) 
            stop("wrong embedding dimension")
        y <- matrix(0, n - dimension + 1L, dimension * m)
        for (i in seq_len(m)) y[, seq.int(i, by = m, length.out = dimension)] <- Recall(as.vector(x[, 
            i]), dimension)
        return(y)
    }
    else if (is.vector(x) || is.ts(x)) {
        n <- length(x)
        if ((dimension < 1) | (dimension > n)) 
            stop("wrong embedding dimension")
        m <- n - dimension + 1L
        data <- x[1L:m + rep.int(dimension:1L, rep.int(m, dimension)) - 
            1L]
        dim(data) <- c(m, dimension)
        return(data)
    }
    else stop("'x' is not a vector or matrix")
}
<environment: namespace:stats>
> print("expand.model.frame"); if(is.function(try(expand.model.frame))) {expand.model.frame;} else{ NULL};
[1] "expand.model.frame"
function (model, extras, envir = environment(formula(model)), 
    na.expand = FALSE) 
{
    f <- formula(model)
    data <- eval(model$call$data, envir)
    ff <- foo ~ bar + baz
    if (is.call(extras)) 
        gg <- extras
    else gg <- parse(text = paste("~", paste(extras, collapse = "+")))[[1L]]
    ff[[2L]] <- f[[2L]]
    ff[[3L]][[2L]] <- f[[3L]]
    ff[[3L]][[3L]] <- gg[[2L]]
    if (!na.expand) {
        naa <- model$call$na.action
        subset <- model$call$subset
        rval <- eval(call("model.frame", ff, data = data, subset = subset, 
            na.action = naa), envir)
    }
    else {
        subset <- model$call$subset
        rval <- eval(call("model.frame", ff, data = data, subset = subset, 
            na.action = I), envir)
        oldmf <- model.frame(model)
        keep <- match(rownames(oldmf), rownames(rval))
        rval <- rval[keep, ]
        class(rval) <- "data.frame"
    }
    return(rval)
}
<environment: namespace:stats>
> print("extractAIC"); if(is.function(try(extractAIC))) {extractAIC;} else{ NULL};
[1] "extractAIC"
function (fit, scale, k = 2, ...) 
UseMethod("extractAIC")
<environment: namespace:stats>
> print("factanal"); if(is.function(try(factanal))) {factanal;} else{ NULL};
[1] "factanal"
function (x, factors, data = NULL, covmat = NULL, n.obs = NA, 
    subset, na.action, start = NULL, scores = c("none", "regression", 
        "Bartlett"), rotation = "varimax", control = NULL, ...) 
{
    sortLoadings <- function(Lambda) {
        cn <- colnames(Lambda)
        Phi <- attr(Lambda, "covariance")
        ssq <- apply(Lambda, 2L, function(x) -sum(x^2))
        Lambda <- Lambda[, order(ssq), drop = FALSE]
        colnames(Lambda) <- cn
        neg <- colSums(Lambda) < 0
        Lambda[, neg] <- -Lambda[, neg]
        if (!is.null(Phi)) {
            unit <- ifelse(neg, -1, 1)
            attr(Lambda, "covariance") <- unit %*% Phi[order(ssq), 
                order(ssq)] %*% unit
        }
        Lambda
    }
    cl <- match.call()
    na.act <- NULL
    if (is.list(covmat)) {
        if (any(is.na(match(c("cov", "n.obs"), names(covmat))))) 
            stop("'covmat' is not a valid covariance list")
        cv <- covmat$cov
        n.obs <- covmat$n.obs
        have.x <- FALSE
    }
    else if (is.matrix(covmat)) {
        cv <- covmat
        have.x <- FALSE
    }
    else if (is.null(covmat)) {
        if (missing(x)) 
            stop("neither 'x' nor 'covmat' supplied")
        have.x <- TRUE
        if (inherits(x, "formula")) {
            mt <- terms(x, data = data)
            if (attr(mt, "response") > 0) 
                stop("response not allowed in formula")
            attr(mt, "intercept") <- 0
            mf <- match.call(expand.dots = FALSE)
            names(mf)[names(mf) == "x"] <- "formula"
            mf$factors <- mf$covmat <- mf$scores <- mf$start <- mf$rotation <- mf$control <- mf$... <- NULL
            mf[[1L]] <- as.name("model.frame")
            mf <- eval.parent(mf)
            na.act <- attr(mf, "na.action")
            if (.check_vars_numeric(mf)) 
                stop("factor analysis applies only to numerical variables")
            z <- model.matrix(mt, mf)
        }
        else {
            z <- as.matrix(x)
            if (!is.numeric(z)) 
                stop("factor analysis applies only to numerical variables")
            if (!missing(subset)) 
                z <- z[subset, , drop = FALSE]
        }
        covmat <- cov.wt(z)
        cv <- covmat$cov
        n.obs <- covmat$n.obs
    }
    else stop("'covmat' is of unknown type")
    scores <- match.arg(scores)
    if (scores != "none" && !have.x) 
        stop("requested scores without an 'x' matrix")
    p <- ncol(cv)
    if (p < 3) 
        stop("factor analysis requires at least three variables")
    dof <- 0.5 * ((p - factors)^2 - p - factors)
    if (dof < 0) 
        stop(gettextf("%d factors is too many for %d variables", 
            factors, p), domain = NA)
    sds <- sqrt(diag(cv))
    cv <- cv/(sds %o% sds)
    cn <- list(nstart = 1, trace = FALSE, lower = 0.005)
    cn[names(control)] <- control
    more <- list(...)[c("nstart", "trace", "lower", "opt", "rotate")]
    if (length(more)) 
        cn[names(more)] <- more
    if (is.null(start)) {
        start <- (1 - 0.5 * factors/p)/diag(solve(cv))
        if ((ns <- cn$nstart) > 1) 
            start <- cbind(start, matrix(runif(ns - 1), p, ns - 
                1, byrow = TRUE))
    }
    start <- as.matrix(start)
    if (nrow(start) != p) 
        stop(gettextf("'start' must have %d rows", p), domain = NA)
    nc <- ncol(start)
    if (nc < 1) 
        stop("no starting values supplied")
    best <- Inf
    for (i in 1L:nc) {
        nfit <- factanal.fit.mle(cv, factors, start[, i], max(cn$lower, 
            0), cn$opt)
        if (cn$trace) 
            cat("start", i, "value:", format(nfit$criteria[1L]), 
                "uniqs:", format(as.vector(round(nfit$uniquenesses, 
                  4))), "\n")
        if (nfit$converged && nfit$criteria[1L] < best) {
            fit <- nfit
            best <- fit$criteria[1L]
        }
    }
    if (best == Inf) 
        stop("unable to optimize from these starting value(s)")
    load <- fit$loadings
    if (rotation != "none") {
        rot <- do.call(rotation, c(list(load), cn$rotate))
        load <- if (is.list(rot)) {
            load <- rot$loadings
            fit$rotmat <- if (inherits(rot, "GPArotation")) 
                t(solve(rot$Th))
            else rot$rotmat
            rot$loadings
        }
        else rot
    }
    fit$loadings <- sortLoadings(load)
    class(fit$loadings) <- "loadings"
    fit$na.action <- na.act
    if (have.x && scores != "none") {
        Lambda <- fit$loadings
        zz <- scale(z, TRUE, TRUE)
        switch(scores, regression = {
            sc <- zz %*% solve(cv, Lambda)
            if (!is.null(Phi <- attr(Lambda, "covariance"))) sc <- sc %*% 
                Phi
        }, Bartlett = {
            d <- 1/fit$uniquenesses
            tmp <- t(Lambda * d)
            sc <- t(solve(tmp %*% Lambda, tmp %*% t(zz)))
        })
        rownames(sc) <- rownames(z)
        colnames(sc) <- colnames(Lambda)
        if (!is.null(na.act)) 
            sc <- napredict(na.act, sc)
        fit$scores <- sc
    }
    if (!is.na(n.obs) && dof > 0) {
        fit$STATISTIC <- (n.obs - 1 - (2 * p + 5)/6 - (2 * factors)/3) * 
            fit$criteria["objective"]
        fit$PVAL <- pchisq(fit$STATISTIC, dof, lower.tail = FALSE)
    }
    fit$n.obs <- n.obs
    fit$call <- cl
    fit
}
<environment: namespace:stats>
> print("factor.scope"); if(is.function(try(factor.scope))) {factor.scope;} else{ NULL};
[1] "factor.scope"
function (factor, scope) 
{
    drop <- scope$drop
    add <- scope$add
    if (length(factor) && !is.null(drop)) {
        nmdrop <- colnames(drop)
        facs <- factor
        if (length(drop)) {
            nmfac <- colnames(factor)
            nmfac0 <- sapply(strsplit(nmfac, ":", fixed = TRUE), 
                function(x) paste(sort(x), collapse = ":"))
            nmdrop0 <- sapply(strsplit(nmdrop, ":", fixed = TRUE), 
                function(x) paste(sort(x), collapse = ":"))
            where <- match(nmdrop0, nmfac0, 0L)
            if (any(!where)) 
                stop(gettextf("lower scope has term(s) %s not included in model", 
                  paste(sQuote(nmdrop[where == 0]), collapse = ", ")), 
                  domain = NA)
            facs <- factor[, -where, drop = FALSE]
            nmdrop <- nmfac[-where]
        }
        else nmdrop <- colnames(factor)
        if (ncol(facs) > 1) {
            keep <- rep.int(TRUE, ncol(facs))
            f <- crossprod(facs > 0)
            for (i in seq(keep)) keep[i] <- max(f[i, -i]) != 
                f[i, i]
            nmdrop <- nmdrop[keep]
        }
    }
    else nmdrop <- character()
    if (!length(add)) 
        nmadd <- character()
    else {
        nmfac <- colnames(factor)
        nmadd <- colnames(add)
        if (!is.null(nmfac)) {
            nmfac0 <- sapply(strsplit(nmfac, ":", fixed = TRUE), 
                function(x) paste(sort(x), collapse = ":"))
            nmadd0 <- sapply(strsplit(nmadd, ":", fixed = TRUE), 
                function(x) paste(sort(x), collapse = ":"))
            where <- match(nmfac0, nmadd0, 0L)
            if (any(!where)) 
                stop(gettextf("upper scope does not include model term(s) %s", 
                  paste(sQuote(nmfac[where == 0L]), collapse = ", ")), 
                  domain = NA)
            nmadd <- nmadd[-where]
            add <- add[, -where, drop = FALSE]
        }
        if (ncol(add) > 1) {
            keep <- rep.int(TRUE, ncol(add))
            f <- crossprod(add > 0)
            for (i in seq(keep)) keep[-i] <- keep[-i] & (f[i, 
                -i] < f[i, i])
            nmadd <- nmadd[keep]
        }
    }
    list(drop = nmdrop, add = nmadd)
}
<environment: namespace:stats>
> print("family"); if(is.function(try(family))) {family;} else{ NULL};
[1] "family"
function (object, ...) 
UseMethod("family")
<environment: namespace:stats>
> print("family.glm"); if(is.function(try(family.glm))) {family.glm;} else{ NULL};
[1] "family.glm"
NULL
> print("family.lm"); if(is.function(try(family.lm))) {family.lm;} else{ NULL};
[1] "family.lm"
NULL
> print("fft"); if(is.function(try(fft))) {fft;} else{ NULL};
[1] "fft"
function (z, inverse = FALSE) 
.Internal(fft(z, inverse))
<environment: namespace:stats>
> print("filter"); if(is.function(try(filter))) {filter;} else{ NULL};
[1] "filter"
function (x, filter, method = c("convolution", "recursive"), 
    sides = 2, circular = FALSE, init = NULL) 
{
    method <- match.arg(method)
    x <- as.ts(x)
    xtsp <- tsp(x)
    x <- as.matrix(x)
    n <- nrow(x)
    nser <- ncol(x)
    nfilt <- length(filter)
    if (any(is.na(filter))) 
        stop("missing values in 'filter'")
    y <- matrix(NA, n, nser)
    if (method == "convolution") {
        if (nfilt > n) 
            stop("'filter' is longer than time series")
        if (sides != 1 && sides != 2) 
            stop("argument 'sides' must be 1 or 2")
        for (i in 1L:nser) y[, i] <- .C("filter1", as.double(x[, 
            i]), as.integer(n), as.double(filter), as.integer(nfilt), 
            as.integer(sides), as.integer(circular), out = double(n), 
            NAOK = TRUE, PACKAGE = "stats")$out
    }
    else {
        if (missing(init)) {
            init <- matrix(0, nfilt, nser)
        }
        else {
            ni <- NROW(init)
            if (ni != nfilt) 
                stop("length of 'init' must equal length of 'filter'")
            if (NCOL(init) != 1 && NCOL(init) != nser) 
                stop(gettextf("'init'; must have 1 or %d cols", 
                  nser), domain = NA)
            if (!is.matrix(init)) 
                init <- matrix(init, nfilt, nser)
        }
        for (i in 1L:nser) y[, i] <- .C("filter2", as.double(x[, 
            i]), as.integer(n), as.double(filter), as.integer(nfilt), 
            out = as.double(c(rev(init[, i]), double(n))), NAOK = TRUE, 
            PACKAGE = "stats")$out[-(1L:nfilt)]
    }
    y <- drop(y)
    tsp(y) <- xtsp
    class(y) <- if (nser > 1) 
        c("mts", "ts")
    else "ts"
    y
}
<environment: namespace:stats>
> print("fisher.test"); if(is.function(try(fisher.test))) {fisher.test;} else{ NULL};
[1] "fisher.test"
function (x, y = NULL, workspace = 2e+05, hybrid = FALSE, control = list(), 
    or = 1, alternative = "two.sided", conf.int = TRUE, conf.level = 0.95, 
    simulate.p.value = FALSE, B = 2000) 
{
    DNAME <- deparse(substitute(x))
    METHOD <- "Fisher's Exact Test for Count Data"
    if (is.data.frame(x)) 
        x <- as.matrix(x)
    if (is.matrix(x)) {
        if (any(dim(x) < 2L)) 
            stop("'x' must have at least 2 rows and columns")
        if (!is.numeric(x) || any(x < 0) || any(is.na(x))) 
            stop("all entries of 'x' must be nonnegative and finite")
        if (!is.integer(x)) {
            xo <- x
            x <- round(x)
            if (any(x > .Machine$integer.max)) 
                stop("'x' has entries too large to be integer")
            if (!identical(TRUE, (ax <- all.equal(xo, x)))) 
                warning("'x' has been rounded to integer: ", 
                  ax)
            storage.mode(x) <- "integer"
        }
    }
    else {
        if (is.null(y)) 
            stop("if 'x' is not a matrix, 'y' must be given")
        if (length(x) != length(y)) 
            stop("'x' and 'y' must have the same length")
        DNAME <- paste(DNAME, "and", deparse(substitute(y)))
        OK <- complete.cases(x, y)
        x <- factor(x[OK])
        y <- factor(y[OK])
        if ((nlevels(x) < 2L) || (nlevels(y) < 2L)) 
            stop("'x' and 'y' must have at least 2 levels")
        x <- table(x, y)
    }
    con <- list(mult = 30)
    con[names(control)] <- control
    if ((mult <- as.integer(con$mult)) < 2) 
        stop("'mult' must be integer >= 2, typically = 30")
    nr <- nrow(x)
    nc <- ncol(x)
    if ((nr == 2) && (nc == 2)) {
        alternative <- char.expand(alternative, c("two.sided", 
            "less", "greater"))
        if (length(alternative) > 1L || is.na(alternative)) 
            stop("alternative must be \"two.sided\", \"less\" or \"greater\"")
        if (!((length(conf.level) == 1L) && is.finite(conf.level) && 
            (conf.level > 0) && (conf.level < 1))) 
            stop("'conf.level' must be a single number between 0 and 1")
        if (!missing(or) && (length(or) > 1L || is.na(or) || 
            or < 0)) 
            stop("'or' must be a single number between 0 and Inf")
    }
    PVAL <- NULL
    if (nr != 2 || nc != 2) {
        if (simulate.p.value) {
            sr <- rowSums(x)
            sc <- colSums(x)
            x <- x[sr > 0, sc > 0, drop = FALSE]
            nr <- nrow(x)
            nc <- ncol(x)
            if (nr <= 1) 
                stop("need 2 or more non-zero row marginals")
            if (nc <= 1) 
                stop("need 2 or more non-zero column marginals")
            METHOD <- paste(METHOD, "with simulated p-value\n\t (based on", 
                B, "replicates)")
            sr <- rowSums(x)
            sc <- colSums(x)
            n <- sum(sc)
            STATISTIC <- -sum(lfactorial(x))
            tmp <- .C("fisher_sim", as.integer(nr), as.integer(nc), 
                as.integer(sr), as.integer(sc), as.integer(n), 
                as.integer(B), integer(nr * nc), double(n + 1), 
                integer(nc), results = double(B), PACKAGE = "stats")$results
            almost.1 <- 1 + 64 * .Machine$double.eps
            PVAL <- (1 + sum(tmp <= STATISTIC/almost.1))/(B + 
                1)
        }
        else if (hybrid) {
            PVAL <- .C("fexact", nr, nc, x, nr, as.double(5), 
                as.double(80), as.double(1), double(1), p = double(1), 
                as.integer(workspace), mult = as.integer(mult), 
                PACKAGE = "stats")$p
        }
        else PVAL <- .C("fexact", nr, nc, x, nr, as.double(-1), 
            as.double(100), as.double(0), double(1), p = double(1), 
            as.integer(workspace), mult = as.integer(mult), PACKAGE = "stats")$p
        RVAL <- list(p.value = max(0, min(1, PVAL)))
    }
    if ((nr == 2) && (nc == 2)) {
        if (hybrid) 
            warning("'hybrid' is ignored for a 2 x 2 table")
        m <- sum(x[, 1])
        n <- sum(x[, 2])
        k <- sum(x[1, ])
        x <- x[1, 1]
        lo <- max(0, k - n)
        hi <- min(k, m)
        NVAL <- or
        names(NVAL) <- "odds ratio"
        support <- lo:hi
        logdc <- dhyper(support, m, n, k, log = TRUE)
        dnhyper <- function(ncp) {
            d <- logdc + log(ncp) * support
            d <- exp(d - max(d))
            d/sum(d)
        }
        mnhyper <- function(ncp) {
            if (ncp == 0) 
                return(lo)
            if (ncp == Inf) 
                return(hi)
            sum(support * dnhyper(ncp))
        }
        pnhyper <- function(q, ncp = 1, upper.tail = FALSE) {
            if (ncp == 1) {
                return(if (upper.tail) phyper(x - 1, m, n, k, 
                  lower.tail = FALSE) else phyper(x, m, n, k))
            }
            if (ncp == 0) {
                return(as.numeric(if (upper.tail) q <= lo else q >= 
                  lo))
            }
            if (ncp == Inf) {
                return(as.numeric(if (upper.tail) q <= hi else q >= 
                  hi))
            }
            sum(dnhyper(ncp)[if (upper.tail) support >= q else support <= 
                q])
        }
        if (is.null(PVAL)) {
            PVAL <- switch(alternative, less = pnhyper(x, or), 
                greater = pnhyper(x, or, upper.tail = TRUE), 
                two.sided = {
                  if (or == 0) as.numeric(x == lo) else if (or == 
                    Inf) as.numeric(x == hi) else {
                    relErr <- 1 + 10^(-7)
                    d <- dnhyper(or)
                    sum(d[d <= d[x - lo + 1] * relErr])
                  }
                })
            RVAL <- list(p.value = PVAL)
        }
        mle <- function(x) {
            if (x == lo) 
                return(0)
            if (x == hi) 
                return(Inf)
            mu <- mnhyper(1)
            if (mu > x) 
                uniroot(function(t) mnhyper(t) - x, c(0, 1))$root
            else if (mu < x) 
                1/uniroot(function(t) mnhyper(1/t) - x, c(.Machine$double.eps, 
                  1))$root
            else 1
        }
        ESTIMATE <- mle(x)
        names(ESTIMATE) <- "odds ratio"
        if (conf.int) {
            ncp.U <- function(x, alpha) {
                if (x == hi) 
                  return(Inf)
                p <- pnhyper(x, 1)
                if (p < alpha) 
                  uniroot(function(t) pnhyper(x, t) - alpha, 
                    c(0, 1))$root
                else if (p > alpha) 
                  1/uniroot(function(t) pnhyper(x, 1/t) - alpha, 
                    c(.Machine$double.eps, 1))$root
                else 1
            }
            ncp.L <- function(x, alpha) {
                if (x == lo) 
                  return(0)
                p <- pnhyper(x, 1, upper.tail = TRUE)
                if (p > alpha) 
                  uniroot(function(t) pnhyper(x, t, upper.tail = TRUE) - 
                    alpha, c(0, 1))$root
                else if (p < alpha) 
                  1/uniroot(function(t) pnhyper(x, 1/t, upper.tail = TRUE) - 
                    alpha, c(.Machine$double.eps, 1))$root
                else 1
            }
            CINT <- switch(alternative, less = c(0, ncp.U(x, 
                1 - conf.level)), greater = c(ncp.L(x, 1 - conf.level), 
                Inf), two.sided = {
                alpha <- (1 - conf.level)/2
                c(ncp.L(x, alpha), ncp.U(x, alpha))
            })
            attr(CINT, "conf.level") <- conf.level
        }
        RVAL <- c(RVAL, list(conf.int = if (conf.int) CINT, estimate = ESTIMATE, 
            null.value = NVAL))
    }
    RVAL <- c(RVAL, alternative = alternative, method = METHOD, 
        data.name = DNAME)
    attr(RVAL, "class") <- "htest"
    return(RVAL)
}
<environment: namespace:stats>
> print("fitted"); if(is.function(try(fitted))) {fitted;} else{ NULL};
[1] "fitted"
function (object, ...) 
UseMethod("fitted")
<environment: namespace:stats>
> print("fivenum"); if(is.function(try(fivenum))) {fivenum;} else{ NULL};
[1] "fivenum"
function (x, na.rm = TRUE) 
{
    xna <- is.na(x)
    if (na.rm) 
        x <- x[!xna]
    else if (any(xna)) 
        return(rep.int(NA, 5))
    x <- sort(x)
    n <- length(x)
    if (n == 0) 
        rep.int(NA, 5)
    else {
        n4 <- floor((n + 3)/2)/2
        d <- c(1, n4, (n + 1)/2, n + 1 - n4, n)
        0.5 * (x[floor(d)] + x[ceiling(d)])
    }
}
<environment: namespace:stats>
> print("fligner.test"); if(is.function(try(fligner.test))) {fligner.test;} else{ NULL};
[1] "fligner.test"
function (x, ...) 
UseMethod("fligner.test")
<environment: namespace:stats>
> print("formula"); if(is.function(try(formula))) {formula;} else{ NULL};
[1] "formula"
function (x, ...) 
UseMethod("formula")
<environment: namespace:stats>
> print("formula.nls"); if(is.function(try(formula.nls))) {formula.nls;} else{ NULL};
[1] "formula.nls"
NULL
> print("friedman.test"); if(is.function(try(friedman.test))) {friedman.test;} else{ NULL};
[1] "friedman.test"
function (y, ...) 
UseMethod("friedman.test")
<environment: namespace:stats>
> print("ftable"); if(is.function(try(ftable))) {ftable;} else{ NULL};
[1] "ftable"
function (x, ...) 
UseMethod("ftable")
<environment: namespace:stats>
> print("ftable.formula"); if(is.function(try(ftable.formula))) {ftable.formula;} else{ NULL};
[1] "ftable.formula"
NULL
> print("getInitial"); if(is.function(try(getInitial))) {getInitial;} else{ NULL};
[1] "getInitial"
function (object, data, ...) 
UseMethod("getInitial")
<environment: namespace:stats>
> print("glm"); if(is.function(try(glm))) {glm;} else{ NULL};
[1] "glm"
function (formula, family = gaussian, data, weights, subset, 
    na.action, start = NULL, etastart, mustart, offset, control = list(...), 
    model = TRUE, method = "glm.fit", x = FALSE, y = TRUE, contrasts = NULL, 
    ...) 
{
    call <- match.call()
    if (is.character(family)) 
        family <- get(family, mode = "function", envir = parent.frame())
    if (is.function(family)) 
        family <- family()
    if (is.null(family$family)) {
        print(family)
        stop("'family' not recognized")
    }
    if (missing(data)) 
        data <- environment(formula)
    mf <- match.call(expand.dots = FALSE)
    m <- match(c("formula", "data", "subset", "weights", "na.action", 
        "etastart", "mustart", "offset"), names(mf), 0L)
    mf <- mf[c(1L, m)]
    mf$drop.unused.levels <- TRUE
    mf[[1L]] <- as.name("model.frame")
    mf <- eval(mf, parent.frame())
    if (identical(method, "model.frame")) 
        return(mf)
    if (!is.character(method) && !is.function(method)) 
        stop("invalid 'method' argument")
    if (identical(method, "glm.fit")) 
        control <- do.call("glm.control", control)
    mt <- attr(mf, "terms")
    Y <- model.response(mf, "any")
    if (length(dim(Y)) == 1L) {
        nm <- rownames(Y)
        dim(Y) <- NULL
        if (!is.null(nm)) 
            names(Y) <- nm
    }
    X <- if (!is.empty.model(mt)) 
        model.matrix(mt, mf, contrasts)
    else matrix(, NROW(Y), 0L)
    weights <- as.vector(model.weights(mf))
    if (!is.null(weights) && !is.numeric(weights)) 
        stop("'weights' must be a numeric vector")
    if (!is.null(weights) && any(weights < 0)) 
        stop("negative weights not allowed")
    offset <- as.vector(model.offset(mf))
    if (!is.null(offset)) {
        if (length(offset) != NROW(Y)) 
            stop(gettextf("number of offsets is %d should equal %d (number of observations)", 
                length(offset), NROW(Y)), domain = NA)
    }
    mustart <- model.extract(mf, "mustart")
    etastart <- model.extract(mf, "etastart")
    fit <- eval(call(if (is.function(method)) "method" else method, 
        x = X, y = Y, weights = weights, start = start, etastart = etastart, 
        mustart = mustart, offset = offset, family = family, 
        control = control, intercept = attr(mt, "intercept") > 
            0L))
    if (length(offset) && attr(mt, "intercept") > 0L) {
        fit$null.deviance <- eval(call(if (is.function(method)) "method" else method, 
            x = X[, "(Intercept)", drop = FALSE], y = Y, weights = weights, 
            offset = offset, family = family, control = control, 
            intercept = TRUE))$deviance
    }
    if (model) 
        fit$model <- mf
    fit$na.action <- attr(mf, "na.action")
    if (x) 
        fit$x <- X
    if (!y) 
        fit$y <- NULL
    fit <- c(fit, list(call = call, formula = formula, terms = mt, 
        data = data, offset = offset, control = control, method = method, 
        contrasts = attr(X, "contrasts"), xlevels = .getXlevels(mt, 
            mf)))
    class(fit) <- c(fit$class, c("glm", "lm"))
    fit
}
<environment: namespace:stats>
> print("glm.control"); if(is.function(try(glm.control))) {glm.control;} else{ NULL};
[1] "glm.control"
function (epsilon = 1e-08, maxit = 25, trace = FALSE) 
{
    if (!is.numeric(epsilon) || epsilon <= 0) 
        stop("value of 'epsilon' must be > 0")
    if (!is.numeric(maxit) || maxit <= 0) 
        stop("maximum number of iterations must be > 0")
    list(epsilon = epsilon, maxit = maxit, trace = trace)
}
<environment: namespace:stats>
> print("hclust"); if(is.function(try(hclust))) {hclust;} else{ NULL};
[1] "hclust"
function (d, method = "complete", members = NULL) 
{
    METHODS <- c("ward", "single", "complete", "average", "mcquitty", 
        "median", "centroid")
    method <- pmatch(method, METHODS)
    if (is.na(method)) 
        stop("invalid clustering method")
    if (method == -1) 
        stop("ambiguous clustering method")
    n <- as.integer(attr(d, "Size"))
    if (is.null(n)) 
        stop("invalid dissimilarities")
    if (n < 2) 
        stop("must have n >= 2 objects to cluster")
    len <- as.integer(n * (n - 1)/2)
    if (length(d) != len) 
        (if (length(d) < len) 
            stop
        else warning)("dissimilarities of improper length")
    if (is.null(members)) 
        members <- rep(1, n)
    else if (length(members) != n) 
        stop("invalid length of members")
    hcl <- .Fortran("hclust", n = n, len = len, method = as.integer(method), 
        ia = integer(n), ib = integer(n), crit = double(n), members = as.double(members), 
        nn = integer(n), disnn = double(n), flag = logical(n), 
        diss = as.double(d), PACKAGE = "stats")
    hcass <- .Fortran("hcass2", n = as.integer(n), ia = as.integer(hcl$ia), 
        ib = as.integer(hcl$ib), order = integer(n), iia = integer(n), 
        iib = integer(n), PACKAGE = "stats")
    tree <- list(merge = cbind(hcass$iia[1L:(n - 1)], hcass$iib[1L:(n - 
        1)]), height = hcl$crit[1L:(n - 1)], order = hcass$order, 
        labels = attr(d, "Labels"), method = METHODS[method], 
        call = match.call(), dist.method = attr(d, "method"))
    class(tree) <- "hclust"
    tree
}
<environment: namespace:stats>
> print("heatmap"); if(is.function(try(heatmap))) {heatmap;} else{ NULL};
[1] "heatmap"
function (x, Rowv = NULL, Colv = if (symm) "Rowv" else NULL, 
    distfun = dist, hclustfun = hclust, reorderfun = function(d, 
        w) reorder(d, w), add.expr, symm = FALSE, revC = identical(Colv, 
        "Rowv"), scale = c("row", "column", "none"), na.rm = TRUE, 
    margins = c(5, 5), ColSideColors, RowSideColors, cexRow = 0.2 + 
        1/log10(nr), cexCol = 0.2 + 1/log10(nc), labRow = NULL, 
    labCol = NULL, main = NULL, xlab = NULL, ylab = NULL, keep.dendro = FALSE, 
    verbose = getOption("verbose"), ...) 
{
    scale <- if (symm && missing(scale)) 
        "none"
    else match.arg(scale)
    if (length(di <- dim(x)) != 2 || !is.numeric(x)) 
        stop("'x' must be a numeric matrix")
    nr <- di[1L]
    nc <- di[2L]
    if (nr <= 1 || nc <= 1) 
        stop("'x' must have at least 2 rows and 2 columns")
    if (!is.numeric(margins) || length(margins) != 2L) 
        stop("'margins' must be a numeric vector of length 2")
    doRdend <- !identical(Rowv, NA)
    doCdend <- !identical(Colv, NA)
    if (!doRdend && identical(Colv, "Rowv")) 
        doCdend <- FALSE
    if (is.null(Rowv)) 
        Rowv <- rowMeans(x, na.rm = na.rm)
    if (is.null(Colv)) 
        Colv <- colMeans(x, na.rm = na.rm)
    if (doRdend) {
        if (inherits(Rowv, "dendrogram")) 
            ddr <- Rowv
        else {
            hcr <- hclustfun(distfun(x))
            ddr <- as.dendrogram(hcr)
            if (!is.logical(Rowv) || Rowv) 
                ddr <- reorderfun(ddr, Rowv)
        }
        if (nr != length(rowInd <- order.dendrogram(ddr))) 
            stop("row dendrogram ordering gave index of wrong length")
    }
    else rowInd <- 1L:nr
    if (doCdend) {
        if (inherits(Colv, "dendrogram")) 
            ddc <- Colv
        else if (identical(Colv, "Rowv")) {
            if (nr != nc) 
                stop("Colv = \"Rowv\" but nrow(x) != ncol(x)")
            ddc <- ddr
        }
        else {
            hcc <- hclustfun(distfun(if (symm) 
                x
            else t(x)))
            ddc <- as.dendrogram(hcc)
            if (!is.logical(Colv) || Colv) 
                ddc <- reorderfun(ddc, Colv)
        }
        if (nc != length(colInd <- order.dendrogram(ddc))) 
            stop("column dendrogram ordering gave index of wrong length")
    }
    else colInd <- 1L:nc
    x <- x[rowInd, colInd]
    labRow <- if (is.null(labRow)) 
        if (is.null(rownames(x))) 
            (1L:nr)[rowInd]
        else rownames(x)
    else labRow[rowInd]
    labCol <- if (is.null(labCol)) 
        if (is.null(colnames(x))) 
            (1L:nc)[colInd]
        else colnames(x)
    else labCol[colInd]
    if (scale == "row") {
        x <- sweep(x, 1L, rowMeans(x, na.rm = na.rm), check.margin = FALSE)
        sx <- apply(x, 1L, sd, na.rm = na.rm)
        x <- sweep(x, 1L, sx, "/", check.margin = FALSE)
    }
    else if (scale == "column") {
        x <- sweep(x, 2L, colMeans(x, na.rm = na.rm), check.margin = FALSE)
        sx <- apply(x, 2L, sd, na.rm = na.rm)
        x <- sweep(x, 2L, sx, "/", check.margin = FALSE)
    }
    lmat <- rbind(c(NA, 3), 2:1)
    lwid <- c(if (doRdend) 1 else 0.05, 4)
    lhei <- c((if (doCdend) 1 else 0.05) + if (!is.null(main)) 0.2 else 0, 
        4)
    if (!missing(ColSideColors)) {
        if (!is.character(ColSideColors) || length(ColSideColors) != 
            nc) 
            stop("'ColSideColors' must be a character vector of length ncol(x)")
        lmat <- rbind(lmat[1, ] + 1, c(NA, 1), lmat[2, ] + 1)
        lhei <- c(lhei[1L], 0.2, lhei[2L])
    }
    if (!missing(RowSideColors)) {
        if (!is.character(RowSideColors) || length(RowSideColors) != 
            nr) 
            stop("'RowSideColors' must be a character vector of length nrow(x)")
        lmat <- cbind(lmat[, 1] + 1, c(rep(NA, nrow(lmat) - 1), 
            1), lmat[, 2] + 1)
        lwid <- c(lwid[1L], 0.2, lwid[2L])
    }
    lmat[is.na(lmat)] <- 0
    if (verbose) {
        cat("layout: widths = ", lwid, ", heights = ", lhei, 
            "; lmat=\n")
        print(lmat)
    }
    op <- par(no.readonly = TRUE)
    on.exit(par(op))
    layout(lmat, widths = lwid, heights = lhei, respect = TRUE)
    if (!missing(RowSideColors)) {
        par(mar = c(margins[1L], 0, 0, 0.5))
        image(rbind(1L:nr), col = RowSideColors[rowInd], axes = FALSE)
    }
    if (!missing(ColSideColors)) {
        par(mar = c(0.5, 0, 0, margins[2L]))
        image(cbind(1L:nc), col = ColSideColors[colInd], axes = FALSE)
    }
    par(mar = c(margins[1L], 0, 0, margins[2L]))
    if (!symm || scale != "none") 
        x <- t(x)
    if (revC) {
        iy <- nr:1
        if (doRdend) 
            ddr <- rev(ddr)
        x <- x[, iy]
    }
    else iy <- 1L:nr
    image(1L:nc, 1L:nr, x, xlim = 0.5 + c(0, nc), ylim = 0.5 + 
        c(0, nr), axes = FALSE, xlab = "", ylab = "", ...)
    axis(1, 1L:nc, labels = labCol, las = 2, line = -0.5, tick = 0, 
        cex.axis = cexCol)
    if (!is.null(xlab)) 
        mtext(xlab, side = 1, line = margins[1L] - 1.25)
    axis(4, iy, labels = labRow, las = 2, line = -0.5, tick = 0, 
        cex.axis = cexRow)
    if (!is.null(ylab)) 
        mtext(ylab, side = 4, line = margins[2L] - 1.25)
    if (!missing(add.expr)) 
        eval(substitute(add.expr))
    par(mar = c(margins[1L], 0, 0, 0))
    if (doRdend) 
        plot(ddr, horiz = TRUE, axes = FALSE, yaxs = "i", leaflab = "none")
    else frame()
    par(mar = c(0, 0, if (!is.null(main)) 1 else 0, margins[2L]))
    if (doCdend) 
        plot(ddc, axes = FALSE, xaxs = "i", leaflab = "none")
    else if (!is.null(main)) 
        frame()
    if (!is.null(main)) {
        par(xpd = NA)
        title(main, cex.main = 1.5 * op[["cex.main"]])
    }
    invisible(list(rowInd = rowInd, colInd = colInd, Rowv = if (keep.dendro && 
        doRdend) ddr, Colv = if (keep.dendro && doCdend) ddc))
}
<environment: namespace:stats>
> print("identify.hclust"); if(is.function(try(identify.hclust))) {identify.hclust;} else{ NULL};
[1] "identify.hclust"
NULL
> print("influence.measures"); if(is.function(try(influence.measures))) {influence.measures;} else{ NULL};
[1] "influence.measures"
function (model) 
{
    is.influential <- function(infmat, n) {
        k <- ncol(infmat) - 4
        if (n <= k) 
            stop("too few cases, n < k")
        absmat <- abs(infmat)
        result <- cbind(absmat[, 1L:k] > 1, absmat[, k + 1] > 
            3 * sqrt(k/(n - k)), abs(1 - infmat[, k + 2]) > (3 * 
            k)/(n - k), pf(infmat[, k + 3], k, n - k) > 0.5, 
            infmat[, k + 4] > (3 * k)/n)
        dimnames(result) <- dimnames(infmat)
        result
    }
    infl <- influence(model)
    p <- model$rank
    e <- weighted.residuals(model)
    s <- sqrt(sum(e^2, na.rm = TRUE)/df.residual(model))
    mqr <- qr.lm(model)
    xxi <- chol2inv(mqr$qr, mqr$rank)
    si <- infl$sigma
    h <- infl$hat
    dfbetas <- infl$coefficients/outer(infl$sigma, sqrt(diag(xxi)))
    vn <- variable.names(model)
    vn[vn == "(Intercept)"] <- "1_"
    colnames(dfbetas) <- paste("dfb", abbreviate(vn), sep = ".")
    dffits <- e * sqrt(h)/(si * (1 - h))
    if (any(ii <- is.infinite(dffits))) 
        dffits[ii] <- NaN
    cov.ratio <- (si/s)^(2 * p)/(1 - h)
    cooks.d <- if (inherits(model, "glm")) 
        (infl$pear.res/(1 - h))^2 * h/(summary(model)$dispersion * 
            p)
    else ((e/(s * (1 - h)))^2 * h)/p
    infmat <- cbind(dfbetas, dffit = dffits, cov.r = cov.ratio, 
        cook.d = cooks.d, hat = h)
    infmat[is.infinite(infmat)] <- NaN
    is.inf <- is.influential(infmat, sum(h > 0))
    ans <- list(infmat = infmat, is.inf = is.inf, call = model$call)
    class(ans) <- "infl"
    ans
}
<environment: namespace:stats>
> print("integrate"); if(is.function(try(integrate))) {integrate;} else{ NULL};
[1] "integrate"
function (f, lower, upper, ..., subdivisions = 100, rel.tol = .Machine$double.eps^0.25, 
    abs.tol = rel.tol, stop.on.error = TRUE, keep.xy = FALSE, 
    aux = NULL) 
{
    f <- match.fun(f)
    ff <- function(x) f(x, ...)
    limit <- as.integer(subdivisions)
    if (limit < 1 || (abs.tol <= 0 && rel.tol < max(50 * .Machine$double.eps, 
        5e-29))) 
        stop("invalid parameter values")
    if (is.finite(lower) && is.finite(upper)) {
        wk <- .External("call_dqags", ff, rho = environment(), 
            as.double(lower), as.double(upper), as.double(abs.tol), 
            as.double(rel.tol), limit = limit, PACKAGE = "base")
    }
    else {
        if (is.na(lower) || is.na(upper)) 
            stop("a limit is missing")
        if (is.finite(lower)) {
            inf <- 1
            bound <- lower
        }
        else if (is.finite(upper)) {
            inf <- -1
            bound <- upper
        }
        else {
            inf <- 2
            bound <- 0
        }
        wk <- .External("call_dqagi", ff, rho = environment(), 
            as.double(bound), as.integer(inf), as.double(abs.tol), 
            as.double(rel.tol), limit = limit, PACKAGE = "base")
    }
    res <- wk[c("value", "abs.error", "subdivisions")]
    res$message <- switch(wk$ierr + 1, "OK", "maximum number of subdivisions reached", 
        "roundoff error was detected", "extremely bad integrand behaviour", 
        "roundoff error is detected in the extrapolation table", 
        "the integral is probably divergent", "the input is invalid")
    if (wk$ierr == 6 || (wk$ierr > 0 && stop.on.error)) 
        stop(res$message)
    res$call <- match.call()
    class(res) <- "integrate"
    res
}
<environment: namespace:stats>
> print("interaction.plot"); if(is.function(try(interaction.plot))) {interaction.plot;} else{ NULL};
[1] "interaction.plot"
function (x.factor, trace.factor, response, fun = mean, type = c("l", 
    "p", "b"), legend = TRUE, trace.label = deparse(substitute(trace.factor)), 
    fixed = FALSE, xlab = deparse(substitute(x.factor)), ylab = ylabel, 
    ylim = range(cells, na.rm = TRUE), lty = nc:1, col = 1, pch = c(1L:9, 
        0, letters), xpd = NULL, leg.bg = par("bg"), leg.bty = "n", 
    xtick = FALSE, xaxt = par("xaxt"), axes = TRUE, ...) 
{
    ylabel <- paste(deparse(substitute(fun)), "of ", deparse(substitute(response)))
    type <- match.arg(type)
    cells <- tapply(response, list(x.factor, trace.factor), fun)
    nr <- nrow(cells)
    nc <- ncol(cells)
    xvals <- 1L:nr
    if (is.ordered(x.factor)) {
        wn <- getOption("warn")
        options(warn = -1)
        xnm <- as.numeric(levels(x.factor))
        options(warn = wn)
        if (!any(is.na(xnm))) 
            xvals <- xnm
    }
    xlabs <- rownames(cells)
    ylabs <- colnames(cells)
    nch <- max(sapply(ylabs, nchar, type = "width"))
    if (is.null(xlabs)) 
        xlabs <- as.character(xvals)
    if (is.null(ylabs)) 
        ylabs <- as.character(1L:nc)
    xlim <- range(xvals)
    xleg <- xlim[2L] + 0.05 * diff(xlim)
    xlim <- xlim + c(-0.2/nr, if (legend) 0.2 + 0.02 * nch else 0.2/nr) * 
        diff(xlim)
    matplot(xvals, cells, ..., type = type, xlim = xlim, ylim = ylim, 
        xlab = xlab, ylab = ylab, axes = axes, xaxt = "n", col = col, 
        lty = lty, pch = pch)
    if (axes && xaxt != "n") {
        axisInt <- function(x, main, sub, lwd, bg, log, asp, 
            ...) axis(1, x, ...)
        mgp. <- par("mgp")
        if (!xtick) 
            mgp.[2L] <- 0
        axisInt(1, at = xvals, labels = xlabs, tick = xtick, 
            mgp = mgp., xaxt = xaxt, ...)
    }
    if (legend) {
        yrng <- diff(ylim)
        yleg <- ylim[2L] - 0.1 * yrng
        if (!is.null(xpd) || {
            xpd. <- par("xpd")
            !is.na(xpd.) && !xpd. && (xpd <- TRUE)
        }) {
            op <- par(xpd = xpd)
            on.exit(par(op))
        }
        text(xleg, ylim[2L] - 0.05 * yrng, paste("  ", trace.label), 
            adj = 0)
        if (!fixed) {
            ord <- sort.list(cells[nr, ], decreasing = TRUE)
            ylabs <- ylabs[ord]
            lty <- lty[1 + (ord - 1)%%length(lty)]
            col <- col[1 + (ord - 1)%%length(col)]
            pch <- pch[ord]
        }
        legend(xleg, yleg, legend = ylabs, col = col, pch = if (type %in% 
            c("p", "b")) 
            pch, lty = if (type %in% c("l", "b")) 
            lty, bty = leg.bty, bg = leg.bg)
    }
    invisible()
}
<environment: namespace:stats>
> print("is.empty.model"); if(is.function(try(is.empty.model))) {is.empty.model;} else{ NULL};
[1] "is.empty.model"
function (x) 
{
    tt <- terms(x)
    (length(attr(tt, "factors")) == 0L) & (attr(tt, "intercept") == 
        0L)
}
<environment: namespace:stats>
> print("isoreg"); if(is.function(try(isoreg))) {isoreg;} else{ NULL};
[1] "isoreg"
function (x, y = NULL) 
{
    xy <- xy.coords(x, y)
    x <- xy$x
    if (any(is.na(x)) || any(is.na(xy$y))) 
        stop("missing values not allowed")
    isOrd <- ((!is.null(xy$xlab) && xy$xlab == "Index") || !is.unsorted(x, 
        strictly = TRUE))
    if (!isOrd) {
        y <- xy$y
        ord <- order(x, -y)
        y <- y[ord]
    }
    z <- .Call("R_isoreg", if (isOrd) xy$y else y, PACKAGE = "stats")
    structure(c(xy[c("x", "y")], z[c("yf", "yc", "iKnots")], 
        list(isOrd = isOrd, ord = if (!isOrd) ord, call = match.call())), 
        class = "isoreg")
}
<environment: namespace:stats>
> print("kernapply"); if(is.function(try(kernapply))) {kernapply;} else{ NULL};
[1] "kernapply"
function (x, ...) 
{
    UseMethod("kernapply")
}
<environment: namespace:stats>
> print("kernel"); if(is.function(try(kernel))) {kernel;} else{ NULL};
[1] "kernel"
function (coef, m = 2, r, name = "unknown") 
{
    mkName <- function(name, args) paste(name, "(", paste(args, 
        collapse = ","), ")", sep = "")
    modified.daniell.kernel <- function(m) {
        if (length(m) == 1L) 
            k <- kernel(c(rep(1, m), 0.5)/(2 * m), m)
        else {
            k <- Recall(m[1L])
            for (i in 2L:length(m)) k <- kernapply(k, Recall(m[i]))
        }
        attr(k, "name") <- mkName("mDaniell", m)
        k
    }
    daniell.kernel <- function(m) {
        if (length(m) == 1L) 
            k <- kernel(rep(1/(2 * m + 1), m + 1), m)
        else {
            k <- Recall(m[1L])
            for (i in 2L:length(m)) k <- kernapply(k, Recall(m[i]))
        }
        attr(k, "name") <- mkName("Daniell", m)
        k
    }
    fejer.kernel <- function(m, r) {
        if (r < 1L) 
            stop("'r' is less than 1")
        if (m < 1L) 
            stop("'m' is less than 1")
        n <- 2L * m + 1L
        wn <- double(m + 1L)
        wj <- 2 * pi * (1L:m)/n
        wn[2L:(m + 1L)] <- sin(r * wj/2)^2/sin(wj/2)^2/r
        wn[1L] <- r
        wn <- wn/(wn[1L] + 2 * sum(wn[2L:(m + 1L)]))
        kernel(wn, m, name = mkName("Fejer", c(m, r)))
    }
    dirichlet.kernel <- function(m, r) {
        if (r < 0) 
            stop("'r' is less than 0")
        if (m < 1) 
            stop("'m' is less than 1")
        n <- 2L * m + 1L
        wn <- double(m + 1L)
        wj <- 2 * pi * (1L:m)/n
        wn[2L:(m + 1)] <- sin((r + 0.5) * wj)/sin(wj/2)
        wn[1L] <- 2 * r + 1
        wn <- wn/(wn[1L] + 2 * sum(wn[2L:(m + 1L)]))
        kernel(wn, m, name = mkName("Dirichlet", c(m, r)))
    }
    if (!missing(m)) 
        if (!is.numeric(m) || length(m) < 1L || m != round(m) || 
            any(m < 0L)) 
            stop("'m' must be numeric with non-negative integers")
    if (is.character(coef)) {
        switch(coef, daniell = daniell.kernel(m), dirichlet = dirichlet.kernel(m, 
            r), fejer = fejer.kernel(m, r), modified.daniell = modified.daniell.kernel(m), 
            stop("unknown named kernel"))
    }
    else {
        if (!is.numeric(coef)) 
            stop("'coef' must be a vector")
        if (length(coef) < 1L) 
            stop("'coef' does not have the correct length")
        m <- length(coef) - 1L
        kernel <- list(coef = coef, m = m)
        attr(kernel, "name") <- name
        class(kernel) <- "tskernel"
        sk <- sum(kernel[-m:m])
        if (abs(sk - 1) > getOption("ts.eps")) 
            stop("coefficients do not add to 1")
        kernel
    }
}
<environment: namespace:stats>
> print("kmeans"); if(is.function(try(kmeans))) {kmeans;} else{ NULL};
[1] "kmeans"
function (x, centers, iter.max = 10, nstart = 1, algorithm = c("Hartigan-Wong", 
    "Lloyd", "Forgy", "MacQueen")) 
{
    do_one <- function(nmeth) {
        Z <- switch(nmeth, {
            Z <- .Fortran(R_kmns, as.double(x), as.integer(m), 
                as.integer(ncol(x)), centers = as.double(centers), 
                as.integer(k), c1 = integer(m), integer(m), nc = integer(k), 
                double(k), double(k), integer(k), double(m), 
                integer(k), integer(k), as.integer(iter.max), 
                wss = double(k), ifault = 0L)
            switch(Z$ifault, stop("empty cluster: try a better set of initial centers", 
                call. = FALSE), warning(gettextf("did not converge in %d iterations", 
                iter.max), call. = FALSE, domain = NA), stop("number of cluster centres must lie between 1 and nrow(x)", 
                call. = FALSE))
            Z
        }, {
            Z <- .C(R_kmeans_Lloyd, as.double(x), as.integer(m), 
                as.integer(ncol(x)), centers = as.double(centers), 
                as.integer(k), c1 = integer(m), iter = as.integer(iter.max), 
                nc = integer(k), wss = double(k))
            if (Z$iter > iter.max) warning("did not converge in ", 
                iter.max, " iterations", call. = FALSE)
            if (any(Z$nc == 0)) warning("empty cluster: try a better set of initial centers", 
                call. = FALSE)
            Z
        }, {
            Z <- .C(R_kmeans_MacQueen, as.double(x), as.integer(m), 
                as.integer(ncol(x)), centers = as.double(centers), 
                as.integer(k), c1 = integer(m), iter = as.integer(iter.max), 
                nc = integer(k), wss = double(k))
            if (Z$iter > iter.max) warning("did not converge in ", 
                iter.max, " iterations", call. = FALSE)
            if (any(Z$nc == 0)) warning("empty cluster: try a better set of initial centers", 
                call. = FALSE)
            Z
        })
        Z
    }
    x <- as.matrix(x)
    m <- nrow(x)
    if (missing(centers)) 
        stop("'centers' must be a number or a matrix")
    nmeth <- switch(match.arg(algorithm), `Hartigan-Wong` = 1, 
        Lloyd = 2, Forgy = 2, MacQueen = 3)
    if (length(centers) == 1L) {
        if (centers == 1) 
            nmeth <- 3
        k <- centers
        if (nstart == 1) 
            centers <- x[sample.int(m, k), , drop = FALSE]
        if (nstart >= 2 || any(duplicated(centers))) {
            cn <- unique(x)
            mm <- nrow(cn)
            if (mm < k) 
                stop("more cluster centers than distinct data points.")
            centers <- cn[sample.int(mm, k), , drop = FALSE]
        }
    }
    else {
        centers <- as.matrix(centers)
        if (any(duplicated(centers))) 
            stop("initial centers are not distinct")
        cn <- NULL
        k <- nrow(centers)
        if (m < k) 
            stop("more cluster centers than data points")
    }
    if (iter.max < 1) 
        stop("'iter.max' must be positive")
    if (ncol(x) != ncol(centers)) 
        stop("must have same number of columns in 'x' and 'centers'")
    Z <- do_one(nmeth)
    best <- sum(Z$wss)
    if (nstart >= 2 && !is.null(cn)) 
        for (i in 2:nstart) {
            centers <- cn[sample.int(mm, k), , drop = FALSE]
            ZZ <- do_one(nmeth)
            if ((z <- sum(ZZ$wss)) < best) {
                Z <- ZZ
                best <- z
            }
        }
    centers <- matrix(Z$centers, k)
    dimnames(centers) <- list(1L:k, dimnames(x)[[2L]])
    cluster <- Z$c1
    if (!is.null(rn <- rownames(x))) 
        names(cluster) <- rn
    totss <- sum(scale(x, scale = FALSE)^2)
    structure(list(cluster = cluster, centers = centers, totss = totss, 
        withinss = Z$wss, tot.withinss = best, betweenss = totss - 
            best, size = Z$nc), class = "kmeans")
}
<environment: namespace:stats>
> print("kruskal.test"); if(is.function(try(kruskal.test))) {kruskal.test;} else{ NULL};
[1] "kruskal.test"
function (x, ...) 
UseMethod("kruskal.test")
<environment: namespace:stats>
> print("ks.test"); if(is.function(try(ks.test))) {ks.test;} else{ NULL};
[1] "ks.test"
function (x, y, ..., alternative = c("two.sided", "less", "greater"), 
    exact = NULL) 
{
    pkolmogorov1x <- function(x, n) {
        if (x <= 0) 
            return(0)
        if (x >= 1) 
            return(1)
        j <- seq.int(from = 0, to = floor(n * (1 - x)))
        1 - x * sum(exp(lchoose(n, j) + (n - j) * log(1 - x - 
            j/n) + (j - 1) * log(x + j/n)))
    }
    alternative <- match.arg(alternative)
    DNAME <- deparse(substitute(x))
    x <- x[!is.na(x)]
    n <- length(x)
    if (n < 1L) 
        stop("not enough 'x' data")
    PVAL <- NULL
    if (is.numeric(y)) {
        DNAME <- paste(DNAME, "and", deparse(substitute(y)))
        y <- y[!is.na(y)]
        n.x <- as.double(n)
        n.y <- length(y)
        if (n.y < 1L) 
            stop("not enough 'y' data")
        if (is.null(exact)) 
            exact <- (n.x * n.y < 10000)
        METHOD <- "Two-sample Kolmogorov-Smirnov test"
        TIES <- FALSE
        n <- n.x * n.y/(n.x + n.y)
        w <- c(x, y)
        z <- cumsum(ifelse(order(w) <= n.x, 1/n.x, -1/n.y))
        if (length(unique(w)) < (n.x + n.y)) {
            warning("cannot compute correct p-values with ties")
            z <- z[c(which(diff(sort(w)) != 0), n.x + n.y)]
            TIES <- TRUE
        }
        STATISTIC <- switch(alternative, two.sided = max(abs(z)), 
            greater = max(z), less = -min(z))
        nm_alternative <- switch(alternative, two.sided = "two-sided", 
            less = "the CDF of x lies below that of y", greater = "the CDF of x lies above that of y")
        if (exact && (alternative == "two.sided") && !TIES) 
            PVAL <- 1 - .C("psmirnov2x", p = as.double(STATISTIC), 
                as.integer(n.x), as.integer(n.y), PACKAGE = "stats")$p
    }
    else {
        if (is.character(y)) 
            y <- get(y, mode = "function")
        if (mode(y) != "function") 
            stop("'y' must be numeric or a string naming a valid function")
        if (is.null(exact)) 
            exact <- (n < 100)
        METHOD <- "One-sample Kolmogorov-Smirnov test"
        TIES <- FALSE
        if (length(unique(x)) < n) {
            warning("cannot compute correct p-values with ties")
            TIES <- TRUE
        }
        x <- y(sort(x), ...) - (0:(n - 1))/n
        STATISTIC <- switch(alternative, two.sided = max(c(x, 
            1/n - x)), greater = max(1/n - x), less = max(x))
        if (exact && !TIES) {
            PVAL <- if (alternative == "two.sided") 
                1 - .C("pkolmogorov2x", p = as.double(STATISTIC), 
                  as.integer(n), PACKAGE = "stats")$p
            else 1 - pkolmogorov1x(STATISTIC, n)
        }
        nm_alternative <- switch(alternative, two.sided = "two-sided", 
            less = "the CDF of x lies below the null hypothesis", 
            greater = "the CDF of x lies above the null hypothesis")
    }
    names(STATISTIC) <- switch(alternative, two.sided = "D", 
        greater = "D^+", less = "D^-")
    pkstwo <- function(x, tol = 1e-06) {
        if (is.numeric(x)) 
            x <- as.vector(x)
        else stop("argument 'x' must be numeric")
        p <- rep(0, length(x))
        p[is.na(x)] <- NA
        IND <- which(!is.na(x) & (x > 0))
        if (length(IND)) {
            p[IND] <- .C("pkstwo", as.integer(length(x[IND])), 
                p = as.double(x[IND]), as.double(tol), PACKAGE = "stats")$p
        }
        return(p)
    }
    if (is.null(PVAL)) {
        PVAL <- ifelse(alternative == "two.sided", 1 - pkstwo(sqrt(n) * 
            STATISTIC), exp(-2 * n * STATISTIC^2))
    }
    RVAL <- list(statistic = STATISTIC, p.value = PVAL, alternative = nm_alternative, 
        method = METHOD, data.name = DNAME)
    class(RVAL) <- "htest"
    return(RVAL)
}
<environment: namespace:stats>
> print("ksmooth"); if(is.function(try(ksmooth))) {ksmooth;} else{ NULL};
[1] "ksmooth"
function (x, y, kernel = c("box", "normal"), bandwidth = 0.5, 
    range.x = range(x), n.points = max(100, length(x)), x.points) 
{
    if (missing(y) || is.null(y)) 
        stop("numeric y must be supplied.\nFor density estimation use density()")
    kernel <- match.arg(kernel)
    krn <- switch(kernel, box = 1, normal = 2)
    x.points <- if (missing(x.points)) 
        seq.int(range.x[1L], range.x[2L], length.out = n.points)
    else {
        n.points <- length(x.points)
        sort(x.points)
    }
    ord <- order(x)
    z <- .C("BDRksmooth", as.double(x[ord]), as.double(y[ord]), 
        as.integer(length(x)), xp = as.double(x.points), yp = double(n.points), 
        as.integer(n.points), as.integer(krn), as.double(bandwidth), 
        PACKAGE = "stats")
    list(x = z$xp, y = z$yp)
}
<environment: namespace:stats>
> print("lag"); if(is.function(try(lag))) {lag;} else{ NULL};
[1] "lag"
function (x, ...) 
UseMethod("lag")
<environment: namespace:stats>
> print("lag.plot"); if(is.function(try(lag.plot))) {lag.plot;} else{ NULL};
[1] "lag.plot"
function (x, lags = 1, layout = NULL, set.lags = 1L:lags, main = NULL, 
    asp = 1, diag = TRUE, diag.col = "gray", type = "p", oma = NULL, 
    ask = NULL, do.lines = (n <= 150), labels = do.lines, ...) 
{
    lAxis <- function(side, ..., mgp, xpd, panel, Mgp) if (missing(Mgp)) 
        axis(side, ..., xpd = NA)
    else axis(side, ..., xpd = NA, mgp = Mgp)
    xnam <- deparse(substitute(x))
    is.mat <- !is.null(ncol(x))
    nser <- ncol(x <- as.ts(as.matrix(x)))
    n <- nrow(x)
    if (missing(lags) && !missing(set.lags)) 
        lags <- length(set.lags <- as.integer(set.lags))
    tot.lags <- nser * lags
    if (is.null(ask)) {
        if (.Device == "null device") 
            dev.new()
        ask <- if (is.null(layout)) 
            par("ask")
        else (dev.interactive() && prod(layout) < tot.lags)
    }
    if (is.null(layout)) 
        layout <- if (prod(pmf <- par("mfrow")) >= tot.lags) 
            pmf
        else grDevices::n2mfrow(tot.lags)
    mlayout <- any(layout > 1)
    if (mlayout) {
        dots <- list(...)
        cex.main <- dots$cex.main
        if (is.null(cex.main)) 
            cex.main <- par("cex.main")
        if (is.null(oma)) {
            oma <- rep(2, 4)
            if (!is.null(main)) 
                oma[3L] <- oma[3L] + 3 * cex.main
        }
        opar <- par(mfrow = layout, mar = c(1.1, 1.1, 0.5, 0.5) + 
            is.mat * c(0, 0.5, 0, 0.5), oma = oma, ask = ask)
        on.exit(par(opar))
    }
    nR <- layout[1L]
    nC <- layout[2L]
    ii <- jj <- 0
    for (i in 1L:nser) {
        X <- x[, i]
        xl <- range(X)
        nam <- if (is.mat) 
            dimnames(x)[[2L]][i]
        else xnam
        newX <- is.mat
        for (ll in set.lags) {
            jj <- 1 + jj%%nC
            if (jj == 1) 
                ii <- 1 + ii%%nR
            if (mlayout) {
                plot(lag(X, ll), X, xlim = xl, ylim = xl, asp = asp, 
                  xlab = paste("lag", ll), ylab = nam, mgp = if (mlayout) 
                    c(0, 0, 0), axes = FALSE, type = type, xy.lines = do.lines, 
                  xy.labels = labels, col.lab = if (newX) 
                    "red", font.lab = if (newX) 
                    2, ...)
                box(...)
                if (jj == 1 && ii%%2 == 1 && !newX) 
                  lAxis(2, ...)
                if (ii == 1 && jj%%2 == 1) 
                  lAxis(3, ...)
                do.4 <- (ii%%2 == 0 && (jj == nC || (i == nser && 
                  ll == set.lags[lags])))
                if (do.4) 
                  lAxis(4, ...)
                if (jj%%2 == 0 && ii == nR) 
                  lAxis(1, ...)
                if (newX) {
                  newX <- FALSE
                  if (!do.4) 
                    lAxis(4, Mgp = c(0, 0.6, 0), ...)
                }
            }
            else {
                plot(lag(X, ll), X, xlim = xl, ylim = xl, asp = asp, 
                  xlab = paste("lag", ll), ylab = nam, type = type, 
                  xy.lines = do.lines, xy.labels = labels, main = main, 
                  ...)
            }
            if (diag) 
                abline(c(0, 1), lty = 2, col = diag.col)
            if (mlayout && !is.null(main)) {
                font.main <- dots$font.main
                if (is.null(font.main)) 
                  font.main <- par("font.main")
                if ((jj == nC && ii == nR) || ll == set.lags[lags]) 
                  mtext(main, 3, 3, outer = TRUE, at = 0.5, cex = cex.main, 
                    font = font.main)
            }
        }
    }
    invisible(NULL)
}
<environment: namespace:stats>
> print("line"); if(is.function(try(line))) {line;} else{ NULL};
[1] "line"
function (x, y = NULL) 
{
    xy <- xy.coords(x, y)
    ok <- complete.cases(xy$x, xy$y)
    n <- length(ok)
    if (n <= 1) 
        stop("insufficient observations")
    z <- .C("tukeyline", as.double(xy$x[ok]), as.double(xy$y[ok]), 
        double(n), double(n), n, double(2), DUP = FALSE, PACKAGE = "stats")
    value <- list(call = sys.call(), coefficients = z[[6L]], 
        residuals = z[[3L]], fitted.values = z[[4L]])
    class(value) <- "tukeyline"
    value
}
<environment: namespace:stats>
> print("lm"); if(is.function(try(lm))) {lm;} else{ NULL};
[1] "lm"
function (formula, data, subset, weights, na.action, method = "qr", 
    model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, 
    contrasts = NULL, offset, ...) 
{
    ret.x <- x
    ret.y <- y
    cl <- match.call()
    mf <- match.call(expand.dots = FALSE)
    m <- match(c("formula", "data", "subset", "weights", "na.action", 
        "offset"), names(mf), 0L)
    mf <- mf[c(1L, m)]
    mf$drop.unused.levels <- TRUE
    mf[[1L]] <- as.name("model.frame")
    mf <- eval(mf, parent.frame())
    if (method == "model.frame") 
        return(mf)
    else if (method != "qr") 
        warning(gettextf("method = '%s' is not supported. Using 'qr'", 
            method), domain = NA)
    mt <- attr(mf, "terms")
    y <- model.response(mf, "numeric")
    w <- as.vector(model.weights(mf))
    if (!is.null(w) && !is.numeric(w)) 
        stop("'weights' must be a numeric vector")
    offset <- as.vector(model.offset(mf))
    if (!is.null(offset)) {
        if (length(offset) != NROW(y)) 
            stop(gettextf("number of offsets is %d, should equal %d (number of observations)", 
                length(offset), NROW(y)), domain = NA)
    }
    if (is.empty.model(mt)) {
        x <- NULL
        z <- list(coefficients = if (is.matrix(y)) matrix(, 0, 
            3) else numeric(), residuals = y, fitted.values = 0 * 
            y, weights = w, rank = 0L, df.residual = if (!is.null(w)) sum(w != 
            0) else if (is.matrix(y)) nrow(y) else length(y))
        if (!is.null(offset)) {
            z$fitted.values <- offset
            z$residuals <- y - offset
        }
    }
    else {
        x <- model.matrix(mt, mf, contrasts)
        z <- if (is.null(w)) 
            lm.fit(x, y, offset = offset, singular.ok = singular.ok, 
                ...)
        else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok, 
            ...)
    }
    class(z) <- c(if (is.matrix(y)) "mlm", "lm")
    z$na.action <- attr(mf, "na.action")
    z$offset <- offset
    z$contrasts <- attr(x, "contrasts")
    z$xlevels <- .getXlevels(mt, mf)
    z$call <- cl
    z$terms <- mt
    if (model) 
        z$model <- mf
    if (ret.x) 
        z$x <- x
    if (ret.y) 
        z$y <- y
    if (!qr) 
        z$qr <- NULL
    z
}
<environment: namespace:stats>
> print("lm.fit"); if(is.function(try(lm.fit))) {lm.fit;} else{ NULL};
[1] "lm.fit"
function (x, y, offset = NULL, method = "qr", tol = 1e-07, singular.ok = TRUE, 
    ...) 
{
    if (is.null(n <- nrow(x))) 
        stop("'x' must be a matrix")
    if (n == 0L) 
        stop("0 (non-NA) cases")
    p <- ncol(x)
    if (p == 0L) {
        return(list(coefficients = numeric(), residuals = y, 
            fitted.values = 0 * y, rank = 0, df.residual = length(y)))
    }
    ny <- NCOL(y)
    if (is.matrix(y) && ny == 1) 
        y <- drop(y)
    if (!is.null(offset)) 
        y <- y - offset
    if (NROW(y) != n) 
        stop("incompatible dimensions")
    if (method != "qr") 
        warning(gettextf("method = '%s' is not supported. Using 'qr'", 
            method), domain = NA)
    if (length(list(...))) 
        warning("extra arguments ", paste(names(list(...)), sep = ", "), 
            " are just disregarded.")
    storage.mode(x) <- "double"
    storage.mode(y) <- "double"
    z <- .Fortran("dqrls", qr = x, n = n, p = p, y = y, ny = ny, 
        tol = as.double(tol), coefficients = mat.or.vec(p, ny), 
        residuals = y, effects = y, rank = integer(1L), pivot = 1L:p, 
        qraux = double(p), work = double(2 * p), PACKAGE = "base")
    if (!singular.ok && z$rank < p) 
        stop("singular fit encountered")
    coef <- z$coefficients
    pivot <- z$pivot
    r1 <- seq_len(z$rank)
    dn <- colnames(x)
    if (is.null(dn)) 
        dn <- paste("x", 1L:p, sep = "")
    nmeffects <- c(dn[pivot[r1]], rep.int("", n - z$rank))
    r2 <- if (z$rank < p) 
        (z$rank + 1L):p
    else integer()
    if (is.matrix(y)) {
        coef[r2, ] <- NA
        coef[pivot, ] <- coef
        dimnames(coef) <- list(dn, colnames(y))
        dimnames(z$effects) <- list(nmeffects, colnames(y))
    }
    else {
        coef[r2] <- NA
        coef[pivot] <- coef
        names(coef) <- dn
        names(z$effects) <- nmeffects
    }
    z$coefficients <- coef
    r1 <- y - z$residuals
    if (!is.null(offset)) 
        r1 <- r1 + offset
    qr <- z[c("qr", "qraux", "pivot", "tol", "rank")]
    colnames(qr$qr) <- colnames(x)[qr$pivot]
    c(z[c("coefficients", "residuals", "effects", "rank")], list(fitted.values = r1, 
        assign = attr(x, "assign"), qr = structure(qr, class = "qr"), 
        df.residual = n - z$rank))
}
<environment: namespace:stats>
> print("lm.influence"); if(is.function(try(lm.influence))) {lm.influence;} else{ NULL};
[1] "lm.influence"
function (model, do.coef = TRUE) 
{
    wt.res <- weighted.residuals(model)
    e <- na.omit(wt.res)
    if (model$rank == 0) {
        n <- length(wt.res)
        sigma <- sqrt(deviance(model)/df.residual(model))
        res <- list(hat = rep(0, n), coefficients = matrix(0, 
            n, 0), sigma = rep(sigma, n), wt.res = e)
    }
    else {
        e[abs(e) < 100 * .Machine$double.eps * median(abs(e))] <- 0
        mqr <- qr.lm(model)
        n <- as.integer(nrow(mqr$qr))
        k <- as.integer(mqr$rank)
        if (NROW(e) != n) 
            stop("non-NA residual length does not match cases used in fitting")
        do.coef <- as.logical(do.coef)
        res <- .Fortran("lminfl", mqr$qr, n, n, k, as.integer(do.coef), 
            mqr$qraux, wt.res = e, hat = double(n), coefficients = if (do.coef) matrix(0, 
                n, k) else double(), sigma = double(n), tol = 10 * 
                .Machine$double.eps, DUP = FALSE, PACKAGE = "stats")[c("hat", 
            "coefficients", "sigma", "wt.res")]
        if (!is.null(model$na.action)) {
            hat <- naresid(model$na.action, res$hat)
            hat[is.na(hat)] <- 0
            res$hat <- hat
            if (do.coef) {
                coefficients <- naresid(model$na.action, res$coefficients)
                coefficients[is.na(coefficients)] <- 0
                res$coefficients <- coefficients
            }
            sigma <- naresid(model$na.action, res$sigma)
            sigma[is.na(sigma)] <- sqrt(deviance(model)/df.residual(model))
            res$sigma <- sigma
        }
    }
    res$wt.res <- naresid(model$na.action, res$wt.res)
    res$hat[res$hat > 1 - 10 * .Machine$double.eps] <- 1
    names(res$hat) <- names(res$sigma) <- names(res$wt.res)
    if (!do.coef) 
        res$coefficients <- NULL
    else {
        rownames(res$coefficients) <- names(res$wt.res)
        colnames(res$coefficients) <- names(coef(model))[!is.na(coef(model))]
    }
    res
}
<environment: namespace:stats>
> print("loadings"); if(is.function(try(loadings))) {loadings;} else{ NULL};
[1] "loadings"
function (x) 
x$loadings
<environment: namespace:stats>
> print("loess"); if(is.function(try(loess))) {loess;} else{ NULL};
[1] "loess"
function (formula, data, weights, subset, na.action, model = FALSE, 
    span = 0.75, enp.target, degree = 2, parametric = FALSE, 
    drop.square = FALSE, normalize = TRUE, family = c("gaussian", 
        "symmetric"), method = c("loess", "model.frame"), control = loess.control(...), 
    ...) 
{
    family <- match.arg(family)
    method <- match.arg(method)
    mf <- match.call(expand.dots = FALSE)
    mf$model <- mf$span <- mf$enp.target <- mf$degree <- mf$parametric <- mf$drop.square <- mf$normalize <- mf$family <- mf$method <- mf$control <- mf$... <- NULL
    mf[[1L]] <- as.name("model.frame")
    mf <- eval(mf, parent.frame())
    if (match.arg(method) == "model.frame") 
        return(mf)
    mt <- attr(mf, "terms")
    y <- model.response(mf, "numeric")
    w <- model.weights(mf)
    if (is.null(w)) 
        w <- rep(1, length(y))
    nmx <- as.character(attr(mt, "variables"))[-(1L:2)]
    x <- mf[, nmx, drop = FALSE]
    if (any(sapply(x, is.factor))) 
        stop("predictors must all be numeric")
    x <- as.matrix(x)
    D <- ncol(x)
    nmx <- colnames(x)
    names(nmx) <- nmx
    drop.square <- match(nmx, nmx[drop.square], 0L) > 0L
    parametric <- match(nmx, nmx[parametric], 0L) > 0L
    if (!match(degree, 0L:2L, 0L)) 
        stop("'degree' must be 0, 1 or 2")
    iterations <- if (family == "gaussian") 
        1
    else control$iterations
    if (!missing(enp.target)) 
        if (!missing(span)) 
            warning("both 'span' and 'enp.target' specified: 'span' will be used")
        else {
            tau <- switch(degree + 1, 1, D + 1, (D + 1) * (D + 
                2)/2) - sum(drop.square)
            span <- 1.2 * tau/enp.target
        }
    if (!is.list(control) || !is.character(control$surface) || 
        !is.character(control$statistics) || !is.character(control$trace.hat) || 
        !is.numeric(control$cell) || !is.numeric(iterations)) 
        stop("invalid 'control' argument")
    fit <- simpleLoess(y, x, w, span, degree, parametric, drop.square, 
        normalize, control$statistics, control$surface, control$cell, 
        iterations, control$trace.hat)
    fit$call <- match.call()
    fit$terms <- mt
    fit$xnames <- nmx
    fit$x <- x
    fit$y <- y
    fit$weights <- w
    if (model) 
        fit$model <- mf
    fit$na.action <- attr(mf, "na.action")
    fit
}
<environment: namespace:stats>
> print("loess.control"); if(is.function(try(loess.control))) {loess.control;} else{ NULL};
[1] "loess.control"
function (surface = c("interpolate", "direct"), statistics = c("approximate", 
    "exact"), trace.hat = c("exact", "approximate"), cell = 0.2, 
    iterations = 4, ...) 
{
    list(surface = match.arg(surface), statistics = match.arg(statistics), 
        trace.hat = match.arg(trace.hat), cell = cell, iterations = iterations)
}
<environment: namespace:stats>
> print("logLik"); if(is.function(try(logLik))) {logLik;} else{ NULL};
[1] "logLik"
function (object, ...) 
UseMethod("logLik")
<environment: namespace:stats>
> print("loglin"); if(is.function(try(loglin))) {loglin;} else{ NULL};
[1] "loglin"
function (table, margin, start = rep(1, length(table)), fit = FALSE, 
    eps = 0.1, iter = 20, param = FALSE, print = TRUE) 
{
    rfit <- fit
    dtab <- dim(table)
    nvar <- length(dtab)
    ncon <- length(margin)
    conf <- matrix(0, nrow = nvar, ncol = ncon)
    nmar <- 0
    varnames <- names(dimnames(table))
    for (k in seq_along(margin)) {
        tmp <- margin[[k]]
        if (is.character(tmp)) {
            tmp <- match(tmp, varnames)
            margin[[k]] <- tmp
        }
        conf[seq_along(tmp), k] <- tmp
        nmar <- nmar + prod(dtab[tmp])
    }
    ntab <- length(table)
    if (length(start) != ntab) 
        stop("'start' and 'table' must be same length")
    storage.mode(conf) <- "integer"
    z <- .C("loglin", as.integer(nvar), as.integer(dtab), as.integer(ncon), 
        conf, as.integer(ntab), as.double(table), fit = as.double(start), 
        locmar = integer(ncon), as.integer(nmar), marginals = double(nmar), 
        as.integer(ntab), u = double(ntab), as.double(eps), as.integer(iter), 
        dev = double(iter), nlast = integer(1L), ifault = integer(1L), 
        PACKAGE = "stats")
    switch(z$ifault, stop("this should not happen"), stop("this should not happen"), 
        warning("algorithm did not converge"), stop("incorrect specification of 'table' or 'start'"))
    if (print) 
        cat(z$nlast, "iterations: deviation", z$dev[z$nlast], 
            "\n")
    fit <- z$fit
    attributes(fit) <- attributes(table)
    observed <- as.vector(table[start > 0])
    expected <- as.vector(fit[start > 0])
    pearson <- sum((observed - expected)^2/expected)
    observed <- as.vector(table[table * fit > 0])
    expected <- as.vector(fit[table * fit > 0])
    lrt <- 2 * sum(observed * log(observed/expected))
    subsets <- function(x) {
        y <- list(vector(mode(x), length = 0))
        for (i in seq_along(x)) {
            y <- c(y, lapply(y, "c", x[i]))
        }
        y[-1L]
    }
    df <- rep.int(0, 2^nvar)
    for (k in seq_along(margin)) {
        terms <- subsets(margin[[k]])
        for (j in seq_along(terms)) df[sum(2^(terms[[j]] - 1))] <- prod(dtab[terms[[j]]] - 
            1)
    }
    if (!is.null(varnames) && all(nzchar(varnames))) {
        for (k in seq_along(margin)) margin[[k]] <- varnames[margin[[k]]]
    }
    else {
        varnames <- as.character(1:ntab)
    }
    y <- list(lrt = lrt, pearson = pearson, df = ntab - sum(df) - 
        1, margin = margin)
    if (rfit) 
        y$fit <- fit
    if (param) {
        fit <- log(fit)
        terms <- seq_along(df)[df > 0]
        parlen <- length(terms) + 1
        parval <- list(parlen)
        parnam <- character(parlen)
        parval[[1L]] <- mean(fit)
        parnam[1L] <- "(Intercept)"
        fit <- fit - parval[[1L]]
        dyadic <- NULL
        while (any(terms > 0)) {
            dyadic <- cbind(dyadic, terms%%2)
            terms <- terms%/%2
        }
        dyadic <- dyadic[order(rowSums(dyadic)), ]
        for (i in 2:parlen) {
            vars <- which(dyadic[i - 1, ] > 0)
            parval[[i]] <- apply(fit, vars, mean)
            parnam[i] <- paste(varnames[vars], collapse = ".")
            fit <- sweep(fit, vars, parval[[i]], check.margin = FALSE)
        }
        names(parval) <- parnam
        y$param <- parval
    }
    return(y)
}
<environment: namespace:stats>
> print("lowess"); if(is.function(try(lowess))) {lowess;} else{ NULL};
[1] "lowess"
function (x, y = NULL, f = 2/3, iter = 3, delta = 0.01 * diff(range(xy$x[o]))) 
{
    xy <- xy.coords(x, y)
    n <- as.integer(length(xy$x))
    if (n == 0) 
        stop("'x' is empty")
    o <- order(xy$x)
    .C("lowess", x = as.double(xy$x[o]), as.double(xy$y[o]), 
        n, as.double(f), as.integer(iter), as.double(delta), 
        y = double(n), double(n), double(n), PACKAGE = "stats")[c("x", 
        "y")]
}
<environment: namespace:stats>
> print("ls.diag"); if(is.function(try(ls.diag))) {ls.diag;} else{ NULL};
[1] "ls.diag"
function (ls.out) 
{
    resids <- as.matrix(ls.out$residuals)
    d0 <- dim(resids)
    xnames <- colnames(ls.out$qr$qr)
    yname <- colnames(resids)
    good <- complete.cases(resids, ls.out$wt)
    if (any(!good)) {
        warning("missing observations deleted")
        resids <- resids[good, , drop = FALSE]
    }
    if (!is.null(ls.out$wt)) {
        if (any(ls.out$wt[good] == 0)) 
            warning("observations with 0 weight not used in calculating standard deviation")
        resids <- resids * ls.out$wt[good]^0.5
    }
    p <- ls.out$qr$rank
    n <- nrow(resids)
    hatdiag <- rep.int(NA, n)
    stats <- array(NA, dim = d0)
    colnames(stats) <- yname
    stdres <- studres <- dfits <- Cooks <- stats
    q <- qr.qy(ls.out$qr, rbind(diag(p), matrix(0, nrow = n - 
        p, ncol = p)))
    hatdiag[good] <- rowSums(as.matrix(q^2))
    stddev <- (colSums(as.matrix(resids^2))/(n - p))^0.5
    stddevmat <- matrix(stddev, nrow = sum(good), ncol = ncol(resids), 
        byrow = TRUE)
    stdres[good, ] <- resids/((1 - hatdiag[good])^0.5 * stddevmat)
    studres[good, ] <- (stdres[good, ] * stddevmat)/(((n - p) * 
        stddevmat^2 - resids^2/(1 - hatdiag[good]))/(n - p - 
        1))^0.5
    dfits[good, ] <- (hatdiag[good]/(1 - hatdiag[good]))^0.5 * 
        studres[good, ]
    Cooks[good, ] <- ((stdres[good, ]^2 * hatdiag[good])/p)/(1 - 
        hatdiag[good])
    if (ncol(resids) == 1 && is.null(yname)) {
        stdres <- as.vector(stdres)
        Cooks <- as.vector(Cooks)
        studres <- as.vector(studres)
        dfits <- as.vector(dfits)
    }
    qr <- as.matrix(ls.out$qr$qr[1L:p, 1L:p])
    qr[row(qr) > col(qr)] <- 0
    qrinv <- solve(qr)
    covmat.unscaled <- qrinv %*% t(qrinv)
    dimnames(covmat.unscaled) <- list(xnames, xnames)
    covmat.scaled <- sum(stddev^2) * covmat.unscaled
    cormat <- covmat.scaled/(outer(diag(covmat.scaled), diag(covmat.scaled))^0.5)
    stderr <- outer(diag(covmat.unscaled)^0.5, stddev)
    dimnames(stderr) <- list(xnames, yname)
    return(list(std.dev = stddev, hat = hatdiag, std.res = stdres, 
        stud.res = studres, cooks = Cooks, dfits = dfits, correlation = cormat, 
        std.err = stderr, cov.scaled = covmat.scaled, cov.unscaled = covmat.unscaled))
}
<environment: namespace:stats>
> print("ls.print"); if(is.function(try(ls.print))) {ls.print;} else{ NULL};
[1] "ls.print"
function (ls.out, digits = 4, print.it = TRUE) 
{
    resids <- as.matrix(ls.out$residuals)
    if (!is.null(ls.out$wt)) {
        if (any(ls.out$wt == 0)) 
            warning("observations with 0 weights not used")
        resids <- resids * ls.out$wt^0.5
    }
    n <- apply(resids, 2L, length) - colSums(is.na(resids))
    lsqr <- ls.out$qr
    p <- lsqr$rank
    if (ls.out$intercept) {
        if (is.matrix(lsqr$qt)) 
            totss <- colSums(lsqr$qt[-1, ]^2)
        else totss <- sum(lsqr$qt[-1L]^2)
        degfree <- p - 1
    }
    else {
        totss <- colSums(as.matrix(lsqr$qt^2))
        degfree <- p
    }
    resss <- colSums(resids^2, na.rm = TRUE)
    resse <- (resss/(n - p))^0.5
    regss <- totss - resss
    rsquared <- regss/totss
    fstat <- (regss/degfree)/(resss/(n - p))
    pvalue <- pf(fstat, degfree, (n - p), lower.tail = FALSE)
    Ynames <- colnames(resids)
    summary <- cbind(format(round(resse, digits)), format(round(rsquared, 
        digits)), format(round(fstat, digits)), format(degfree), 
        format(n - p), format(round(pvalue, digits)))
    dimnames(summary) <- list(Ynames, c("Mean Sum Sq", "R Squared", 
        "F-value", "Df 1", "Df 2", "Pr(>F)"))
    mat <- as.matrix(lsqr$qr[1L:p, 1L:p])
    mat[row(mat) > col(mat)] <- 0
    qrinv <- solve(mat)
    m.y <- ncol(resids)
    coef.table <- as.list(1L:m.y)
    if (m.y == 1) 
        coef <- matrix(ls.out$coefficients, ncol = 1)
    else coef <- ls.out$coefficients
    for (i in 1L:m.y) {
        covmat <- (resss[i]/(n[i] - p)) * (qrinv %*% t(qrinv))
        se <- diag(covmat)^0.5
        coef.table[[i]] <- cbind(coef[, i], se, coef[, i]/se, 
            2 * pt(abs(coef[, i]/se), n[i] - p, lower.tail = FALSE))
        dimnames(coef.table[[i]]) <- list(colnames(lsqr$qr), 
            c("Estimate", "Std.Err", "t-value", "Pr(>|t|)"))
        if (print.it) {
            if (m.y > 1) 
                cat("Response:", Ynames[i], "\n\n")
            cat(paste("Residual Standard Error=", format(round(resse[i], 
                digits)), "\nR-Square=", format(round(rsquared[i], 
                digits)), "\nF-statistic (df=", format(degfree), 
                ", ", format(n[i] - p), ")=", format(round(fstat[i], 
                  digits)), "\np-value=", format(round(pvalue[i], 
                  digits)), "\n\n", sep = ""))
            print(round(coef.table[[i]], digits))
            cat("\n\n")
        }
    }
    names(coef.table) <- Ynames
    invisible(list(summary = summary, coef.table = coef.table))
}
<environment: namespace:stats>
> print("lsfit"); if(is.function(try(lsfit))) {lsfit;} else{ NULL};
[1] "lsfit"
function (x, y, wt = NULL, intercept = TRUE, tolerance = 1e-07, 
    yname = NULL) 
{
    x <- as.matrix(x)
    y <- as.matrix(y)
    xnames <- colnames(x)
    if (is.null(xnames)) {
        if (ncol(x) == 1) 
            xnames <- "X"
        else xnames <- paste("X", 1L:ncol(x), sep = "")
    }
    if (intercept) {
        x <- cbind(1, x)
        xnames <- c("Intercept", xnames)
    }
    if (is.null(yname) && ncol(y) > 1) 
        yname <- paste("Y", 1L:ncol(y), sep = "")
    good <- complete.cases(x, y, wt)
    dimy <- dim(as.matrix(y))
    if (any(!good)) {
        warning(gettextf("%d missing values deleted", sum(!good)), 
            domain = NA)
        x <- as.matrix(x)[good, ]
        y <- as.matrix(y)[good, ]
        wt <- wt[good]
    }
    nrx <- NROW(x)
    ncx <- NCOL(x)
    nry <- NROW(y)
    ncy <- NCOL(y)
    nwts <- length(wt)
    if (nry != nrx) 
        stop(gettextf("'X' matrix has %d responses, 'Y' has %d responses", 
            nrx, nry), domain = NA)
    if (nry < ncx) 
        stop(gettextf("%d responses, but only %d variables", 
            nry, ncx), domain = NA)
    if (!is.null(wt)) {
        if (any(wt < 0)) 
            stop("negative weights not allowed")
        if (nwts != nry) 
            stop(gettextf("number of weights = %d should equal %d (number of responses)", 
                nwts, nry), domain = NA)
        wtmult <- wt^0.5
        if (any(wt == 0)) {
            xzero <- as.matrix(x)[wt == 0, ]
            yzero <- as.matrix(y)[wt == 0, ]
        }
        x <- x * wtmult
        y <- y * wtmult
        invmult <- 1/ifelse(wt == 0, 1, wtmult)
    }
    storage.mode(x) <- "double"
    storage.mode(y) <- "double"
    z <- .Fortran("dqrls", qr = x, n = nrx, p = ncx, y = y, ny = ncy, 
        tol = tolerance, coefficients = mat.or.vec(ncx, ncy), 
        residuals = mat.or.vec(nrx, ncy), effects = mat.or.vec(nrx, 
            ncy), rank = integer(1L), pivot = as.integer(1L:ncx), 
        qraux = double(ncx), work = double(2 * ncx), PACKAGE = "base")
    resids <- array(NA, dim = dimy)
    dim(z$residuals) <- c(nry, ncy)
    if (!is.null(wt)) {
        if (any(wt == 0)) {
            if (ncx == 1) 
                fitted.zeros <- xzero * z$coefficients
            else fitted.zeros <- xzero %*% z$coefficients
            z$residuals[wt == 0, ] <- yzero - fitted.zeros
        }
        z$residuals <- z$residuals * invmult
    }
    resids[good, ] <- z$residuals
    if (dimy[2L] == 1 && is.null(yname)) {
        resids <- as.vector(resids)
        names(z$coefficients) <- xnames
    }
    else {
        colnames(resids) <- yname
        colnames(z$effects) <- yname
        dim(z$coefficients) <- c(ncx, ncy)
        dimnames(z$coefficients) <- list(xnames, yname)
    }
    z$qr <- as.matrix(z$qr)
    colnames(z$qr) <- xnames
    output <- list(coefficients = z$coefficients, residuals = resids)
    if (z$rank != ncx) {
        xnames <- xnames[z$pivot]
        dimnames(z$qr) <- list(NULL, xnames)
        warning("'X' matrix was collinear")
    }
    if (!is.null(wt)) {
        weights <- rep.int(NA, dimy[1L])
        weights[good] <- wt
        output <- c(output, list(wt = weights))
    }
    rqr <- list(qt = z$effects, qr = z$qr, qraux = z$qraux, rank = z$rank, 
        pivot = z$pivot, tol = z$tol)
    oldClass(rqr) <- "qr"
    output <- c(output, list(intercept = intercept, qr = rqr))
    return(output)
}
<environment: namespace:stats>
> print("mad"); if(is.function(try(mad))) {mad;} else{ NULL};
[1] "mad"
function (x, center = median(x), constant = 1.4826, na.rm = FALSE, 
    low = FALSE, high = FALSE) 
{
    if (na.rm) 
        x <- x[!is.na(x)]
    n <- length(x)
    constant * if ((low || high) && n%%2 == 0) {
        if (low && high) 
            stop("'low' and 'high' cannot be both TRUE")
        n2 <- n%/%2 + as.integer(high)
        sort(abs(x - center), partial = n2)[n2]
    }
    else median(abs(x - center))
}
<environment: namespace:stats>
> print("mahalanobis"); if(is.function(try(mahalanobis))) {mahalanobis;} else{ NULL};
[1] "mahalanobis"
function (x, center, cov, inverted = FALSE, ...) 
{
    x <- if (is.vector(x)) 
        matrix(x, ncol = length(x))
    else as.matrix(x)
    x <- sweep(x, 2, center)
    if (!inverted) 
        cov <- solve(cov, ...)
    retval <- rowSums((x %*% cov) * x)
    names(retval) <- rownames(x)
    retval
}
<environment: namespace:stats>
> print("make.link"); if(is.function(try(make.link))) {make.link;} else{ NULL};
[1] "make.link"
function (link) 
{
    switch(link, logit = {
        linkfun <- function(mu) .Call("logit_link", mu, PACKAGE = "stats")
        linkinv <- function(eta) .Call("logit_linkinv", eta, 
            PACKAGE = "stats")
        mu.eta <- function(eta) .Call("logit_mu_eta", eta, PACKAGE = "stats")
        valideta <- function(eta) TRUE
    }, probit = {
        linkfun <- function(mu) qnorm(mu)
        linkinv <- function(eta) {
            thresh <- -qnorm(.Machine$double.eps)
            eta <- pmin(pmax(eta, -thresh), thresh)
            pnorm(eta)
        }
        mu.eta <- function(eta) pmax(dnorm(eta), .Machine$double.eps)
        valideta <- function(eta) TRUE
    }, cauchit = {
        linkfun <- function(mu) qcauchy(mu)
        linkinv <- function(eta) {
            thresh <- -qcauchy(.Machine$double.eps)
            eta <- pmin(pmax(eta, -thresh), thresh)
            pcauchy(eta)
        }
        mu.eta <- function(eta) pmax(dcauchy(eta), .Machine$double.eps)
        valideta <- function(eta) TRUE
    }, cloglog = {
        linkfun <- function(mu) log(-log(1 - mu))
        linkinv <- function(eta) pmax(pmin(-expm1(-exp(eta)), 
            1 - .Machine$double.eps), .Machine$double.eps)
        mu.eta <- function(eta) {
            eta <- pmin(eta, 700)
            pmax(exp(eta) * exp(-exp(eta)), .Machine$double.eps)
        }
        valideta <- function(eta) TRUE
    }, identity = {
        linkfun <- function(mu) mu
        linkinv <- function(eta) eta
        mu.eta <- function(eta) rep.int(1, length(eta))
        valideta <- function(eta) TRUE
    }, log = {
        linkfun <- function(mu) log(mu)
        linkinv <- function(eta) pmax(exp(eta), .Machine$double.eps)
        mu.eta <- function(eta) pmax(exp(eta), .Machine$double.eps)
        valideta <- function(eta) TRUE
    }, sqrt = {
        linkfun <- function(mu) sqrt(mu)
        linkinv <- function(eta) eta^2
        mu.eta <- function(eta) 2 * eta
        valideta <- function(eta) all(eta > 0)
    }, `1/mu^2` = {
        linkfun <- function(mu) 1/mu^2
        linkinv <- function(eta) 1/sqrt(eta)
        mu.eta <- function(eta) -1/(2 * eta^1.5)
        valideta <- function(eta) all(eta > 0)
    }, inverse = {
        linkfun <- function(mu) 1/mu
        linkinv <- function(eta) 1/eta
        mu.eta <- function(eta) -1/(eta^2)
        valideta <- function(eta) all(eta != 0)
    }, stop(sQuote(link), " link not recognised"))
    structure(list(linkfun = linkfun, linkinv = linkinv, mu.eta = mu.eta, 
        valideta = valideta, name = link), class = "link-glm")
}
<environment: namespace:stats>
> print("makepredictcall"); if(is.function(try(makepredictcall))) {makepredictcall;} else{ NULL};
[1] "makepredictcall"
function (var, call) 
UseMethod("makepredictcall")
<environment: namespace:stats>
> print("manova"); if(is.function(try(manova))) {manova;} else{ NULL};
[1] "manova"
function (...) 
{
    Call <- fcall <- match.call()
    fcall[[1L]] <- as.name("aov")
    result <- eval(fcall, parent.frame())
    if (inherits(result, "aovlist")) {
        for (i in seq_along(result)) {
            if (!inherits(result[[i]], "maov")) 
                stop("need multiple response")
            class(result[[i]]) <- c("manova", oldClass(result[[i]]))
        }
        attr(result, "call") <- Call
    }
    else {
        if (!inherits(result, "maov")) 
            stop("need multiple response")
        class(result) <- c("manova", oldClass(result))
        result$call <- Call
    }
    result
}
<environment: namespace:stats>
> print("mantelhaen.test"); if(is.function(try(mantelhaen.test))) {mantelhaen.test;} else{ NULL};
[1] "mantelhaen.test"
function (x, y = NULL, z = NULL, alternative = c("two.sided", 
    "less", "greater"), correct = TRUE, exact = FALSE, conf.level = 0.95) 
{
    DNAME <- deparse(substitute(x))
    if (is.array(x)) {
        if (length(dim(x)) == 3L) {
            if (any(is.na(x))) 
                stop("NAs are not allowed")
            if (any(dim(x) < 2L)) 
                stop("each dimension in table must be >= 2")
        }
        else stop("'x' must be a 3-dimensional array")
    }
    else {
        if (is.null(y)) 
            stop("if 'x' is not an array, 'y' must be given")
        if (is.null(z)) 
            stop("if 'x' is not an array, 'z' must be given")
        if (any(diff(c(length(x), length(y), length(z))) != 0L)) 
            stop("'x', 'y', and 'z' must have the same length")
        DNAME <- paste(DNAME, "and", deparse(substitute(y)), 
            "and", deparse(substitute(z)))
        OK <- complete.cases(x, y, z)
        x <- factor(x[OK])
        y <- factor(y[OK])
        if ((nlevels(x) < 2L) || (nlevels(y) < 2L)) 
            stop("'x' and 'y' must have at least 2 levels")
        else x <- table(x, y, z[OK])
    }
    if (any(apply(x, 3L, sum) < 2)) 
        stop("sample size in each stratum must be > 1")
    I <- dim(x)[1L]
    J <- dim(x)[2L]
    K <- dim(x)[3L]
    if ((I == 2) && (J == 2)) {
        alternative <- match.arg(alternative)
        if (!missing(conf.level) && (length(conf.level) != 1 || 
            !is.finite(conf.level) || conf.level < 0 || conf.level > 
            1)) 
            stop("'conf.level' must be a single number between 0 and 1")
        NVAL <- 1
        names(NVAL) <- "common odds ratio"
        if (!exact) {
            s.x <- apply(x, c(1L, 3L), sum)
            s.y <- apply(x, c(2L, 3L), sum)
            n <- as.double(apply(x, 3L, sum))
            DELTA <- sum(x[1, 1, ] - s.x[1, ] * s.y[1, ]/n)
            YATES <- ifelse(correct && (abs(DELTA) >= 0.5), 0.5, 
                0)
            STATISTIC <- ((abs(DELTA) - YATES)^2/sum(apply(rbind(s.x, 
                s.y), 2L, prod)/(n^2 * (n - 1))))
            PARAMETER <- 1
            if (alternative == "two.sided") 
                PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
            else {
                z <- sign(DELTA) * sqrt(STATISTIC)
                PVAL <- pnorm(z, lower.tail = (alternative == 
                  "less"))
            }
            names(STATISTIC) <- "Mantel-Haenszel X-squared"
            names(PARAMETER) <- "df"
            METHOD <- paste("Mantel-Haenszel chi-squared test", 
                ifelse(YATES, "with", "without"), "continuity correction")
            s.diag <- sum(x[1, 1, ] * x[2, 2, ]/n)
            s.offd <- sum(x[1, 2, ] * x[2, 1, ]/n)
            ESTIMATE <- s.diag/s.offd
            sd <- sqrt(sum((x[1, 1, ] + x[2, 2, ]) * x[1, 1, 
                ] * x[2, 2, ]/n^2)/(2 * s.diag^2) + sum(((x[1, 
                1, ] + x[2, 2, ]) * x[1, 2, ] * x[2, 1, ] + (x[1, 
                2, ] + x[2, 1, ]) * x[1, 1, ] * x[2, 2, ])/n^2)/(2 * 
                s.diag * s.offd) + sum((x[1, 2, ] + x[2, 1, ]) * 
                x[1, 2, ] * x[2, 1, ]/n^2)/(2 * s.offd^2))
            CINT <- switch(alternative, less = c(0, ESTIMATE * 
                exp(qnorm(conf.level) * sd)), greater = c(ESTIMATE * 
                exp(qnorm(conf.level, lower.tail = FALSE) * sd), 
                Inf), two.sided = {
                ESTIMATE * exp(c(1, -1) * qnorm((1 - conf.level)/2) * 
                  sd)
            })
            RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, 
                p.value = PVAL)
        }
        else {
            METHOD <- paste("Exact conditional test of independence", 
                "in 2 x 2 x k tables")
            m <- apply(x, c(2L, 3L), sum)[1, ]
            n <- apply(x, c(2L, 3L), sum)[2, ]
            t <- apply(x, c(1L, 3L), sum)[1, ]
            s <- sum(x[1, 1, ])
            lo <- sum(pmax(0, t - n))
            hi <- sum(pmin(m, t))
            support <- lo:hi
            dc <- .C(R_d2x2xk, as.integer(K), as.double(m), as.double(n), 
                as.double(t), d = double(hi - lo + 1))$d
            logdc <- log(dc)
            dn2x2xk <- function(ncp) {
                if (ncp == 1) 
                  return(dc)
                d <- logdc + log(ncp) * support
                d <- exp(d - max(d))
                d/sum(d)
            }
            mn2x2xk <- function(ncp) {
                if (ncp == 0) 
                  return(lo)
                if (ncp == Inf) 
                  return(hi)
                sum(support * dn2x2xk(ncp))
            }
            pn2x2xk <- function(q, ncp = 1, upper.tail = FALSE) {
                if (ncp == 0) {
                  if (upper.tail) 
                    return(as.numeric(q <= lo))
                  else return(as.numeric(q >= lo))
                }
                if (ncp == Inf) {
                  if (upper.tail) 
                    return(as.numeric(q <= hi))
                  else return(as.numeric(q >= hi))
                }
                d <- dn2x2xk(ncp)
                if (upper.tail) 
                  sum(d[support >= q])
                else sum(d[support <= q])
            }
            PVAL <- switch(alternative, less = pn2x2xk(s, 1), 
                greater = pn2x2xk(s, 1, upper.tail = TRUE), two.sided = {
                  relErr <- 1 + 10^(-7)
                  d <- dc
                  sum(d[d <= d[s - lo + 1] * relErr])
                })
            mle <- function(x) {
                if (x == lo) 
                  return(0)
                if (x == hi) 
                  return(Inf)
                mu <- mn2x2xk(1)
                if (mu > x) 
                  uniroot(function(t) mn2x2xk(t) - x, c(0, 1))$root
                else if (mu < x) 
                  1/uniroot(function(t) mn2x2xk(1/t) - x, c(.Machine$double.eps, 
                    1))$root
                else 1
            }
            ESTIMATE <- mle(s)
            ncp.U <- function(x, alpha) {
                if (x == hi) 
                  return(Inf)
                p <- pn2x2xk(x, 1)
                if (p < alpha) 
                  uniroot(function(t) pn2x2xk(x, t) - alpha, 
                    c(0, 1))$root
                else if (p > alpha) 
                  1/uniroot(function(t) pn2x2xk(x, 1/t) - alpha, 
                    c(.Machine$double.eps, 1))$root
                else 1
            }
            ncp.L <- function(x, alpha) {
                if (x == lo) 
                  return(0)
                p <- pn2x2xk(x, 1, upper.tail = TRUE)
                if (p > alpha) 
                  uniroot(function(t) pn2x2xk(x, t, upper.tail = TRUE) - 
                    alpha, c(0, 1))$root
                else if (p < alpha) 
                  1/uniroot(function(t) pn2x2xk(x, 1/t, upper.tail = TRUE) - 
                    alpha, c(.Machine$double.eps, 1))$root
                else 1
            }
            CINT <- switch(alternative, less = c(0, ncp.U(s, 
                1 - conf.level)), greater = c(ncp.L(s, 1 - conf.level), 
                Inf), two.sided = {
                alpha <- (1 - conf.level)/2
                c(ncp.L(s, alpha), ncp.U(s, alpha))
            })
            STATISTIC <- s
            names(STATISTIC) <- "S"
            RVAL <- list(statistic = STATISTIC, p.value = PVAL)
        }
        names(ESTIMATE) <- names(NVAL)
        attr(CINT, "conf.level") <- conf.level
        RVAL <- c(RVAL, list(conf.int = CINT, estimate = ESTIMATE, 
            null.value = NVAL, alternative = alternative))
    }
    else {
        df <- (I - 1) * (J - 1)
        n <- m <- double(length = df)
        V <- matrix(0, nrow = df, ncol = df)
        for (k in 1:K) {
            f <- x[, , k]
            ntot <- sum(f)
            rowsums <- apply(f, 1L, sum)[-I]
            colsums <- apply(f, 2L, sum)[-J]
            n <- n + c(f[-I, -J])
            m <- m + c(outer(rowsums, colsums, "*"))/ntot
            V <- V + (kronecker(diag(ntot * colsums, nrow = J - 
                1) - outer(colsums, colsums), diag(ntot * rowsums, 
                nrow = I - 1) - outer(rowsums, rowsums))/(ntot^2 * 
                (ntot - 1)))
        }
        n <- n - m
        STATISTIC <- c(crossprod(n, qr.solve(V, n)))
        PARAMETER <- df
        PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
        names(STATISTIC) <- "Cochran-Mantel-Haenszel M^2"
        names(PARAMETER) <- "df"
        METHOD <- "Cochran-Mantel-Haenszel test"
        RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, 
            p.value = PVAL)
    }
    RVAL <- c(RVAL, list(method = METHOD, data.name = DNAME))
    class(RVAL) <- "htest"
    return(RVAL)
}
<environment: namespace:stats>
> print("mauchly.test"); if(is.function(try(mauchly.test))) {mauchly.test;} else{ NULL};
[1] "mauchly.test"
function (object, ...) 
UseMethod("mauchly.test", object)
<environment: namespace:stats>
> print("mcnemar.test"); if(is.function(try(mcnemar.test))) {mcnemar.test;} else{ NULL};
[1] "mcnemar.test"
function (x, y = NULL, correct = TRUE) 
{
    if (is.matrix(x)) {
        r <- nrow(x)
        if ((r < 2) || (ncol(x) != r)) 
            stop("'x' must be square with at least two rows and columns")
        if (any(x < 0) || any(is.na(x))) 
            stop("all entries of 'x' must be nonnegative and finite")
        DNAME <- deparse(substitute(x))
    }
    else {
        if (is.null(y)) 
            stop("if 'x' is not a matrix, 'y' must be given")
        if (length(x) != length(y)) 
            stop("'x' and 'y' must have the same length")
        DNAME <- paste(deparse(substitute(x)), "and", deparse(substitute(y)))
        OK <- complete.cases(x, y)
        x <- as.factor(x[OK])
        y <- as.factor(y[OK])
        r <- nlevels(x)
        if ((r < 2) || (nlevels(y) != r)) 
            stop("'x' and 'y' must have the same number of levels (minimum 2)")
        x <- table(x, y)
    }
    PARAMETER <- r * (r - 1)/2
    METHOD <- "McNemar's Chi-squared test"
    if (correct && (r == 2) && any(x - t(x) != 0)) {
        y <- (abs(x - t(x)) - 1)
        METHOD <- paste(METHOD, "with continuity correction")
    }
    else y <- x - t(x)
    x <- x + t(x)
    STATISTIC <- sum(y[upper.tri(x)]^2/x[upper.tri(x)])
    PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
    names(STATISTIC) <- "McNemar's chi-squared"
    names(PARAMETER) <- "df"
    RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, 
        p.value = PVAL, method = METHOD, data.name = DNAME)
    class(RVAL) <- "htest"
    return(RVAL)
}
<environment: namespace:stats>
> print("median"); if(is.function(try(median))) {median;} else{ NULL};
[1] "median"
function (x, na.rm = FALSE) 
UseMethod("median")
<environment: namespace:stats>
> print("medpolish"); if(is.function(try(medpolish))) {medpolish;} else{ NULL};
[1] "medpolish"
function (x, eps = 0.01, maxiter = 10, trace.iter = TRUE, na.rm = FALSE) 
{
    z <- as.matrix(x)
    nr <- nrow(z)
    nc <- ncol(z)
    t <- 0
    r <- numeric(nr)
    c <- numeric(nc)
    oldsum <- 0
    for (iter in 1L:maxiter) {
        rdelta <- apply(z, 1L, median, na.rm = na.rm)
        z <- z - matrix(rdelta, nrow = nr, ncol = nc)
        r <- r + rdelta
        delta <- median(c, na.rm = na.rm)
        c <- c - delta
        t <- t + delta
        cdelta <- apply(z, 2L, median, na.rm = na.rm)
        z <- z - matrix(cdelta, nrow = nr, ncol = nc, byrow = TRUE)
        c <- c + cdelta
        delta <- median(r, na.rm = na.rm)
        r <- r - delta
        t <- t + delta
        newsum <- sum(abs(z), na.rm = na.rm)
        converged <- newsum == 0 || abs(newsum - oldsum) < eps * 
            newsum
        if (converged) 
            break
        oldsum <- newsum
        if (trace.iter) 
            cat(iter, ":", newsum, "\n")
    }
    if (converged) {
        if (trace.iter) 
            cat("Final:", newsum, "\n")
    }
    else warning(gettextf("medpolish() did not converge in %d iterations", 
        maxiter), domain = NA)
    names(r) <- rownames(z)
    names(c) <- colnames(z)
    ans <- list(overall = t, row = r, col = c, residuals = z, 
        name = deparse(substitute(x)))
    class(ans) <- "medpolish"
    ans
}
<environment: namespace:stats>
> print("model.extract"); if(is.function(try(model.extract))) {model.extract;} else{ NULL};
[1] "model.extract"
function (frame, component) 
{
    component <- as.character(substitute(component))
    rval <- switch(component, response = model.response(frame), 
        offset = model.offset(frame), frame[[paste("(", component, 
            ")", sep = "")]])
    if (!is.null(rval)) {
        if (length(rval) == nrow(frame)) 
            names(rval) <- attr(frame, "row.names")
        else if (is.matrix(rval) && nrow(rval) == nrow(frame)) {
            t1 <- dimnames(rval)
            dimnames(rval) <- list(attr(frame, "row.names"), 
                t1[[2L]])
        }
    }
    return(rval)
}
<environment: namespace:stats>
> print("model.frame"); if(is.function(try(model.frame))) {model.frame;} else{ NULL};
[1] "model.frame"
function (formula, ...) 
UseMethod("model.frame")
<environment: namespace:stats>
> print("model.matrix"); if(is.function(try(model.matrix))) {model.matrix;} else{ NULL};
[1] "model.matrix"
function (object, ...) 
UseMethod("model.matrix")
<environment: namespace:stats>
> print("model.tables"); if(is.function(try(model.tables))) {model.tables;} else{ NULL};
[1] "model.tables"
function (x, ...) 
UseMethod("model.tables")
<environment: namespace:stats>
> print("monthplot"); if(is.function(try(monthplot))) {monthplot;} else{ NULL};
[1] "monthplot"
function (x, ...) 
UseMethod("monthplot")
<environment: namespace:stats>
> print("mood.test"); if(is.function(try(mood.test))) {mood.test;} else{ NULL};
[1] "mood.test"
function (x, ...) 
UseMethod("mood.test")
<environment: namespace:stats>
> print("na.action"); if(is.function(try(na.action))) {na.action;} else{ NULL};
[1] "na.action"
function (object, ...) 
UseMethod("na.action")
<environment: namespace:stats>
> print("na.contiguous"); if(is.function(try(na.contiguous))) {na.contiguous;} else{ NULL};
[1] "na.contiguous"
function (object, ...) 
UseMethod("na.contiguous")
<environment: namespace:stats>
> print("na.fail"); if(is.function(try(na.fail))) {na.fail;} else{ NULL};
[1] "na.fail"
function (object, ...) 
UseMethod("na.fail")
<environment: namespace:stats>
> print("naprint"); if(is.function(try(naprint))) {naprint;} else{ NULL};
[1] "naprint"
function (x, ...) 
UseMethod("naprint")
<environment: namespace:stats>
> print("naresid"); if(is.function(try(naresid))) {naresid;} else{ NULL};
[1] "naresid"
function (omit, x, ...) 
UseMethod("naresid")
<environment: namespace:stats>
> print("nextn"); if(is.function(try(nextn))) {nextn;} else{ NULL};
[1] "nextn"
function (n, factors = c(2, 3, 5)) 
.Internal(nextn(n, factors))
<environment: namespace:stats>
> print("nlm"); if(is.function(try(nlm))) {nlm;} else{ NULL};
[1] "nlm"
function (f, p, ..., hessian = FALSE, typsize = rep(1, length(p)), 
    fscale = 1, print.level = 0, ndigit = 12, gradtol = 1e-06, 
    stepmax = max(1000 * sqrt(sum((p/typsize)^2)), 1000), steptol = 1e-06, 
    iterlim = 100, check.analyticals = TRUE) 
{
    print.level <- as.integer(print.level)
    if (print.level < 0 || print.level > 2) 
        stop("'print.level' must be in {0,1,2}")
    msg <- (1 + c(8, 0, 16))[1 + print.level]
    if (!check.analyticals) 
        msg <- msg + (2 + 4)
    .Internal(nlm(function(x) f(x, ...), p, hessian, typsize, 
        fscale, msg, ndigit, gradtol, stepmax, steptol, iterlim))
}
<environment: namespace:stats>
> print("nlminb"); if(is.function(try(nlminb))) {nlminb;} else{ NULL};
[1] "nlminb"
function (start, objective, gradient = NULL, hessian = NULL, 
    ..., scale = 1, control = list(), lower = -Inf, upper = Inf) 
{
    par <- as.double(start)
    names(par) <- names(start)
    n <- length(par)
    iv <- integer(78 + 3 * n)
    v <- double(130 + (n * (n + 27))/2)
    .Call(R_port_ivset, 2, iv, v)
    if (length(control)) {
        nms <- names(control)
        if (!is.list(control) || is.null(nms)) 
            stop("control argument must be a named list")
        pos <- pmatch(nms, names(port_cpos))
        if (any(nap <- is.na(pos))) {
            warning(paste("unrecognized control element(s) named `", 
                paste(nms[nap], collapse = ", "), "' ignored", 
                sep = ""))
            pos <- pos[!nap]
            control <- control[!nap]
        }
        ivpars <- pos <= 4
        vpars <- !ivpars
        if (any(ivpars)) 
            iv[port_cpos[pos[ivpars]]] <- as.integer(unlist(control[ivpars]))
        if (any(vpars)) 
            v[port_cpos[pos[vpars]]] <- as.double(unlist(control[vpars]))
    }
    obj <- quote(objective(.par, ...))
    rho <- new.env(parent = environment())
    assign(".par", par, envir = rho)
    grad <- hess <- low <- upp <- NULL
    if (!is.null(gradient)) {
        grad <- quote(gradient(.par, ...))
        if (!is.null(hessian)) {
            if (is.logical(hessian)) 
                stop("Logical `hessian' argument not allowed.  See documentation.")
            hess <- quote(hessian(.par, ...))
        }
    }
    if (any(lower != -Inf) || any(upper != Inf)) {
        low <- rep(as.double(lower), length.out = length(par))
        upp <- rep(as.double(upper), length.out = length(par))
    }
    else low <- upp <- numeric()
    .Call(R_port_nlminb, obj, grad, hess, rho, low, upp, d = rep(as.double(scale), 
        length.out = length(par)), iv, v)
    iv1 <- iv[1L]
    list(par = get(".par", envir = rho), objective = v[10L], 
        convergence = (if (iv1 %in% 3L:6L) 0L else 1L), iterations = iv[31L], 
        evaluations = c(`function` = iv[6L], gradient = iv[30L]), 
        message = if (19 <= iv1 && iv1 <= 43) {
            if (any(B <- iv1 == port_cpos)) sprintf("'control' component '%s' = %g, is out of range", 
                names(port_cpos)[B], v[iv1]) else sprintf("V[IV[1]] = V[%d] = %g is out of range (see PORT docu.)", 
                iv1, v[iv1])
        } else port_msg(iv1))
}
<environment: namespace:stats>
> print("nls"); if(is.function(try(nls))) {nls;} else{ NULL};
[1] "nls"
function (formula, data = parent.frame(), start, control = nls.control(), 
    algorithm = c("default", "plinear", "port"), trace = FALSE, 
    subset, weights, na.action, model = FALSE, lower = -Inf, 
    upper = Inf, ...) 
{
    formula <- as.formula(formula)
    algorithm <- match.arg(algorithm)
    if (!is.list(data) && !is.environment(data)) 
        stop("'data' must be a list or an environment")
    mf <- match.call()
    varNames <- all.vars(formula)
    if (length(formula) == 2L) {
        formula[[3L]] <- formula[[2L]]
        formula[[2L]] <- 0
    }
    form2 <- formula
    form2[[2L]] <- 0
    varNamesRHS <- all.vars(form2)
    mWeights <- missing(weights)
    pnames <- if (missing(start)) {
        if (!is.null(attr(data, "parameters"))) {
            names(attr(data, "parameters"))
        }
        else {
            cll <- formula[[length(formula)]]
            func <- get(as.character(cll[[1L]]))
            if (!is.null(pn <- attr(func, "pnames"))) 
                as.character(as.list(match.call(func, call = cll))[-1L][pn])
        }
    }
    else names(start)
    env <- environment(formula)
    if (is.null(env)) 
        env <- parent.frame()
    if (length(pnames)) 
        varNames <- varNames[is.na(match(varNames, pnames))]
    lenVar <- function(var) tryCatch(length(eval(as.name(var), 
        data, env)), error = function(e) -1)
    if (length(varNames)) {
        n <- sapply(varNames, lenVar)
        if (any(not.there <- n == -1)) {
            nnn <- names(n[not.there])
            if (missing(start)) {
                if (algorithm == "plinear") 
                  stop("No starting values specified")
                warning("No starting values specified for some parameters.\n", 
                  "Intializing ", paste(sQuote(nnn), collapse = ", "), 
                  " to '1.'.\n", "Consider specifying 'start' or using a selfStart model")
                start <- as.list(rep(1, length(nnn)))
                names(start) <- nnn
                varNames <- varNames[i <- is.na(match(varNames, 
                  nnn))]
                n <- n[i]
            }
            else stop("parameters without starting value in 'data': ", 
                paste(nnn, collapse = ", "))
        }
    }
    else {
        if (length(pnames) && any((np <- sapply(pnames, lenVar)) == 
            -1)) {
            message("fitting parameters ", paste(sQuote(pnames[np == 
                -1]), collapse = ", "), " without any variables")
            n <- integer()
        }
        else stop("no parameters to fit")
    }
    respLength <- length(eval(formula[[2L]], data, env))
    if (length(n) > 0L) {
        varIndex <- n%%respLength == 0
        if (is.list(data) && diff(range(n[names(n) %in% names(data)])) > 
            0) {
            mf <- data
            if (!missing(subset)) 
                warning("argument 'subset' will be ignored")
            if (!missing(na.action)) 
                warning("argument 'na.action' will be ignored")
            if (missing(start)) 
                start <- getInitial(formula, mf)
            startEnv <- new.env(hash = FALSE, parent = environment(formula))
            for (i in names(start)) assign(i, start[[i]], envir = startEnv)
            rhs <- eval(formula[[3L]], data, startEnv)
            n <- NROW(rhs)
            wts <- if (mWeights) 
                rep(1, n)
            else eval(substitute(weights), data, environment(formula))
        }
        else {
            mf$formula <- as.formula(paste("~", paste(varNames[varIndex], 
                collapse = "+")), env = environment(formula))
            mf$start <- mf$control <- mf$algorithm <- mf$trace <- mf$model <- NULL
            mf$lower <- mf$upper <- NULL
            mf[[1L]] <- as.name("model.frame")
            mf <- eval.parent(mf)
            n <- nrow(mf)
            mf <- as.list(mf)
            wts <- if (!mWeights) 
                model.weights(mf)
            else rep(1, n)
        }
        if (any(wts < 0 | is.na(wts))) 
            stop("missing or negative weights not allowed")
    }
    else {
        varIndex <- logical()
        mf <- list(0)
        wts <- numeric()
    }
    if (missing(start)) 
        start <- getInitial(formula, mf)
    for (var in varNames[!varIndex]) mf[[var]] <- eval(as.name(var), 
        data, env)
    varNamesRHS <- varNamesRHS[varNamesRHS %in% varNames[varIndex]]
    m <- switch(algorithm, plinear = nlsModel.plinear(formula, 
        mf, start, wts), port = nlsModel(formula, mf, start, 
        wts, upper), nlsModel(formula, mf, start, wts))
    ctrl <- nls.control()
    if (!missing(control)) {
        control <- as.list(control)
        ctrl[names(control)] <- control
    }
    if (algorithm != "port") {
        if (!missing(lower) || !missing(upper)) 
            warning("Upper or lower bounds ignored unless algorithm = \"port\"")
        convInfo <- .Call(R_nls_iter, m, ctrl, trace)
        nls.out <- list(m = m, convInfo = convInfo, data = substitute(data), 
            call = match.call())
    }
    else {
        pfit <- nls_port_fit(m, start, lower, upper, control, 
            trace, give.v = TRUE)
        iv <- pfit[["iv"]]
        msg.nls <- port_msg(iv[1L])
        conv <- (iv[1L] %in% 3:6)
        if (!conv) {
            msg <- paste("Convergence failure:", msg.nls)
            if (ctrl$warnOnly) 
                warning(msg)
            else stop(msg)
        }
        v. <- port_get_named_v(pfit[["v"]])
        cInfo <- list(isConv = conv, finIter = iv[31L], finTol = v.[["NREDUC"]], 
            nEval = c(`function` = iv[6L], gradient = iv[30L]), 
            stopCode = iv[1L], stopMessage = msg.nls)
        cl <- match.call()
        cl$lower <- lower
        cl$upper <- upper
        nls.out <- list(m = m, data = substitute(data), call = cl, 
            convInfo = cInfo, convergence = as.integer(!conv), 
            message = msg.nls)
    }
    nls.out$call$algorithm <- algorithm
    nls.out$call$control <- ctrl
    nls.out$call$trace <- trace
    nls.out$na.action <- attr(mf, "na.action")
    nls.out$dataClasses <- attr(attr(mf, "terms"), "dataClasses")[varNamesRHS]
    if (model) 
        nls.out$model <- mf
    if (!mWeights) 
        nls.out$weights <- wts
    nls.out$control <- control
    class(nls.out) <- "nls"
    nls.out
}
<environment: namespace:stats>
> print("nls.control"); if(is.function(try(nls.control))) {nls.control;} else{ NULL};
[1] "nls.control"
function (maxiter = 50, tol = 1e-05, minFactor = 1/1024, printEval = FALSE, 
    warnOnly = FALSE) 
list(maxiter = maxiter, tol = tol, minFactor = minFactor, printEval = printEval, 
    warnOnly = warnOnly)
<environment: namespace:stats>
> print("nobs"); if(is.function(try(nobs))) {nobs;} else{ NULL};
[1] "nobs"
function (object, ...) 
UseMethod("nobs")
<environment: namespace:stats>
> print("numericDeriv"); if(is.function(try(numericDeriv))) {numericDeriv;} else{ NULL};
[1] "numericDeriv"
function (expr, theta, rho = parent.frame(), dir = 1) 
{
    dir <- rep(dir, length.out = length(theta))
    val <- .Call(R_numeric_deriv, expr, theta, rho, dir)
    valDim <- dim(val)
    if (!is.null(valDim)) {
        if (valDim[length(valDim)] == 1) 
            valDim <- valDim[-length(valDim)]
        if (length(valDim) > 1L) 
            dim(attr(val, "gradient")) <- c(valDim, dim(attr(val, 
                "gradient"))[-1L])
    }
    val
}
<environment: namespace:stats>
> print("offset"); if(is.function(try(offset))) {offset;} else{ NULL};
[1] "offset"
function (object) 
object
<environment: namespace:stats>
> print("oneway.test"); if(is.function(try(oneway.test))) {oneway.test;} else{ NULL};
[1] "oneway.test"
function (formula, data, subset, na.action, var.equal = FALSE) 
{
    if (missing(formula) || (length(formula) != 3L)) 
        stop("'formula' missing or incorrect")
    dp <- as.character(formula)
    if (length(dp) != 3L) 
        stop("a two-sided formula is required")
    DNAME <- paste(dp[[2L]], "and", dp[[3L]])
    m <- match.call(expand.dots = FALSE)
    if (is.matrix(eval(m$data, parent.frame()))) 
        m$data <- as.data.frame(data)
    m$var.equal <- NULL
    m[[1L]] <- as.name("model.frame")
    mf <- eval(m, parent.frame())
    response <- attr(attr(mf, "terms"), "response")
    y <- mf[[response]]
    if (length(mf[-response]) > 1L) 
        g <- factor(do.call("interaction", mf[-response]))
    else g <- factor(mf[[-response]])
    k <- nlevels(g)
    if (k < 2L) 
        stop("not enough groups")
    n.i <- tapply(y, g, length)
    if (any(n.i < 2)) 
        stop("not enough observations")
    m.i <- tapply(y, g, mean)
    v.i <- tapply(y, g, var)
    w.i <- n.i/v.i
    sum.w.i <- sum(w.i)
    tmp <- sum((1 - w.i/sum.w.i)^2/(n.i - 1))/(k^2 - 1)
    METHOD <- "One-way analysis of means"
    if (var.equal) {
        n <- sum(n.i)
        STATISTIC <- ((sum(n.i * (m.i - mean(y))^2)/(k - 1))/(sum((n.i - 
            1) * v.i)/(n - k)))
        PARAMETER <- c(k - 1, n - k)
        PVAL <- pf(STATISTIC, k - 1, n - k, lower.tail = FALSE)
    }
    else {
        m <- sum(w.i * m.i)/sum.w.i
        STATISTIC <- sum(w.i * (m.i - m)^2)/((k - 1) * (1 + 2 * 
            (k - 2) * tmp))
        PARAMETER <- c(k - 1, 1/(3 * tmp))
        PVAL <- pf(STATISTIC, k - 1, 1/(3 * tmp), lower.tail = FALSE)
        METHOD <- paste(METHOD, "(not assuming equal variances)")
    }
    names(STATISTIC) <- "F"
    names(PARAMETER) <- c("num df", "denom df")
    RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, 
        p.value = PVAL, method = METHOD, data.name = DNAME)
    class(RVAL) <- "htest"
    RVAL
}
<environment: namespace:stats>
> print("optim"); if(is.function(try(optim))) {optim;} else{ NULL};
[1] "optim"
function (par, fn, gr = NULL, ..., method = c("Nelder-Mead", 
    "BFGS", "CG", "L-BFGS-B", "SANN"), lower = -Inf, upper = Inf, 
    control = list(), hessian = FALSE) 
{
    fn1 <- function(par) fn(par, ...)
    gr1 <- if (!is.null(gr)) 
        function(par) gr(par, ...)
    method <- match.arg(method)
    if ((length(lower) > 1L || length(upper) > 1L || lower[1L] != 
        -Inf || upper[1L] != Inf) && method != "L-BFGS-B") {
        warning("bounds can only be used with method L-BFGS-B")
        method <- "L-BFGS-B"
    }
    con <- list(trace = 0, fnscale = 1, parscale = rep.int(1, 
        length(par)), ndeps = rep.int(0.001, length(par)), maxit = 100L, 
        abstol = -Inf, reltol = sqrt(.Machine$double.eps), alpha = 1, 
        beta = 0.5, gamma = 2, REPORT = 10, type = 1, lmm = 5, 
        factr = 1e+07, pgtol = 0, tmax = 10, temp = 10)
    nmsC <- names(con)
    if (method == "Nelder-Mead") 
        con$maxit <- 500
    if (method == "SANN") {
        con$maxit <- 10000
        con$REPORT <- 100
    }
    con[(namc <- names(control))] <- control
    if (length(noNms <- namc[!namc %in% nmsC])) 
        warning("unknown names in control: ", paste(noNms, collapse = ", "))
    if (con$trace < 0) 
        warning("read the documentation for 'trace' more carefully")
    else if (method == "SANN" && con$trace && as.integer(con$REPORT) == 
        0) 
        stop("'trace != 0' needs 'REPORT >= 1'")
    if (method == "L-BFGS-B" && any(!is.na(match(c("reltol", 
        "abstol"), namc)))) 
        warning("method L-BFGS-B uses 'factr' (and 'pgtol') instead of 'reltol' and 'abstol'")
    npar <- length(par)
    if (npar == 1 && method == "Nelder-Mead") 
        warning("one-diml optimization by Nelder-Mead is unreliable: use optimize")
    lower <- as.double(rep(lower, , npar))
    upper <- as.double(rep(upper, , npar))
    res <- .Internal(optim(par, fn1, gr1, method, con, lower, 
        upper))
    names(res) <- c("par", "value", "counts", "convergence", 
        "message")
    nm <- names(par)
    if (!is.null(nm)) 
        names(res$par) <- nm
    names(res$counts) <- c("function", "gradient")
    if (hessian) {
        hess <- .Internal(optimhess(res$par, fn1, gr1, con))
        hess <- 0.5 * (hess + t(hess))
        if (!is.null(nm)) 
            dimnames(hess) <- list(nm, nm)
        res$hessian <- hess
    }
    res
}
<environment: namespace:stats>
> print("optimize"); if(is.function(try(optimize))) {optimize;} else{ NULL};
[1] "optimize"
function (f, interval, ..., lower = min(interval), upper = max(interval), 
    maximum = FALSE, tol = .Machine$double.eps^0.25) 
{
    if (maximum) {
        val <- .Internal(fmin(function(arg) -f(arg, ...), lower, 
            upper, tol))
        list(maximum = val, objective = f(val, ...))
    }
    else {
        val <- .Internal(fmin(function(arg) f(arg, ...), lower, 
            upper, tol))
        list(minimum = val, objective = f(val, ...))
    }
}
<environment: namespace:stats>
> print("order.dendrogram"); if(is.function(try(order.dendrogram))) {order.dendrogram;} else{ NULL};
[1] "order.dendrogram"
function (x) 
{
    if (!inherits(x, "dendrogram")) 
        stop("'order.dendrogram' requires a dendrogram")
    unlist(x)
}
<environment: namespace:stats>
> print("p.adjust"); if(is.function(try(p.adjust))) {p.adjust;} else{ NULL};
[1] "p.adjust"
function (p, method = p.adjust.methods, n = length(p)) 
{
    method <- match.arg(method)
    if (method == "fdr") 
        method <- "BH"
    nm <- names(p)
    p <- as.numeric(p)
    names(p) <- nm
    p0 <- p
    if (all(nna <- !is.na(p))) 
        nna <- TRUE
    p <- p[nna]
    lp <- length(p)
    stopifnot(n >= lp)
    if (n <= 1) 
        return(p0)
    if (n == 2 && method == "hommel") 
        method <- "hochberg"
    p0[nna] <- switch(method, bonferroni = pmin(1, n * p), holm = {
        i <- seq_len(lp)
        o <- order(p)
        ro <- order(o)
        pmin(1, cummax((n - i + 1L) * p[o]))[ro]
    }, hommel = {
        if (n > lp) p <- c(p, rep.int(1, n - lp))
        i <- seq_len(n)
        o <- order(p)
        p <- p[o]
        ro <- order(o)
        q <- pa <- rep.int(min(n * p/i), n)
        for (j in (n - 1):2) {
            ij <- seq_len(n - j + 1)
            i2 <- (n - j + 2):n
            q1 <- min(j * p[i2]/(2:j))
            q[ij] <- pmin(j * p[ij], q1)
            q[i2] <- q[n - j + 1]
            pa <- pmax(pa, q)
        }
        pmax(pa, p)[if (lp < n) ro[1:lp] else ro]
    }, hochberg = {
        i <- lp:1L
        o <- order(p, decreasing = TRUE)
        ro <- order(o)
        pmin(1, cummin((n - i + 1L) * p[o]))[ro]
    }, BH = {
        i <- lp:1L
        o <- order(p, decreasing = TRUE)
        ro <- order(o)
        pmin(1, cummin(n/i * p[o]))[ro]
    }, BY = {
        i <- lp:1L
        o <- order(p, decreasing = TRUE)
        ro <- order(o)
        q <- sum(1L/(1L:n))
        pmin(1, cummin(q * n/i * p[o]))[ro]
    }, none = p)
    p0
}
<environment: namespace:stats>
> print("pairwise.prop.test"); if(is.function(try(pairwise.prop.test))) {pairwise.prop.test;} else{ NULL};
[1] "pairwise.prop.test"
function (x, n, p.adjust.method = p.adjust.methods, ...) 
{
    p.adjust.method <- match.arg(p.adjust.method)
    METHOD <- "Pairwise comparison of proportions"
    DNAME <- deparse(substitute(x))
    if (is.matrix(x)) {
        if (ncol(x) != 2) 
            stop("'x' must have 2 columns")
        n <- rowSums(x)
        x <- x[, 1]
    }
    else {
        DNAME <- paste(DNAME, "out of", deparse(substitute(n)))
        if (length(x) != length(n)) 
            stop("'x' and 'n' must have the same length")
    }
    OK <- complete.cases(x, n)
    x <- x[OK]
    n <- n[OK]
    if (length(x) < 2L) 
        stop("too few groups")
    compare.levels <- function(i, j) {
        prop.test(x[c(i, j)], n[c(i, j)], ...)$p.value
    }
    level.names <- names(x)
    if (is.null(level.names)) 
        level.names <- seq_along(x)
    PVAL <- pairwise.table(compare.levels, level.names, p.adjust.method)
    ans <- list(method = METHOD, data.name = DNAME, p.value = PVAL, 
        p.adjust.method = p.adjust.method)
    class(ans) <- "pairwise.htest"
    ans
}
<environment: namespace:stats>
> print("pairwise.t.test"); if(is.function(try(pairwise.t.test))) {pairwise.t.test;} else{ NULL};
[1] "pairwise.t.test"
function (x, g, p.adjust.method = p.adjust.methods, pool.sd = !paired, 
    paired = FALSE, alternative = c("two.sided", "less", "greater"), 
    ...) 
{
    if (paired & pool.sd) 
        stop("Pooling of SD is incompatible with paired tests")
    DNAME <- paste(deparse(substitute(x)), "and", deparse(substitute(g)))
    g <- factor(g)
    p.adjust.method <- match.arg(p.adjust.method)
    alternative <- match.arg(alternative)
    if (pool.sd) {
        METHOD <- "t tests with pooled SD"
        xbar <- tapply(x, g, mean, na.rm = TRUE)
        s <- tapply(x, g, sd, na.rm = TRUE)
        n <- tapply(!is.na(x), g, sum)
        degf <- n - 1
        total.degf <- sum(degf)
        pooled.sd <- sqrt(sum(s^2 * degf)/total.degf)
        compare.levels <- function(i, j) {
            dif <- xbar[i] - xbar[j]
            se.dif <- pooled.sd * sqrt(1/n[i] + 1/n[j])
            t.val <- dif/se.dif
            if (alternative == "two.sided") 
                2 * pt(-abs(t.val), total.degf)
            else pt(t.val, total.degf, lower.tail = (alternative == 
                "less"))
        }
    }
    else {
        METHOD <- if (paired) 
            "paired t tests"
        else "t tests with non-pooled SD"
        compare.levels <- function(i, j) {
            xi <- x[as.integer(g) == i]
            xj <- x[as.integer(g) == j]
            t.test(xi, xj, paired = paired, alternative = alternative, 
                ...)$p.value
        }
    }
    PVAL <- pairwise.table(compare.levels, levels(g), p.adjust.method)
    ans <- list(method = METHOD, data.name = DNAME, p.value = PVAL, 
        p.adjust.method = p.adjust.method)
    class(ans) <- "pairwise.htest"
    ans
}
<environment: namespace:stats>
> print("pairwise.table"); if(is.function(try(pairwise.table))) {pairwise.table;} else{ NULL};
[1] "pairwise.table"
function (compare.levels, level.names, p.adjust.method) 
{
    ix <- seq_along(level.names)
    names(ix) <- level.names
    pp <- outer(ix[-1L], ix[-length(ix)], function(ivec, jvec) sapply(seq_along(ivec), 
        function(k) {
            i <- ivec[k]
            j <- jvec[k]
            if (i > j) 
                compare.levels(i, j)
            else NA
        }))
    pp[lower.tri(pp, TRUE)] <- p.adjust(pp[lower.tri(pp, TRUE)], 
        p.adjust.method)
    pp
}
<environment: namespace:stats>
> print("pairwise.wilcox.test"); if(is.function(try(pairwise.wilcox.test))) {pairwise.wilcox.test;} else{ NULL};
[1] "pairwise.wilcox.test"
function (x, g, p.adjust.method = p.adjust.methods, paired = FALSE, 
    ...) 
{
    p.adjust.method <- match.arg(p.adjust.method)
    DNAME <- paste(deparse(substitute(x)), "and", deparse(substitute(g)))
    g <- factor(g)
    METHOD <- if (paired) 
        "Wilcoxon signed rank test"
    else "Wilcoxon rank sum test"
    compare.levels <- function(i, j) {
        xi <- x[as.integer(g) == i]
        xj <- x[as.integer(g) == j]
        wilcox.test(xi, xj, paired = paired, ...)$p.value
    }
    PVAL <- pairwise.table(compare.levels, levels(g), p.adjust.method)
    ans <- list(method = METHOD, data.name = DNAME, p.value = PVAL, 
        p.adjust.method = p.adjust.method)
    class(ans) <- "pairwise.htest"
    ans
}
<environment: namespace:stats>
> print("plot.HoltWinters"); if(is.function(try(plot.HoltWinters))) {plot.HoltWinters;} else{ NULL};
[1] "plot.HoltWinters"
NULL
> print("plot.acf"); if(is.function(try(plot.acf))) {plot.acf;} else{ NULL};
[1] "plot.acf"
NULL
> print("plot.density"); if(is.function(try(plot.density))) {plot.density;} else{ NULL};
[1] "plot.density"
function (x, main = NULL, xlab = NULL, ylab = "Density", type = "l", 
    zero.line = TRUE, ...) 
{
    if (is.null(xlab)) 
        xlab <- paste("N =", x$n, "  Bandwidth =", formatC(x$bw))
    if (is.null(main)) 
        main <- deparse(x$call)
    plot.default(x, main = main, xlab = xlab, ylab = ylab, type = type, 
        ...)
    if (zero.line) 
        abline(h = 0, lwd = 0.1, col = "gray")
    invisible(NULL)
}
<environment: namespace:stats>
> print("plot.isoreg"); if(is.function(try(plot.isoreg))) {plot.isoreg;} else{ NULL};
[1] "plot.isoreg"
NULL
> print("plot.lm"); if(is.function(try(plot.lm))) {plot.lm;} else{ NULL};
[1] "plot.lm"
function (x, which = c(1L:3L, 5L), caption = list("Residuals vs Fitted", 
    "Normal Q-Q", "Scale-Location", "Cook's distance", "Residuals vs Leverage", 
    expression("Cook's dist vs Leverage  " * h[ii]/(1 - h[ii]))), 
    panel = if (add.smooth) panel.smooth else points, sub.caption = NULL, 
    main = "", ask = prod(par("mfcol")) < length(which) && dev.interactive(), 
    ..., id.n = 3, labels.id = names(residuals(x)), cex.id = 0.75, 
    qqline = TRUE, cook.levels = c(0.5, 1), add.smooth = getOption("add.smooth"), 
    label.pos = c(4, 2), cex.caption = 1) 
{
    dropInf <- function(x, h) {
        if (any(isInf <- h >= 1)) {
            warning("Not plotting observations with leverage one:\n  ", 
                paste(which(isInf), collapse = ", "), call. = FALSE)
            x[isInf] <- NaN
        }
        x
    }
    if (!inherits(x, "lm")) 
        stop("use only with \"lm\" objects")
    if (!is.numeric(which) || any(which < 1) || any(which > 6)) 
        stop("'which' must be in 1:6")
    isGlm <- inherits(x, "glm")
    show <- rep(FALSE, 6)
    show[which] <- TRUE
    r <- residuals(x)
    yh <- predict(x)
    w <- weights(x)
    if (!is.null(w)) {
        wind <- w != 0
        r <- r[wind]
        yh <- yh[wind]
        w <- w[wind]
        labels.id <- labels.id[wind]
    }
    n <- length(r)
    if (any(show[2L:6L])) {
        s <- if (inherits(x, "rlm")) 
            x$s
        else if (isGlm) 
            sqrt(summary(x)$dispersion)
        else sqrt(deviance(x)/df.residual(x))
        hii <- lm.influence(x, do.coef = FALSE)$hat
        if (any(show[4L:6L])) {
            cook <- if (isGlm) 
                cooks.distance(x)
            else cooks.distance(x, sd = s, res = r)
        }
    }
    if (any(show[2L:3L])) {
        ylab23 <- if (isGlm) 
            "Std. deviance resid."
        else "Standardized residuals"
        r.w <- if (is.null(w)) 
            r
        else sqrt(w) * r
        rs <- dropInf(r.w/(s * sqrt(1 - hii)), hii)
    }
    if (any(show[5L:6L])) {
        r.hat <- range(hii, na.rm = TRUE)
        isConst.hat <- all(r.hat == 0) || diff(r.hat) < 1e-10 * 
            mean(hii, na.rm = TRUE)
    }
    if (any(show[c(1L, 3L)])) 
        l.fit <- if (isGlm) 
            "Predicted values"
        else "Fitted values"
    if (is.null(id.n)) 
        id.n <- 0
    else {
        id.n <- as.integer(id.n)
        if (id.n < 0L || id.n > n) 
            stop(gettextf("'id.n' must be in {1,..,%d}", n), 
                domain = NA)
    }
    if (id.n > 0L) {
        if (is.null(labels.id)) 
            labels.id <- paste(1L:n)
        iid <- 1L:id.n
        show.r <- sort.list(abs(r), decreasing = TRUE)[iid]
        if (any(show[2L:3L])) 
            show.rs <- sort.list(abs(rs), decreasing = TRUE)[iid]
        text.id <- function(x, y, ind, adj.x = TRUE) {
            labpos <- if (adj.x) 
                label.pos[1 + as.numeric(x > mean(range(x)))]
            else 3
            text(x, y, labels.id[ind], cex = cex.id, xpd = TRUE, 
                pos = labpos, offset = 0.25)
        }
    }
    getCaption <- function(k) if (length(caption) < k) 
        NA_character_
    else as.graphicsAnnot(caption[[k]])
    if (is.null(sub.caption)) {
        cal <- x$call
        if (!is.na(m.f <- match("formula", names(cal)))) {
            cal <- cal[c(1, m.f)]
            names(cal)[2L] <- ""
        }
        cc <- deparse(cal, 80)
        nc <- nchar(cc[1L], "c")
        abbr <- length(cc) > 1 || nc > 75
        sub.caption <- if (abbr) 
            paste(substr(cc[1L], 1L, min(75L, nc)), "...")
        else cc[1L]
    }
    one.fig <- prod(par("mfcol")) == 1
    if (ask) {
        oask <- devAskNewPage(TRUE)
        on.exit(devAskNewPage(oask))
    }
    if (show[1L]) {
        ylim <- range(r, na.rm = TRUE)
        if (id.n > 0) 
            ylim <- extendrange(r = ylim, f = 0.08)
        plot(yh, r, xlab = l.fit, ylab = "Residuals", main = main, 
            ylim = ylim, type = "n", ...)
        panel(yh, r, ...)
        if (one.fig) 
            title(sub = sub.caption, ...)
        mtext(getCaption(1), 3, 0.25, cex = cex.caption)
        if (id.n > 0) {
            y.id <- r[show.r]
            y.id[y.id < 0] <- y.id[y.id < 0] - strheight(" ")/3
            text.id(yh[show.r], y.id, show.r)
        }
        abline(h = 0, lty = 3, col = "gray")
    }
    if (show[2L]) {
        ylim <- range(rs, na.rm = TRUE)
        ylim[2L] <- ylim[2L] + diff(ylim) * 0.075
        qq <- qqnorm(rs, main = main, ylab = ylab23, ylim = ylim, 
            ...)
        if (qqline) 
            qqline(rs, lty = 3, col = "gray50")
        if (one.fig) 
            title(sub = sub.caption, ...)
        mtext(getCaption(2), 3, 0.25, cex = cex.caption)
        if (id.n > 0) 
            text.id(qq$x[show.rs], qq$y[show.rs], show.rs)
    }
    if (show[3L]) {
        sqrtabsr <- sqrt(abs(rs))
        ylim <- c(0, max(sqrtabsr, na.rm = TRUE))
        yl <- as.expression(substitute(sqrt(abs(YL)), list(YL = as.name(ylab23))))
        yhn0 <- if (is.null(w)) 
            yh
        else yh[w != 0]
        plot(yhn0, sqrtabsr, xlab = l.fit, ylab = yl, main = main, 
            ylim = ylim, type = "n", ...)
        panel(yhn0, sqrtabsr, ...)
        if (one.fig) 
            title(sub = sub.caption, ...)
        mtext(getCaption(3), 3, 0.25, cex = cex.caption)
        if (id.n > 0) 
            text.id(yhn0[show.rs], sqrtabsr[show.rs], show.rs)
    }
    if (show[4L]) {
        if (id.n > 0) {
            show.r <- order(-cook)[iid]
            ymx <- cook[show.r[1L]] * 1.075
        }
        else ymx <- max(cook, na.rm = TRUE)
        plot(cook, type = "h", ylim = c(0, ymx), main = main, 
            xlab = "Obs. number", ylab = "Cook's distance", ...)
        if (one.fig) 
            title(sub = sub.caption, ...)
        mtext(getCaption(4), 3, 0.25, cex = cex.caption)
        if (id.n > 0) 
            text.id(show.r, cook[show.r], show.r, adj.x = FALSE)
    }
    if (show[5L]) {
        ylab5 <- if (isGlm) 
            "Std. Pearson resid."
        else "Standardized residuals"
        r.w <- residuals(x, "pearson")
        if (!is.null(w)) 
            r.w <- r.w[wind]
        rsp <- dropInf(r.w/(s * sqrt(1 - hii)), hii)
        ylim <- range(rsp, na.rm = TRUE)
        if (id.n > 0) {
            ylim <- extendrange(r = ylim, f = 0.08)
            show.rsp <- order(-cook)[iid]
        }
        do.plot <- TRUE
        if (isConst.hat) {
            if (missing(caption)) 
                caption[[5L]] <- "Constant Leverage:\n Residuals vs Factor Levels"
            aterms <- attributes(terms(x))
            dcl <- aterms$dataClasses[-aterms$response]
            facvars <- names(dcl)[dcl %in% c("factor", "ordered")]
            mf <- model.frame(x)[facvars]
            if (ncol(mf) > 0) {
                effM <- mf
                for (j in seq_len(ncol(mf))) effM[, j] <- sapply(split(yh, 
                  mf[, j]), mean)[mf[, j]]
                ord <- do.call(order, effM)
                dm <- data.matrix(mf)[ord, , drop = FALSE]
                nf <- length(nlev <- unlist(unname(lapply(x$xlevels, 
                  length))))
                ff <- if (nf == 1) 
                  1
                else rev(cumprod(c(1, nlev[nf:2])))
                facval <- (dm - 1) %*% ff
                xx <- facval
                plot(facval, rsp, xlim = c(-1/2, sum((nlev - 
                  1) * ff) + 1/2), ylim = ylim, xaxt = "n", main = main, 
                  xlab = "Factor Level Combinations", ylab = ylab5, 
                  type = "n", ...)
                grp_means <- sapply(split(yh, mf[, 1L]), mean)
                axis(1, at = ff[1L] * (1L:nlev[1L] - 1/2) - 1/2, 
                  labels = x$xlevels[[1L]][order(grp_means)])
                mtext(paste(facvars[1L], ":"), side = 1, line = 0.25, 
                  adj = -0.05)
                abline(v = ff[1L] * (0:nlev[1L]) - 1/2, col = "gray", 
                  lty = "F4")
                panel(facval, rsp, ...)
                abline(h = 0, lty = 3, col = "gray")
            }
            else {
                message("hat values (leverages) are all = ", 
                  format(mean(r.hat)), "\n and there are no factor predictors; no plot no. 5")
                frame()
                do.plot <- FALSE
            }
        }
        else {
            xx <- hii
            xx[xx >= 1] <- NA
            plot(xx, rsp, xlim = c(0, max(xx, na.rm = TRUE)), 
                ylim = ylim, main = main, xlab = "Leverage", 
                ylab = ylab5, type = "n", ...)
            panel(xx, rsp, ...)
            abline(h = 0, v = 0, lty = 3, col = "gray")
            if (one.fig) 
                title(sub = sub.caption, ...)
            if (length(cook.levels)) {
                p <- length(coef(x))
                usr <- par("usr")
                hh <- seq.int(min(r.hat[1L], r.hat[2L]/100), 
                  usr[2L], length.out = 101)
                for (crit in cook.levels) {
                  cl.h <- sqrt(crit * p * (1 - hh)/hh)
                  lines(hh, cl.h, lty = 2, col = 2)
                  lines(hh, -cl.h, lty = 2, col = 2)
                }
                legend("bottomleft", legend = "Cook's distance", 
                  lty = 2, col = 2, bty = "n")
                xmax <- min(0.99, usr[2L])
                ymult <- sqrt(p * (1 - xmax)/xmax)
                aty <- c(-sqrt(rev(cook.levels)) * ymult, sqrt(cook.levels) * 
                  ymult)
                axis(4, at = aty, labels = paste(c(rev(cook.levels), 
                  cook.levels)), mgp = c(0.25, 0.25, 0), las = 2, 
                  tck = 0, cex.axis = cex.id, col.axis = 2)
            }
        }
        if (do.plot) {
            mtext(getCaption(5), 3, 0.25, cex = cex.caption)
            if (id.n > 0) {
                y.id <- rsp[show.rsp]
                y.id[y.id < 0] <- y.id[y.id < 0] - strheight(" ")/3
                text.id(xx[show.rsp], y.id, show.rsp)
            }
        }
    }
    if (show[6L]) {
        g <- dropInf(hii/(1 - hii), hii)
        ymx <- max(cook, na.rm = TRUE) * 1.025
        plot(g, cook, xlim = c(0, max(g, na.rm = TRUE)), ylim = c(0, 
            ymx), main = main, ylab = "Cook's distance", xlab = expression("Leverage  " * 
            h[ii]), xaxt = "n", type = "n", ...)
        panel(g, cook, ...)
        athat <- pretty(hii)
        axis(1, at = athat/(1 - athat), labels = paste(athat))
        if (one.fig) 
            title(sub = sub.caption, ...)
        p <- length(coef(x))
        bval <- pretty(sqrt(p * cook/g), 5)
        usr <- par("usr")
        xmax <- usr[2L]
        ymax <- usr[4L]
        for (i in seq_along(bval)) {
            bi2 <- bval[i]^2
            if (ymax > bi2 * xmax) {
                xi <- xmax + strwidth(" ")/3
                yi <- bi2 * xi
                abline(0, bi2, lty = 2)
                text(xi, yi, paste(bval[i]), adj = 0, xpd = TRUE)
            }
            else {
                yi <- ymax - 1.5 * strheight(" ")
                xi <- yi/bi2
                lines(c(0, xi), c(0, yi), lty = 2)
                text(xi, ymax - 0.8 * strheight(" "), paste(bval[i]), 
                  adj = 0.5, xpd = TRUE)
            }
        }
        mtext(getCaption(6), 3, 0.25, cex = cex.caption)
        if (id.n > 0) {
            show.r <- order(-cook)[iid]
            text.id(g[show.r], cook[show.r], show.r)
        }
    }
    if (!one.fig && par("oma")[3L] >= 1) 
        mtext(sub.caption, outer = TRUE, cex = 1.25)
    invisible()
}
<environment: namespace:stats>
> print("plot.ppr"); if(is.function(try(plot.ppr))) {plot.ppr;} else{ NULL};
[1] "plot.ppr"
NULL
> print("plot.profile.nls"); if(is.function(try(plot.profile.nls))) {plot.profile.nls;} else{ NULL};
[1] "plot.profile.nls"
NULL
> print("plot.spec"); if(is.function(try(plot.spec))) {plot.spec;} else{ NULL};
[1] "plot.spec"
function (x, add = FALSE, ci = 0.95, log = c("yes", "dB", "no"), 
    xlab = "frequency", ylab = NULL, type = "l", ci.col = "blue", 
    ci.lty = 3, main = NULL, sub = NULL, plot.type = c("marginal", 
        "coherency", "phase"), ...) 
{
    spec.ci <- function(spec.obj, coverage = 0.95) {
        if (coverage < 0 || coverage >= 1) 
            stop("coverage probability out of range [0,1)")
        tail <- (1 - coverage)
        df <- spec.obj$df
        upper.quantile <- 1 - tail * pchisq(df, df, lower.tail = FALSE)
        lower.quantile <- tail * pchisq(df, df)
        1/(qchisq(c(upper.quantile, lower.quantile), df)/df)
    }
    plot.type <- match.arg(plot.type)
    log <- match.arg(log)
    m <- match.call()
    if (plot.type == "coherency") {
        m[[1L]] <- as.name("plot.spec.coherency")
        m$plot.type <- m$log <- m$add <- NULL
        return(eval(m, parent.frame()))
    }
    if (plot.type == "phase") {
        m[[1L]] <- as.name("plot.spec.phase")
        m$plot.type <- m$log <- m$add <- NULL
        return(eval(m, parent.frame()))
    }
    if (is.null(ylab)) 
        ylab <- if (log == "dB") 
            "spectrum (dB)"
        else "spectrum"
    if (is.logical(log)) 
        log <- if (log) 
            "yes"
        else "no"
    if (missing(log) && getOption("ts.S.compat")) 
        log <- "dB"
    log <- match.arg(log)
    ylog <- ""
    if (log == "dB") 
        x$spec <- 10 * log10(x$spec)
    if (log == "yes") 
        ylog <- "y"
    if (add) {
        matplot(x$freq, x$spec, type = type, add = TRUE, ...)
    }
    else {
        matplot(x$freq, x$spec, xlab = xlab, ylab = ylab, type = type, 
            log = ylog, ...)
        if (ci <= 0 || !is.numeric(x$df) || log == "no") {
            ci.text <- ""
        }
        else {
            conf.lim <- spec.ci(x, coverage = ci)
            if (log == "dB") {
                conf.lim <- 10 * log10(conf.lim)
                conf.y <- max(x$spec) - conf.lim[2L]
                conf.x <- max(x$freq) - x$bandwidth
                lines(rep(conf.x, 2), conf.y + conf.lim, col = ci.col)
                lines(conf.x + c(-0.5, 0.5) * x$bandwidth, rep(conf.y, 
                  2), col = ci.col)
                ci.text <- paste(", ", round(100 * ci, 2), "% C.I. is (", 
                  paste(format(conf.lim, digits = 3), collapse = ","), 
                  ")dB", sep = "")
            }
            else {
                ci.text <- ""
                conf.y <- max(x$spec)/conf.lim[2L]
                conf.x <- max(x$freq) - x$bandwidth
                lines(rep(conf.x, 2), conf.y * conf.lim, col = ci.col)
                lines(conf.x + c(-0.5, 0.5) * x$bandwidth, rep(conf.y, 
                  2), col = ci.col)
            }
        }
        if (is.null(main)) 
            main <- paste(if (!is.null(x$series)) 
                paste("Series:", x$series)
            else "from specified model", x$method, sep = "\n")
        if (is.null(sub) && is.numeric(x$bandwidth)) 
            sub <- paste("bandwidth = ", format(x$bandwidth, 
                digits = 3), ci.text, sep = "")
        title(main = main, sub = sub)
    }
    invisible(x)
}
<environment: namespace:stats>
> print("plot.stepfun"); if(is.function(try(plot.stepfun))) {plot.stepfun;} else{ NULL};
[1] "plot.stepfun"
function (x, xval, xlim, ylim = range(c(y, Fn.kn)), xlab = "x", 
    ylab = "f(x)", main = NULL, add = FALSE, verticals = TRUE, 
    do.points = (n < 1000), pch = par("pch"), col = par("col"), 
    col.points = col, cex.points = par("cex"), col.hor = col, 
    col.vert = col, lty = par("lty"), lwd = par("lwd"), ...) 
{
    if (!is.stepfun(x)) {
        if (is.numeric(x)) {
            sarg <- substitute(x)
            x <- ecdf(x)
            attr(x, "call") <- call("ecdf", sarg)
        }
        else stop("'plot.stepfun' called with wrong type of argument 'x'")
    }
    if (missing(main)) 
        main <- {
            cl <- attr(x, "call")
            deparse(if (!is.null(cl)) 
                cl
            else sys.call())
        }
    knF <- knots(x)
    xval <- if (missing(xval)) 
        knF
    else sort(xval)
    if (missing(xlim)) {
        rx <- range(xval)
        dr <- if (length(xval) > 1L) 
            max(0.08 * diff(rx), median(diff(xval)))
        else abs(xval)/16
        xlim <- rx + dr * c(-1, 1)
    }
    else dr <- diff(xlim)
    knF <- knF[xlim[1L] - dr <= knF & knF <= xlim[2L] + dr]
    ti <- c(xlim[1L] - dr, knF, xlim[2L] + dr)
    ti.l <- ti[-length(ti)]
    ti.r <- ti[-1L]
    y <- x(0.5 * (ti.l + ti.r))
    n <- length(y)
    Fn.kn <- x(knF)
    if (add) 
        segments(ti.l, y, ti.r, y, col = col.hor, lty = lty, 
            lwd = lwd, ...)
    else {
        if (missing(ylim)) 
            ylim <- range(c(y, Fn.kn))
        plot(NA, NA, type = "n", xlim = xlim, ylim = ylim, xlab = xlab, 
            ylab = ylab, main = main, ...)
        segments(ti.l, y, ti.r, y, col = col.hor, lty = lty, 
            lwd = lwd)
    }
    if (do.points) 
        points(knF, Fn.kn, pch = pch, col = col.points, cex = cex.points)
    if (verticals) 
        segments(knF, y[-n], knF, y[-1L], col = col.vert, lty = lty, 
            lwd = lwd)
    invisible(list(t = ti, y = y))
}
<environment: namespace:stats>
> print("plot.stl"); if(is.function(try(plot.stl))) {plot.stl;} else{ NULL};
[1] "plot.stl"
NULL
> print("plot.ts"); if(is.function(try(plot.ts))) {plot.ts;} else{ NULL};
[1] "plot.ts"
function (x, y = NULL, plot.type = c("multiple", "single"), xy.labels, 
    xy.lines, panel = lines, nc, yax.flip = FALSE, mar.multi = c(0, 
        5.1, 0, if (yax.flip) 5.1 else 2.1), oma.multi = c(6, 
        0, 5, 0), axes = TRUE, ...) 
{
    plotts <- function(x, y = NULL, plot.type = c("multiple", 
        "single"), xy.labels, xy.lines, panel = lines, nc, xlabel, 
        ylabel, type = "l", xlim = NULL, ylim = NULL, xlab = "Time", 
        ylab, log = "", col = par("col"), bg = NA, pch = par("pch"), 
        cex = par("cex"), lty = par("lty"), lwd = par("lwd"), 
        axes = TRUE, frame.plot = axes, ann = par("ann"), cex.lab = par("cex.lab"), 
        col.lab = par("col.lab"), font.lab = par("font.lab"), 
        cex.axis = par("cex.axis"), col.axis = par("col.axis"), 
        font.axis = par("font.axis"), main = NULL, ...) {
        plot.type <- match.arg(plot.type)
        nser <- NCOL(x)
        if (plot.type == "multiple" && nser > 1) {
            addmain <- function(main, cex.main = par("cex.main"), 
                font.main = par("font.main"), col.main = par("col.main"), 
                ...) mtext(main, side = 3, line = 3, cex = cex.main, 
                font = font.main, col = col.main, ...)
            panel <- match.fun(panel)
            nser <- NCOL(x)
            if (nser > 10) 
                stop("cannot plot more than 10 series as \"multiple\"")
            if (is.null(main)) 
                main <- xlabel
            nm <- colnames(x)
            if (is.null(nm)) 
                nm <- paste("Series", 1L:nser)
            if (missing(nc)) 
                nc <- if (nser > 4) 
                  2
                else 1
            nr <- ceiling(nser/nc)
            oldpar <- par(mar = mar.multi, oma = oma.multi, mfcol = c(nr, 
                nc))
            on.exit(par(oldpar))
            for (i in 1L:nser) {
                plot.default(x[, i], axes = FALSE, xlab = "", 
                  ylab = "", log = log, col = col, bg = bg, pch = pch, 
                  ann = ann, type = "n", ...)
                panel(x[, i], col = col, bg = bg, pch = pch, 
                  type = type, ...)
                if (frame.plot) 
                  box(...)
                y.side <- if (i%%2 || !yax.flip) 
                  2
                else 4
                do.xax <- i%%nr == 0 || i == nser
                if (axes) {
                  axis(y.side, xpd = NA, cex.axis = cex.axis, 
                    col.axis = col.axis, font.axis = font.axis)
                  if (do.xax) 
                    axis(1, xpd = NA, cex.axis = cex.axis, col.axis = col.axis, 
                      font.axis = font.axis)
                }
                if (ann) {
                  mtext(nm[i], y.side, line = 3, cex = cex.lab, 
                    col = col.lab, font = font.lab, ...)
                  if (do.xax) 
                    mtext(xlab, side = 1, line = 3, cex = cex.lab, 
                      col = col.lab, font = font.lab, ...)
                }
            }
            if (ann && !is.null(main)) {
                par(mfcol = c(1, 1))
                addmain(main, ...)
            }
            return(invisible())
        }
        x <- as.ts(x)
        if (!is.null(y)) {
            y <- hasTsp(y)
            if (NCOL(x) > 1 || NCOL(y) > 1) 
                stop("scatter plots only for univariate time series")
            if (is.ts(x) && is.ts(y)) {
                xy <- ts.intersect(x, y)
                xy <- xy.coords(xy[, 1], xy[, 2], xlabel, ylabel, 
                  log)
            }
            else xy <- xy.coords(x, y, xlabel, ylabel, log)
            xlab <- if (missing(xlab)) 
                xy$xlab
            else xlab
            ylab <- if (missing(ylab)) 
                xy$ylab
            else ylab
            xlim <- if (is.null(xlim)) 
                range(xy$x[is.finite(xy$x)])
            else xlim
            ylim <- if (is.null(ylim)) 
                range(xy$y[is.finite(xy$y)])
            else ylim
            n <- length(xy$x)
            if (missing(xy.labels)) 
                xy.labels <- (n <= 150)
            if (!is.logical(xy.labels)) {
                if (!is.character(xy.labels)) 
                  stop("'xy.labels' must be logical or character")
                do.lab <- TRUE
            }
            else do.lab <- xy.labels
            ptype <- if (do.lab) 
                "n"
            else if (missing(type)) 
                "p"
            else type
            plot.default(xy, type = ptype, xlab = xlab, ylab = ylab, 
                xlim = xlim, ylim = ylim, log = log, col = col, 
                bg = bg, pch = pch, axes = axes, frame.plot = frame.plot, 
                ann = ann, main = main, ...)
            if (missing(xy.lines)) 
                xy.lines <- do.lab
            if (do.lab) 
                text(xy, labels = if (is.character(xy.labels)) 
                  xy.labels
                else if (all(tsp(x) == tsp(y))) 
                  formatC(time(x), width = 1)
                else seq_along(xy$x), col = col, cex = cex)
            if (xy.lines) 
                lines(xy, col = col, lty = lty, lwd = lwd, type = if (do.lab) 
                  "c"
                else "l")
            return(invisible())
        }
        if (missing(ylab)) {
            ylab <- colnames(x)
            if (length(ylab) != 1L) 
                ylab <- xlabel
        }
        if (is.matrix(x)) {
            k <- ncol(x)
            tx <- time(x)
            xy <- xy.coords(x = matrix(rep.int(tx, k), ncol = k), 
                y = x, log = log)
            xy$x <- tx
        }
        else xy <- xy.coords(x, NULL, log = log)
        if (is.null(xlim)) 
            xlim <- range(xy$x)
        if (is.null(ylim)) 
            ylim <- range(xy$y[is.finite(xy$y)])
        plot.new()
        plot.window(xlim, ylim, log, ...)
        if (is.matrix(x)) {
            for (i in seq_len(k)) lines.default(xy$x, x[, i], 
                col = col[(i - 1L)%%length(col) + 1L], lty = lty[(i - 
                  1L)%%length(lty) + 1L], lwd = lwd[(i - 1L)%%length(lwd) + 
                  1L], bg = bg[(i - 1L)%%length(bg) + 1L], pch = pch[(i - 
                  1L)%%length(pch) + 1L], type = type)
        }
        else {
            lines.default(xy$x, x, col = col[1L], bg = bg, lty = lty[1L], 
                lwd = lwd[1L], pch = pch[1L], type = type)
        }
        if (ann) 
            title(main = main, xlab = xlab, ylab = ylab, ...)
        if (axes) {
            axis(1, ...)
            axis(2, ...)
        }
        if (frame.plot) 
            box(...)
    }
    xlabel <- if (!missing(x)) 
        deparse(substitute(x))
    ylabel <- if (!missing(y)) 
        deparse(substitute(y))
    plotts(x = x, y = y, plot.type = plot.type, xy.labels = xy.labels, 
        xy.lines = xy.lines, panel = panel, nc = nc, xlabel = xlabel, 
        ylabel = ylabel, axes = axes, ...)
}
<environment: namespace:stats>
> print("poisson.test"); if(is.function(try(poisson.test))) {poisson.test;} else{ NULL};
[1] "poisson.test"
function (x, T = 1, r = 1, alternative = c("two.sided", "less", 
    "greater"), conf.level = 0.95) 
{
    DNAME <- deparse(substitute(x))
    DNAME <- paste(DNAME, "time base:", deparse(substitute(T)))
    if ((l <- length(x)) != length(T)) 
        if (length(T) == 1L) 
            T <- rep(T, l)
        else stop("'x' and 'T' have incompatible length")
    xr <- round(x)
    if (any(!is.finite(x) | (x < 0)) || max(abs(x - xr)) > 1e-07) 
        stop("'x' must be finite, nonnegative, and integer")
    x <- xr
    if (any(is.na(T) | (T < 0))) 
        stop("'T' must be nonnegative")
    if ((k <- length(x)) < 1L) 
        stop("not enough data")
    if (k > 2L) 
        stop("The case k > 2 is unimplemented")
    if (!missing(r) && (length(r) > 1 || is.na(r) || r < 0)) 
        stop("'r' must be a single positive number")
    alternative <- match.arg(alternative)
    if (k == 2) {
        RVAL <- binom.test(x, sum(x), r * T[1L]/(r * T[1L] + 
            T[2L]), alternative = alternative, conf.level = conf.level)
        RVAL$data.name <- DNAME
        RVAL$statistic <- x[1L]
        RVAL$parameter <- sum(x) * r * T[1L]/sum(T * c(1, r))
        names(RVAL$statistic) <- c("count1")
        names(RVAL$parameter) <- c("expected count1")
        RVAL$estimate <- (x[1L]/T[1L])/(x[2L]/T[2L])
        names(RVAL$estimate) <- "rate ratio"
        pp <- RVAL$conf.int
        RVAL$conf.int <- pp/(1 - pp) * T[2L]/T[1L]
        names(r) <- "rate ratio"
        RVAL$null.value <- r
        RVAL$method <- "Comparison of Poisson rates"
        return(RVAL)
    }
    else {
        m <- r * T
        PVAL <- switch(alternative, less = ppois(x, m), greater = ppois(x - 
            1, m, lower.tail = FALSE), two.sided = {
            if (m == 0) (x == 0) else {
                relErr <- 1 + 1e-07
                d <- dpois(x, r * T)
                if (x == m) 1 else if (x < m) {
                  N <- ceiling(2 * m - x)
                  while (dpois(N, m) > d) N <- 2 * N
                  i <- seq.int(from = ceiling(m), to = N)
                  y <- sum(dpois(i, m) <= d * relErr)
                  ppois(x, m) + ppois(N - y, m, lower.tail = FALSE)
                } else {
                  i <- seq.int(from = 0, to = floor(m))
                  y <- sum(dpois(i, m) <= d * relErr)
                  ppois(y - 1, m) + ppois(x - 1, m, lower.tail = FALSE)
                }
            }
        })
        p.L <- function(x, alpha) {
            if (x == 0) 
                0
            else qgamma(alpha, x)
        }
        p.U <- function(x, alpha) qgamma(1 - alpha, x + 1)
        CINT <- switch(alternative, less = c(0, p.U(x, 1 - conf.level)), 
            greater = c(p.L(x, 1 - conf.level), Inf), two.sided = {
                alpha <- (1 - conf.level)/2
                c(p.L(x, alpha), p.U(x, alpha))
            })/T
        attr(CINT, "conf.level") <- conf.level
        ESTIMATE <- x/T
        names(x) <- "number of events"
        names(T) <- "time base"
        names(ESTIMATE) <- names(r) <- "event rate"
        structure(list(statistic = x, parameter = T, p.value = PVAL, 
            conf.int = CINT, estimate = ESTIMATE, null.value = r, 
            alternative = alternative, method = "Exact Poisson test", 
            data.name = DNAME), class = "htest")
    }
}
<environment: namespace:stats>
> print("poly"); if(is.function(try(poly))) {poly;} else{ NULL};
[1] "poly"
function (x, ..., degree = 1, coefs = NULL, raw = FALSE) 
{
    dots <- list(...)
    if (nd <- length(dots)) {
        if (nd == 1 && length(dots[[1L]]) == 1L) 
            degree <- dots[[1L]]
        else return(polym(x, ..., degree = degree, raw = raw))
    }
    if (is.matrix(x)) {
        m <- unclass(as.data.frame(cbind(x, ...)))
        return(do.call("polym", c(m, degree = degree, raw = raw)))
    }
    if (degree < 1) 
        stop("'degree' must be at least 1")
    if (any(is.na(x))) 
        stop("missing values are not allowed in 'poly'")
    n <- degree + 1
    if (raw) {
        if (degree >= length(unique(x))) 
            stop("'degree' must be less than number of unique points")
        Z <- outer(x, 1L:degree, "^")
        colnames(Z) <- 1L:degree
        attr(Z, "degree") <- 1L:degree
        class(Z) <- c("poly", "matrix")
        return(Z)
    }
    if (is.null(coefs)) {
        if (degree >= length(unique(x))) 
            stop("'degree' must be less than number of unique points")
        xbar <- mean(x)
        x <- x - xbar
        X <- outer(x, seq_len(n) - 1, "^")
        QR <- qr(X)
        if (QR$rank < degree) 
            stop("'degree' must be less than number of unique points")
        z <- QR$qr
        z <- z * (row(z) == col(z))
        raw <- qr.qy(QR, z)
        norm2 <- colSums(raw^2)
        alpha <- (colSums(x * raw^2)/norm2 + xbar)[1L:degree]
        Z <- raw/rep(sqrt(norm2), each = length(x))
        colnames(Z) <- 1L:n - 1L
        Z <- Z[, -1, drop = FALSE]
        attr(Z, "degree") <- 1L:degree
        attr(Z, "coefs") <- list(alpha = alpha, norm2 = c(1, 
            norm2))
        class(Z) <- c("poly", "matrix")
    }
    else {
        alpha <- coefs$alpha
        norm2 <- coefs$norm2
        Z <- matrix(, length(x), n)
        Z[, 1] <- 1
        Z[, 2] <- x - alpha[1L]
        if (degree > 1) 
            for (i in 2:degree) Z[, i + 1] <- (x - alpha[i]) * 
                Z[, i] - (norm2[i + 1]/norm2[i]) * Z[, i - 1]
        Z <- Z/rep(sqrt(norm2[-1L]), each = length(x))
        colnames(Z) <- 0:degree
        Z <- Z[, -1, drop = FALSE]
        attr(Z, "degree") <- 1L:degree
        attr(Z, "coefs") <- list(alpha = alpha, norm2 = norm2)
        class(Z) <- c("poly", "matrix")
    }
    Z
}
<environment: namespace:stats>
> print("power"); if(is.function(try(power))) {power;} else{ NULL};
[1] "power"
function (lambda = 1) 
{
    if (!is.numeric(lambda) || is.na(lambda)) 
        stop("invalid argument 'lambda'")
    if (lambda <= 0) 
        return(make.link("log"))
    if (lambda == 1) 
        return(make.link("identity"))
    linkfun <- function(mu) mu^lambda
    linkinv <- function(eta) pmax(eta^(1/lambda), .Machine$double.eps)
    mu.eta <- function(eta) pmax((1/lambda) * eta^(1/lambda - 
        1), .Machine$double.eps)
    valideta <- function(eta) all(eta > 0)
    link <- paste("mu^", round(lambda, 3), sep = "")
    structure(list(linkfun = linkfun, linkinv = linkinv, mu.eta = mu.eta, 
        valideta = valideta, name = link), class = "link-glm")
}
<environment: namespace:stats>
> print("power.anova.test"); if(is.function(try(power.anova.test))) {power.anova.test;} else{ NULL};
[1] "power.anova.test"
function (groups = NULL, n = NULL, between.var = NULL, within.var = NULL, 
    sig.level = 0.05, power = NULL) 
{
    if (sum(sapply(list(groups, n, between.var, within.var, power, 
        sig.level), is.null)) != 1) 
        stop("exactly one of 'groups', 'n', 'between.var', 'within.var', 'power', and 'sig.level' must be NULL")
    if (!is.null(groups) && groups < 2) 
        stop("number of groups must be at least 2")
    if (!is.null(n) && n < 2) 
        stop("number of observations in each group must be at least 2")
    if (!is.null(sig.level) && !is.numeric(sig.level) || any(0 > 
        sig.level | sig.level > 1)) 
        stop("'sig.level' must be numeric in [0, 1]")
    p.body <- quote({
        lambda <- (groups - 1) * n * (between.var/within.var)
        pf(qf(sig.level, groups - 1, (n - 1) * groups, lower.tail = FALSE), 
            groups - 1, (n - 1) * groups, lambda, lower.tail = FALSE)
    })
    if (is.null(power)) 
        power <- eval(p.body)
    else if (is.null(groups)) 
        groups <- uniroot(function(groups) eval(p.body) - power, 
            c(2, 100))$root
    else if (is.null(n)) 
        n <- uniroot(function(n) eval(p.body) - power, c(2, 1e+05))$root
    else if (is.null(within.var)) 
        within.var <- uniroot(function(within.var) eval(p.body) - 
            power, between.var * c(1e-07, 1e+07))$root
    else if (is.null(between.var)) 
        between.var <- uniroot(function(between.var) eval(p.body) - 
            power, within.var * c(1e-07, 1e+07))$root
    else if (is.null(sig.level)) 
        sig.level <- uniroot(function(sig.level) eval(p.body) - 
            power, c(1e-10, 1 - 1e-10))$root
    else stop("internal error")
    NOTE <- "n is number in each group"
    METHOD <- "Balanced one-way analysis of variance power calculation"
    structure(list(groups = groups, n = n, between.var = between.var, 
        within.var = within.var, sig.level = sig.level, power = power, 
        note = NOTE, method = METHOD), class = "power.htest")
}
<environment: namespace:stats>
> print("power.prop.test"); if(is.function(try(power.prop.test))) {power.prop.test;} else{ NULL};
[1] "power.prop.test"
function (n = NULL, p1 = NULL, p2 = NULL, sig.level = 0.05, power = NULL, 
    alternative = c("two.sided", "one.sided"), strict = FALSE) 
{
    if (sum(sapply(list(n, p1, p2, power, sig.level), is.null)) != 
        1) 
        stop("exactly one of 'n', 'p1', 'p2', 'power', and 'sig.level' must be NULL")
    if (!is.null(sig.level) && !is.numeric(sig.level) || any(0 > 
        sig.level | sig.level > 1)) 
        stop("'sig.level' must be numeric in [0, 1]")
    alternative <- match.arg(alternative)
    tside <- switch(alternative, one.sided = 1, two.sided = 2)
    p.body <- quote(pnorm(((sqrt(n) * abs(p1 - p2) - (qnorm(sig.level/tside, 
        lower.tail = FALSE) * sqrt((p1 + p2) * (1 - (p1 + p2)/2))))/sqrt(p1 * 
        (1 - p1) + p2 * (1 - p2)))))
    if (strict & tside == 2) 
        p.body <- quote({
            qu <- qnorm(sig.level/tside, lower.tail = FALSE)
            d <- abs(p1 - p2)
            q1 <- 1 - p1
            q2 <- 1 - p2
            pbar <- (p1 + p2)/2
            qbar <- 1 - pbar
            v1 <- p1 * q1
            v2 <- p2 * q2
            vbar <- pbar * qbar
            pnorm((sqrt(n) * d - qu * sqrt(2 * vbar))/sqrt(v1 + 
                v2)) + pnorm((sqrt(n) * d + qu * sqrt(2 * vbar))/sqrt(v1 + 
                v2), lower.tail = FALSE)
        })
    if (is.null(power)) 
        power <- eval(p.body)
    else if (is.null(n)) 
        n <- uniroot(function(n) eval(p.body) - power, c(1, 1e+07))$root
    else if (is.null(p1)) 
        p1 <- uniroot(function(p1) eval(p.body) - power, c(0, 
            p2))$root
    else if (is.null(p2)) 
        p2 <- uniroot(function(p2) eval(p.body) - power, c(p1, 
            1))$root
    else if (is.null(sig.level)) 
        sig.level <- uniroot(function(sig.level) eval(p.body) - 
            power, c(1e-10, 1 - 1e-10))$root
    else stop("internal error")
    NOTE <- "n is number in *each* group"
    METHOD <- "Two-sample comparison of proportions power calculation"
    structure(list(n = n, p1 = p1, p2 = p2, sig.level = sig.level, 
        power = power, alternative = alternative, note = NOTE, 
        method = METHOD), class = "power.htest")
}
<environment: namespace:stats>
> print("power.t.test"); if(is.function(try(power.t.test))) {power.t.test;} else{ NULL};
[1] "power.t.test"
function (n = NULL, delta = NULL, sd = 1, sig.level = 0.05, power = NULL, 
    type = c("two.sample", "one.sample", "paired"), alternative = c("two.sided", 
        "one.sided"), strict = FALSE) 
{
    if (sum(sapply(list(n, delta, sd, power, sig.level), is.null)) != 
        1) 
        stop("exactly one of 'n', 'delta', 'sd', 'power', and 'sig.level' must be NULL")
    if (!is.null(sig.level) && !is.numeric(sig.level) || any(0 > 
        sig.level | sig.level > 1)) 
        stop("'sig.level' must be numeric in [0, 1]")
    type <- match.arg(type)
    alternative <- match.arg(alternative)
    tsample <- switch(type, one.sample = 1, two.sample = 2, paired = 1)
    tside <- switch(alternative, one.sided = 1, two.sided = 2)
    if (tside == 2 && !is.null(delta)) 
        delta <- abs(delta)
    p.body <- quote({
        nu <- (n - 1) * tsample
        pt(qt(sig.level/tside, nu, lower.tail = FALSE), nu, ncp = sqrt(n/tsample) * 
            delta/sd, lower.tail = FALSE)
    })
    if (strict & tside == 2) 
        p.body <- quote({
            nu <- (n - 1) * tsample
            qu <- qt(sig.level/tside, nu, lower.tail = FALSE)
            pt(qu, nu, ncp = sqrt(n/tsample) * delta/sd, lower.tail = FALSE) + 
                pt(-qu, nu, ncp = sqrt(n/tsample) * delta/sd, 
                  lower.tail = TRUE)
        })
    if (is.null(power)) 
        power <- eval(p.body)
    else if (is.null(n)) 
        n <- uniroot(function(n) eval(p.body) - power, c(2, 1e+07))$root
    else if (is.null(sd)) 
        sd <- uniroot(function(sd) eval(p.body) - power, delta * 
            c(1e-07, 1e+07))$root
    else if (is.null(delta)) 
        delta <- uniroot(function(delta) eval(p.body) - power, 
            sd * c(1e-07, 1e+07))$root
    else if (is.null(sig.level)) 
        sig.level <- uniroot(function(sig.level) eval(p.body) - 
            power, c(1e-10, 1 - 1e-10))$root
    else stop("internal error")
    NOTE <- switch(type, paired = "n is number of *pairs*, sd is std.dev. of *differences* within pairs", 
        two.sample = "n is number in *each* group", NULL)
    METHOD <- paste(switch(type, one.sample = "One-sample", two.sample = "Two-sample", 
        paired = "Paired"), "t test power calculation")
    structure(list(n = n, delta = delta, sd = sd, sig.level = sig.level, 
        power = power, alternative = alternative, note = NOTE, 
        method = METHOD), class = "power.htest")
}
<environment: namespace:stats>
> print("ppoints"); if(is.function(try(ppoints))) {ppoints;} else{ NULL};
[1] "ppoints"
function (n, a = ifelse(n <= 10, 3/8, 1/2)) 
{
    if (length(n) > 1L) 
        n <- length(n)
    if (n > 0) 
        (1L:n - a)/(n + 1 - 2 * a)
    else numeric()
}
<environment: namespace:stats>
> print("ppr"); if(is.function(try(ppr))) {ppr;} else{ NULL};
[1] "ppr"
function (x, ...) 
UseMethod("ppr")
<environment: namespace:stats>
> print("prcomp"); if(is.function(try(prcomp))) {prcomp;} else{ NULL};
[1] "prcomp"
function (x, ...) 
UseMethod("prcomp")
<environment: namespace:stats>
> print("predict"); if(is.function(try(predict))) {predict;} else{ NULL};
[1] "predict"
function (object, ...) 
UseMethod("predict")
<environment: namespace:stats>
> print("predict.Arima"); if(is.function(try(predict.Arima))) {predict.Arima;} else{ NULL};
[1] "predict.Arima"
NULL
> print("predict.HoltWinters"); if(is.function(try(predict.HoltWinters))) {predict.HoltWinters;} else{ NULL};
[1] "predict.HoltWinters"
NULL
> print("predict.glm"); if(is.function(try(predict.glm))) {predict.glm;} else{ NULL};
[1] "predict.glm"
function (object, newdata = NULL, type = c("link", "response", 
    "terms"), se.fit = FALSE, dispersion = NULL, terms = NULL, 
    na.action = na.pass, ...) 
{
    type <- match.arg(type)
    na.act <- object$na.action
    object$na.action <- NULL
    if (!se.fit) {
        if (missing(newdata)) {
            pred <- switch(type, link = object$linear.predictors, 
                response = object$fitted.values, terms = predict.lm(object, 
                  se.fit = se.fit, scale = 1, type = "terms", 
                  terms = terms))
            if (!is.null(na.act)) 
                pred <- napredict(na.act, pred)
        }
        else {
            pred <- predict.lm(object, newdata, se.fit, scale = 1, 
                type = ifelse(type == "link", "response", type), 
                terms = terms, na.action = na.action)
            switch(type, response = {
                pred <- family(object)$linkinv(pred)
            }, link = , terms = )
        }
    }
    else {
        if (inherits(object, "survreg")) 
            dispersion <- 1
        if (is.null(dispersion) || dispersion == 0) 
            dispersion <- summary(object, dispersion = dispersion)$dispersion
        residual.scale <- as.vector(sqrt(dispersion))
        pred <- predict.lm(object, newdata, se.fit, scale = residual.scale, 
            type = ifelse(type == "link", "response", type), 
            terms = terms, na.action = na.action)
        fit <- pred$fit
        se.fit <- pred$se.fit
        switch(type, response = {
            se.fit <- se.fit * abs(family(object)$mu.eta(fit))
            fit <- family(object)$linkinv(fit)
        }, link = , terms = )
        if (missing(newdata) && !is.null(na.act)) {
            fit <- napredict(na.act, fit)
            se.fit <- napredict(na.act, se.fit)
        }
        pred <- list(fit = fit, se.fit = se.fit, residual.scale = residual.scale)
    }
    pred
}
<environment: namespace:stats>
> print("predict.lm"); if(is.function(try(predict.lm))) {predict.lm;} else{ NULL};
[1] "predict.lm"
function (object, newdata, se.fit = FALSE, scale = NULL, df = Inf, 
    interval = c("none", "confidence", "prediction"), level = 0.95, 
    type = c("response", "terms"), terms = NULL, na.action = na.pass, 
    pred.var = res.var/weights, weights = 1, ...) 
{
    tt <- terms(object)
    if (!inherits(object, "lm")) 
        warning("calling predict.lm(<fake-lm-object>) ...")
    if (missing(newdata) || is.null(newdata)) {
        mm <- X <- model.matrix(object)
        mmDone <- TRUE
        offset <- object$offset
    }
    else {
        Terms <- delete.response(tt)
        m <- model.frame(Terms, newdata, na.action = na.action, 
            xlev = object$xlevels)
        if (!is.null(cl <- attr(Terms, "dataClasses"))) 
            .checkMFClasses(cl, m)
        X <- model.matrix(Terms, m, contrasts.arg = object$contrasts)
        offset <- rep(0, nrow(X))
        if (!is.null(off.num <- attr(tt, "offset"))) 
            for (i in off.num) offset <- offset + eval(attr(tt, 
                "variables")[[i + 1]], newdata)
        if (!is.null(object$call$offset)) 
            offset <- offset + eval(object$call$offset, newdata)
        mmDone <- FALSE
    }
    n <- length(object$residuals)
    p <- object$rank
    p1 <- seq_len(p)
    piv <- if (p) 
        qr.lm(object)$pivot[p1]
    if (p < ncol(X) && !(missing(newdata) || is.null(newdata))) 
        warning("prediction from a rank-deficient fit may be misleading")
    beta <- object$coefficients
    predictor <- drop(X[, piv, drop = FALSE] %*% beta[piv])
    if (!is.null(offset)) 
        predictor <- predictor + offset
    interval <- match.arg(interval)
    if (interval == "prediction") {
        if (missing(newdata)) 
            warning("Predictions on current data refer to _future_ responses\n")
        if (missing(newdata) && missing(weights)) {
            w <- weights.default(object)
            if (!is.null(w)) {
                weights <- w
                warning("Assuming prediction variance inversely proportional to weights used for fitting\n")
            }
        }
        if (!missing(newdata) && missing(weights) && !is.null(object$weights) && 
            missing(pred.var)) 
            warning("Assuming constant prediction variance even though model fit is weighted\n")
        if (inherits(weights, "formula")) {
            if (length(weights) != 2L) 
                stop("'weights' as formula should be one-sided")
            d <- if (missing(newdata) || is.null(newdata)) 
                model.frame(object)
            else newdata
            weights <- eval(weights[[2L]], d, environment(weights))
        }
    }
    type <- match.arg(type)
    if (se.fit || interval != "none") {
        res.var <- if (is.null(scale)) {
            r <- object$residuals
            w <- object$weights
            rss <- sum(if (is.null(w)) r^2 else r^2 * w)
            df <- object$df.residual
            rss/df
        }
        else scale^2
        if (type != "terms") {
            if (p > 0) {
                XRinv <- if (missing(newdata) && is.null(w)) 
                  qr.Q(qr.lm(object))[, p1, drop = FALSE]
                else X[, piv] %*% qr.solve(qr.R(qr.lm(object))[p1, 
                  p1])
                ip <- drop(XRinv^2 %*% rep(res.var, p))
            }
            else ip <- rep(0, n)
        }
    }
    if (type == "terms") {
        if (!mmDone) {
            mm <- model.matrix(object)
            mmDone <- TRUE
        }
        aa <- attr(mm, "assign")
        ll <- attr(tt, "term.labels")
        hasintercept <- attr(tt, "intercept") > 0L
        if (hasintercept) 
            ll <- c("(Intercept)", ll)
        aaa <- factor(aa, labels = ll)
        asgn <- split(order(aa), aaa)
        if (hasintercept) {
            asgn$"(Intercept)" <- NULL
            if (!mmDone) {
                mm <- model.matrix(object)
                mmDone <- TRUE
            }
            avx <- colMeans(mm)
            termsconst <- sum(avx[piv] * beta[piv])
        }
        nterms <- length(asgn)
        if (nterms > 0) {
            predictor <- matrix(ncol = nterms, nrow = NROW(X))
            dimnames(predictor) <- list(rownames(X), names(asgn))
            if (se.fit || interval != "none") {
                ip <- matrix(ncol = nterms, nrow = NROW(X))
                dimnames(ip) <- list(rownames(X), names(asgn))
                Rinv <- qr.solve(qr.R(qr.lm(object))[p1, p1])
            }
            if (hasintercept) 
                X <- sweep(X, 2L, avx, check.margin = FALSE)
            unpiv <- rep.int(0L, NCOL(X))
            unpiv[piv] <- p1
            for (i in seq.int(1L, nterms, length.out = nterms)) {
                iipiv <- asgn[[i]]
                ii <- unpiv[iipiv]
                iipiv[ii == 0L] <- 0L
                predictor[, i] <- if (any(iipiv > 0L)) 
                  X[, iipiv, drop = FALSE] %*% beta[iipiv]
                else 0
                if (se.fit || interval != "none") 
                  ip[, i] <- if (any(iipiv > 0L)) 
                    as.matrix(X[, iipiv, drop = FALSE] %*% Rinv[ii, 
                      , drop = FALSE])^2 %*% rep.int(res.var, 
                      p)
                  else 0
            }
            if (!is.null(terms)) {
                predictor <- predictor[, terms, drop = FALSE]
                if (se.fit) 
                  ip <- ip[, terms, drop = FALSE]
            }
        }
        else {
            predictor <- ip <- matrix(0, n, 0L)
        }
        attr(predictor, "constant") <- if (hasintercept) 
            termsconst
        else 0
    }
    if (interval != "none") {
        tfrac <- qt((1 - level)/2, df)
        hwid <- tfrac * switch(interval, confidence = sqrt(ip), 
            prediction = sqrt(ip + pred.var))
        if (type != "terms") {
            predictor <- cbind(predictor, predictor + hwid %o% 
                c(1, -1))
            colnames(predictor) <- c("fit", "lwr", "upr")
        }
        else {
            if (!is.null(terms)) 
                hwid <- hwid[, terms, drop = FALSE]
            lwr <- predictor + hwid
            upr <- predictor - hwid
        }
    }
    if (se.fit || interval != "none") {
        se <- sqrt(ip)
        if (type == "terms" && !is.null(terms)) 
            se <- se[, terms, drop = FALSE]
    }
    if (missing(newdata) && !is.null(na.act <- object$na.action)) {
        predictor <- napredict(na.act, predictor)
        if (se.fit) 
            se <- napredict(na.act, se)
    }
    if (type == "terms" && interval != "none") {
        if (missing(newdata) && !is.null(na.act)) {
            lwr <- napredict(na.act, lwr)
            upr <- napredict(na.act, upr)
        }
        list(fit = predictor, se.fit = se, lwr = lwr, upr = upr, 
            df = df, residual.scale = sqrt(res.var))
    }
    else if (se.fit) 
        list(fit = predictor, se.fit = se, df = df, residual.scale = sqrt(res.var))
    else predictor
}
<environment: namespace:stats>
> print("predict.loess"); if(is.function(try(predict.loess))) {predict.loess;} else{ NULL};
[1] "predict.loess"
NULL
> print("predict.nls"); if(is.function(try(predict.nls))) {predict.nls;} else{ NULL};
[1] "predict.nls"
NULL
> print("predict.smooth.spline"); if(is.function(try(predict.smooth.spline))) {predict.smooth.spline;} else{ NULL};
[1] "predict.smooth.spline"
NULL
> print("preplot"); if(is.function(try(preplot))) {preplot;} else{ NULL};
[1] "preplot"
function (object, ...) 
UseMethod("preplot")
<environment: namespace:stats>
> print("princomp"); if(is.function(try(princomp))) {princomp;} else{ NULL};
[1] "princomp"
function (x, ...) 
UseMethod("princomp")
<environment: namespace:stats>
> print("print.power.htest"); if(is.function(try(print.power.htest))) {print.power.htest;} else{ NULL};
[1] "print.power.htest"
NULL
> print("print.ts"); if(is.function(try(print.ts))) {print.ts;} else{ NULL};
[1] "print.ts"
function (x, calendar, ...) 
{
    x.orig <- x
    x <- as.ts(x)
    fr.x <- frequency(x)
    if (missing(calendar)) 
        calendar <- any(fr.x == c(4, 12)) && length(start(x)) == 
            2L
    Tsp <- tsp(x)
    if (is.null(Tsp)) {
        warning("series is corrupt, with no 'tsp' attribute")
        print(unclass(x))
        return(invisible(x))
    }
    nn <- 1 + round((Tsp[2L] - Tsp[1L]) * Tsp[3L])
    if (NROW(x) != nn) {
        warning(gettextf("series is corrupt: length %d with 'tsp' implying %d", 
            NROW(x), nn), domain = NA, call. = FALSE)
        calendar <- FALSE
    }
    if (!calendar) 
        header <- function(x) {
            if ((fr.x <- frequency(x)) != 1) 
                cat("Time Series:\nStart =", deparse(start(x)), 
                  "\nEnd =", deparse(end(x)), "\nFrequency =", 
                  deparse(fr.x), "\n")
            else cat("Time Series:\nStart =", format(tsp(x)[1L]), 
                "\nEnd =", format(tsp(x)[2L]), "\nFrequency =", 
                deparse(fr.x), "\n")
        }
    if (NCOL(x) == 1) {
        if (calendar) {
            if (fr.x > 1) {
                dn2 <- if (fr.x == 12) 
                  month.abb
                else if (fr.x == 4) {
                  c("Qtr1", "Qtr2", "Qtr3", "Qtr4")
                }
                else paste("p", 1L:fr.x, sep = "")
                if (NROW(x) <= fr.x && start(x)[1L] == end(x)[1L]) {
                  dn1 <- start(x)[1L]
                  dn2 <- dn2[1 + (start(x)[2L] - 2 + seq_along(x))%%fr.x]
                  x <- matrix(format(x, ...), nrow = 1L, byrow = TRUE, 
                    dimnames = list(dn1, dn2))
                }
                else {
                  start.pad <- start(x)[2L] - 1
                  end.pad <- fr.x - end(x)[2L]
                  dn1 <- start(x)[1L]:end(x)[1L]
                  x <- matrix(c(rep.int("", start.pad), format(x, 
                    ...), rep.int("", end.pad)), ncol = fr.x, 
                    byrow = TRUE, dimnames = list(dn1, dn2))
                }
            }
            else {
                tx <- time(x)
                attributes(x) <- NULL
                names(x) <- tx
            }
        }
        else {
            header(x)
            attr(x, "class") <- attr(x, "tsp") <- attr(x, "na.action") <- NULL
        }
    }
    else {
        if (calendar && fr.x > 1) {
            tm <- time(x)
            t2 <- 1 + round(fr.x * ((tm + 0.001)%%1))
            p1 <- format(floor(zapsmall(tm)))
            rownames(x) <- if (fr.x == 12) 
                paste(month.abb[t2], p1, sep = " ")
            else paste(p1, if (fr.x == 4) 
                c("Q1", "Q2", "Q3", "Q4")[t2]
            else format(t2), sep = " ")
        }
        else {
            if (!calendar) 
                header(x)
            rownames(x) <- format(time(x))
        }
        attr(x, "class") <- attr(x, "tsp") <- attr(x, "na.action") <- NULL
    }
    NextMethod("print", x, quote = FALSE, right = TRUE, ...)
    invisible(x.orig)
}
<environment: namespace:stats>
> print("printCoefmat"); if(is.function(try(printCoefmat))) {printCoefmat;} else{ NULL};
[1] "printCoefmat"
function (x, digits = max(3, getOption("digits") - 2), signif.stars = getOption("show.signif.stars"), 
    signif.legend = signif.stars, dig.tst = max(1, min(5, digits - 
        1)), cs.ind = 1:k, tst.ind = k + 1, zap.ind = integer(0), 
    P.values = NULL, has.Pvalue = nc >= 4 && substr(colnames(x)[nc], 
        1, 3) == "Pr(", eps.Pvalue = .Machine$double.eps, na.print = "NA", 
    ...) 
{
    if (is.null(d <- dim(x)) || length(d) != 2L) 
        stop("'x' must be coefficient matrix/data frame")
    nc <- d[2L]
    if (is.null(P.values)) {
        scp <- getOption("show.coef.Pvalues")
        if (!is.logical(scp) || is.na(scp)) {
            warning("option \"show.coef.Pvalues\" is invalid: assuming TRUE")
            scp <- TRUE
        }
        P.values <- has.Pvalue && scp
    }
    else if (P.values && !has.Pvalue) 
        stop("'P.values' is TRUE, but 'has.Pvalue' is not")
    if (has.Pvalue && !P.values) {
        d <- dim(xm <- data.matrix(x[, -nc, drop = FALSE]))
        nc <- nc - 1
        has.Pvalue <- FALSE
    }
    else xm <- data.matrix(x)
    k <- nc - has.Pvalue - (if (missing(tst.ind)) 
        1
    else length(tst.ind))
    if (!missing(cs.ind) && length(cs.ind) > k) 
        stop("wrong k / cs.ind")
    Cf <- array("", dim = d, dimnames = dimnames(xm))
    ok <- !(ina <- is.na(xm))
    for (i in zap.ind) xm[, i] <- zapsmall(xm[, i], digits)
    if (length(cs.ind)) {
        acs <- abs(coef.se <- xm[, cs.ind, drop = FALSE])
        if (any(ia <- is.finite(acs))) {
            digmin <- 1 + if (length(acs <- acs[ia & acs != 0])) 
                floor(log10(range(acs[acs != 0], finite = TRUE)))
            else 0
            Cf[, cs.ind] <- format(round(coef.se, max(1, digits - 
                digmin)), digits = digits)
        }
    }
    if (length(tst.ind)) 
        Cf[, tst.ind] <- format(round(xm[, tst.ind], digits = dig.tst), 
            digits = digits)
    if (any(r.ind <- !((1L:nc) %in% c(cs.ind, tst.ind, if (has.Pvalue) nc)))) 
        for (i in which(r.ind)) Cf[, i] <- format(xm[, i], digits = digits)
    ok[, tst.ind] <- FALSE
    okP <- if (has.Pvalue) 
        ok[, -nc]
    else ok
    x1 <- Cf[okP]
    dec <- getOption("OutDec")
    if (dec != ".") 
        x1 <- chartr(dec, ".", x1)
    x0 <- (xm[okP] == 0) != (as.numeric(x1) == 0)
    if (length(not.both.0 <- which(x0 & !is.na(x0)))) {
        Cf[okP][not.both.0] <- format(xm[okP][not.both.0], digits = max(1, 
            digits - 1))
    }
    if (any(ina)) 
        Cf[ina] <- na.print
    if (P.values) {
        if (!is.logical(signif.stars) || is.na(signif.stars)) {
            warning("option \"show.signif.stars\" is invalid: assuming TRUE")
            signif.stars <- TRUE
        }
        if (any(okP <- ok[, nc])) {
            pv <- as.vector(xm[, nc])
            Cf[okP, nc] <- format.pval(pv[okP], digits = dig.tst, 
                eps = eps.Pvalue)
            signif.stars <- signif.stars && any(pv[okP] < 0.1)
            if (signif.stars) {
                Signif <- symnum(pv, corr = FALSE, na = FALSE, 
                  cutpoints = c(0, 0.001, 0.01, 0.05, 0.1, 1), 
                  symbols = c("***", "**", "*", ".", " "))
                Cf <- cbind(Cf, format(Signif))
            }
        }
        else signif.stars <- FALSE
    }
    else signif.stars <- FALSE
    print.default(Cf, quote = FALSE, right = TRUE, na.print = na.print, 
        ...)
    if (signif.stars && signif.legend) 
        cat("---\nSignif. codes: ", attr(Signif, "legend"), "\n")
    invisible(x)
}
<environment: namespace:stats>
> print("profile"); if(is.function(try(profile))) {profile;} else{ NULL};
[1] "profile"
function (fitted, ...) 
UseMethod("profile")
<environment: namespace:stats>
> print("profile.nls"); if(is.function(try(profile.nls))) {profile.nls;} else{ NULL};
[1] "profile.nls"
NULL
> print("proj"); if(is.function(try(proj))) {proj;} else{ NULL};
[1] "proj"
function (object, ...) 
UseMethod("proj")
<environment: namespace:stats>
> print("prop.test"); if(is.function(try(prop.test))) {prop.test;} else{ NULL};
[1] "prop.test"
function (x, n, p = NULL, alternative = c("two.sided", "less", 
    "greater"), conf.level = 0.95, correct = TRUE) 
{
    DNAME <- deparse(substitute(x))
    if (is.table(x) && length(dim(x)) == 1L) {
        if (dim(x) != 2L) 
            stop("table 'x' should have 2 entries")
        l <- 1
        n <- sum(x)
        x <- x[1L]
    }
    else if (is.matrix(x)) {
        if (ncol(x) != 2L) 
            stop("'x' must have 2 columns")
        l <- nrow(x)
        n <- rowSums(x)
        x <- x[, 1L]
    }
    else {
        DNAME <- paste(DNAME, "out of", deparse(substitute(n)))
        if ((l <- length(x)) != length(n)) 
            stop("'x' and 'n' must have the same length")
    }
    OK <- complete.cases(x, n)
    x <- x[OK]
    n <- n[OK]
    if ((k <- length(x)) < 1L) 
        stop("not enough data")
    if (any(n <= 0)) 
        stop("elements of 'n' must be positive")
    if (any(x < 0)) 
        stop("elements of 'x' must be nonnegative")
    if (any(x > n)) 
        stop("elements of 'x' must not be greater than those of 'n'")
    if (is.null(p) && (k == 1)) 
        p <- 0.5
    if (!is.null(p)) {
        DNAME <- paste(DNAME, ", null ", ifelse(k == 1, "probability ", 
            "probabilities "), deparse(substitute(p)), sep = "")
        if (length(p) != l) 
            stop("'p' must have the same length as 'x' and 'n'")
        p <- p[OK]
        if (any((p <= 0) | (p >= 1))) 
            stop("elements of 'p' must be in (0,1)")
    }
    alternative <- match.arg(alternative)
    if (k > 2 || (k == 2) && !is.null(p)) 
        alternative <- "two.sided"
    if ((length(conf.level) != 1L) || is.na(conf.level) || (conf.level <= 
        0) || (conf.level >= 1)) 
        stop("'conf.level' must be a single number between 0 and 1")
    correct <- as.logical(correct)
    ESTIMATE <- x/n
    names(ESTIMATE) <- if (k == 1) 
        "p"
    else paste("prop", 1L:l)[OK]
    NVAL <- p
    CINT <- NULL
    YATES <- ifelse(correct && (k <= 2), 0.5, 0)
    if (k == 1) {
        z <- ifelse(alternative == "two.sided", qnorm((1 + conf.level)/2), 
            qnorm(conf.level))
        YATES <- min(YATES, abs(x - n * p))
        z22n <- z^2/(2 * n)
        p.c <- ESTIMATE + YATES/n
        p.u <- if (p.c >= 1) 
            1
        else (p.c + z22n + z * sqrt(p.c * (1 - p.c)/n + z22n/(2 * 
            n)))/(1 + 2 * z22n)
        p.c <- ESTIMATE - YATES/n
        p.l <- if (p.c <= 0) 
            0
        else (p.c + z22n - z * sqrt(p.c * (1 - p.c)/n + z22n/(2 * 
            n)))/(1 + 2 * z22n)
        CINT <- switch(alternative, two.sided = c(max(p.l, 0), 
            min(p.u, 1)), greater = c(max(p.l, 0), 1), less = c(0, 
            min(p.u, 1)))
    }
    else if ((k == 2) & is.null(p)) {
        DELTA <- ESTIMATE[1L] - ESTIMATE[2L]
        YATES <- min(YATES, abs(DELTA)/sum(1/n))
        WIDTH <- (switch(alternative, two.sided = qnorm((1 + 
            conf.level)/2), qnorm(conf.level)) * sqrt(sum(ESTIMATE * 
            (1 - ESTIMATE)/n)) + YATES * sum(1/n))
        CINT <- switch(alternative, two.sided = c(max(DELTA - 
            WIDTH, -1), min(DELTA + WIDTH, 1)), greater = c(max(DELTA - 
            WIDTH, -1), 1), less = c(-1, min(DELTA + WIDTH, 1)))
    }
    if (!is.null(CINT)) 
        attr(CINT, "conf.level") <- conf.level
    METHOD <- paste(ifelse(k == 1, "1-sample proportions test", 
        paste(k, "-sample test for ", ifelse(is.null(p), "equality of", 
            "given"), " proportions", sep = "")), ifelse(YATES, 
        "with", "without"), "continuity correction")
    if (is.null(p)) {
        p <- sum(x)/sum(n)
        PARAMETER <- k - 1
    }
    else {
        PARAMETER <- k
        names(NVAL) <- names(ESTIMATE)
    }
    names(PARAMETER) <- "df"
    x <- cbind(x, n - x)
    E <- cbind(n * p, n * (1 - p))
    if (any(E < 5)) 
        warning("Chi-squared approximation may be incorrect")
    STATISTIC <- sum((abs(x - E) - YATES)^2/E)
    names(STATISTIC) <- "X-squared"
    if (alternative == "two.sided") 
        PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
    else {
        if (k == 1) 
            z <- sign(ESTIMATE - p) * sqrt(STATISTIC)
        else z <- sign(DELTA) * sqrt(STATISTIC)
        PVAL <- pnorm(z, lower.tail = (alternative == "less"))
    }
    RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, 
        p.value = as.numeric(PVAL), estimate = ESTIMATE, null.value = NVAL, 
        conf.int = CINT, alternative = alternative, method = METHOD, 
        data.name = DNAME)
    class(RVAL) <- "htest"
    return(RVAL)
}
<environment: namespace:stats>
> print("prop.trend.test"); if(is.function(try(prop.trend.test))) {prop.trend.test;} else{ NULL};
[1] "prop.trend.test"
function (x, n, score = seq_along(x)) 
{
    method <- "Chi-squared Test for Trend in Proportions"
    dname <- paste(deparse(substitute(x)), "out of", deparse(substitute(n)))
    dname <- paste(dname, ",\n using scores:", paste(score, collapse = " "))
    x <- as.vector(x)
    n <- as.vector(n)
    score <- as.vector(score)
    freq <- x/n
    p <- sum(x)/sum(n)
    w <- n/p/(1 - p)
    a <- anova(lm(freq ~ score, weights = w))
    chisq <- a["score", "Sum Sq"]
    names(chisq) <- "X-squared"
    df <- c(df = 1)
    pval <- pchisq(chisq, 1, lower.tail = FALSE)
    rval <- list(statistic = chisq, parameter = df, p.value = as.numeric(pval), 
        method = method, data.name = dname)
    class(rval) <- "htest"
    return(rval)
}
<environment: namespace:stats>
> print("qbirthday"); if(is.function(try(qbirthday))) {qbirthday;} else{ NULL};
[1] "qbirthday"
function (prob = 0.5, classes = 365, coincident = 2) 
{
    k <- coincident
    c <- classes
    p <- prob
    if (p <= 0) 
        return(1)
    if (p >= 1) 
        return(c * (k - 1) + 1)
    N <- exp(((k - 1) * log(c) + lgamma(k + 1) + log(-log1p(-p)))/k)
    N <- ceiling(N)
    if (pbirthday(N, c, k) < prob) {
        N <- N + 1
        while (pbirthday(N, c, k) < prob) N <- N + 1
    }
    else if (pbirthday(N - 1, c, k) >= prob) {
        N <- N - 1
        while (pbirthday(N - 1, c, k) >= prob) N <- N - 1
    }
    N
}
<environment: namespace:stats>
> print("qqnorm"); if(is.function(try(qqnorm))) {qqnorm;} else{ NULL};
[1] "qqnorm"
function (y, ...) 
UseMethod("qqnorm")
<environment: namespace:stats>
> print("quade.test"); if(is.function(try(quade.test))) {quade.test;} else{ NULL};
[1] "quade.test"
function (y, ...) 
UseMethod("quade.test")
<environment: namespace:stats>
> print("quantile"); if(is.function(try(quantile))) {quantile;} else{ NULL};
[1] "quantile"
function (x, ...) 
UseMethod("quantile")
<environment: namespace:stats>
> print("r2dtable"); if(is.function(try(r2dtable))) {r2dtable;} else{ NULL};
[1] "r2dtable"
function (n, r, c) 
{
    if (length(n) == 0L || (n < 0) || is.na(n)) 
        stop("invalid argument 'n'")
    if ((length(r) <= 1L) || any(r < 0) || any(is.na(r))) 
        stop("invalid argument 'r'")
    if ((length(c) <= 1L) || any(c < 0) || any(is.na(c))) 
        stop("invalid argument 'c'")
    if (sum(r) != sum(c)) 
        stop("arguments 'r' and 'c' must have the same sums")
    .Call("R_r2dtable", as.integer(n), as.integer(r), as.integer(c), 
        PACKAGE = "base")
}
<environment: namespace:stats>
> print("read.ftable"); if(is.function(try(read.ftable))) {read.ftable;} else{ NULL};
[1] "read.ftable"
function (file, sep = "", quote = "\"", row.var.names, col.vars, 
    skip = 0) 
{
    if (is.character(file)) {
        file <- file(file, "r")
        on.exit(close(file))
    }
    if (!inherits(file, "connection")) 
        stop("'file' must be a character string or connection")
    if (!isSeekable(file)) {
        tmpf <- tempfile()
        cat(readLines(file), file = tmpf, sep = "\n")
        file <- file(tmpf, "r")
        on.exit({
            close(file)
            unlink(tmpf)
        }, add = TRUE)
    }
    z <- utils::count.fields(file, sep, quote, skip)
    n.row.vars <- z[max(which(z == max(z)))] - z[length(z)] + 
        1
    seek(file, where = 0)
    if (skip > 0) 
        readLines(file, skip)
    lines <- readLines(file)
    seek(file, where = 0)
    if (skip > 0) 
        readLines(file, skip)
    i <- which(z == n.row.vars)
    j <- i[grep("^[^[:space:]]", lines[i])]
    if ((length(j) == 1L) && (j > 1)) {
        n.col.vars <- j - 1
        col.vars <- vector("list", length = n.col.vars)
        n <- c(1, z[1:n.col.vars] - 1)
        for (k in seq.int(from = 1, to = n.col.vars)) {
            s <- scan(file, what = "", sep = sep, quote = quote, 
                nlines = 1, quiet = TRUE)
            col.vars[[k]] <- s[-1L]
            names(col.vars)[k] <- s[1L]
        }
        row.vars <- vector("list", length = n.row.vars)
        names(row.vars) <- scan(file, what = "", sep = sep, quote = quote, 
            nlines = 1, quiet = TRUE)
        z <- z[-(1:(n.col.vars + 1))]
    }
    else {
        if ((z[1L] == 1) && z[2L] == max(z)) {
            n.col.vars <- 1
            col.vars <- vector("list", length = n.col.vars)
            s <- scan(file, what = "", sep = sep, quote = quote, 
                nlines = 2, quiet = TRUE)
            names(col.vars) <- s[1L]
            s <- s[-1L]
            row.vars <- vector("list", length = n.row.vars)
            i <- 1:n.row.vars
            names(row.vars) <- s[i]
            col.vars[[1L]] <- s[-i]
            z <- z[-(1:2)]
        }
        else {
            if (missing(row.var.names)) {
                stop("'row.var.names' missing")
            }
            n.row.vars <- length(row.var.names)
            row.vars <- vector("list", length = n.row.vars)
            names(row.vars) <- as.character(row.var.names)
            if (missing(col.vars) || !is.list(col.vars)) {
                stop("'col.vars' missing or incorrect")
            }
            col.vars <- lapply(col.vars, as.character)
            n.col.vars <- length(col.vars)
            if (is.null(names(col.vars))) 
                names(col.vars) <- paste("Factor", seq_along(col.vars), 
                  sep = ".")
            else {
                nam <- names(col.vars)
                ind <- which(!nzchar(nam))
                names(col.vars)[ind] <- paste("Factor", ind, 
                  sep = ".")
            }
        }
    }
    p <- 1
    n <- integer(n.row.vars)
    for (k in seq.int(from = 1, to = n.row.vars)) {
        n[k] <- sum(z >= max(z) - k + 1)/p
        p <- p * n[k]
    }
    is.row.lab <- rep(rep(c(TRUE, FALSE), length(z)), c(rbind(z - 
        min(z) + 1, min(z) - 1)))
    s <- scan(file, what = "", sep = sep, quote = quote, quiet = TRUE)
    values <- as.numeric(s[!is.row.lab])
    tmp <- s[is.row.lab]
    len <- length(tmp)
    for (k in seq.int(from = 1, to = n.row.vars)) {
        i <- seq.int(from = 1, to = len, by = len/n[k])
        row.vars[[k]] <- unique(tmp[i])
        tmp <- tmp[seq.int(from = 2, to = len/n[k])]
        len <- length(tmp)
    }
    values <- matrix(values, nrow = prod(sapply(row.vars, length)), 
        ncol = prod(sapply(col.vars, length)), byrow = TRUE)
    structure(values, row.vars = row.vars, col.vars = col.vars, 
        class = "ftable")
}
<environment: namespace:stats>
> print("rect.hclust"); if(is.function(try(rect.hclust))) {rect.hclust;} else{ NULL};
[1] "rect.hclust"
function (tree, k = NULL, which = NULL, x = NULL, h = NULL, border = 2, 
    cluster = NULL) 
{
    if (length(h) > 1L | length(k) > 1L) 
        stop("'k' and 'h' must be a scalar")
    if (!is.null(h)) {
        if (!is.null(k)) 
            stop("specify exactly one of 'k' and 'h'")
        k <- min(which(rev(tree$height) < h))
        k <- max(k, 2)
    }
    else if (is.null(k)) 
        stop("specify exactly one of 'k' and 'h'")
    if (k < 2 | k > length(tree$height)) 
        stop(gettextf("k must be between 2 and %d", length(tree$height)), 
            domain = NA)
    if (is.null(cluster)) 
        cluster <- cutree(tree, k = k)
    clustab <- table(cluster)[unique(cluster[tree$order])]
    m <- c(0, cumsum(clustab))
    if (!is.null(x)) {
        if (!is.null(which)) 
            stop("specify exactly one of 'which' and 'x'")
        which <- x
        for (n in seq_along(x)) which[n] <- max(which(m < x[n]))
    }
    else if (is.null(which)) 
        which <- 1L:k
    if (any(which > k)) 
        stop(gettextf("all elements of 'which' must be between 1 and %d", 
            k), domain = NA)
    border <- rep(border, length.out = length(which))
    retval <- list()
    for (n in seq_along(which)) {
        rect(m[which[n]] + 0.66, par("usr")[3L], m[which[n] + 
            1] + 0.33, mean(rev(tree$height)[(k - 1):k]), border = border[n])
        retval[[n]] <- which(cluster == as.integer(names(clustab)[which[n]]))
    }
    invisible(retval)
}
<environment: namespace:stats>
> print("relevel"); if(is.function(try(relevel))) {relevel;} else{ NULL};
[1] "relevel"
function (x, ref, ...) 
UseMethod("relevel")
<environment: namespace:stats>
> print("reorder.default"); if(is.function(try(reorder.default))) {reorder.default;} else{ NULL};
[1] "reorder.default"
NULL
> print("reorder.dendrogram"); if(is.function(try(reorder.dendrogram))) {reorder.dendrogram;} else{ NULL};
[1] "reorder.dendrogram"
NULL
> print("replications"); if(is.function(try(replications))) {replications;} else{ NULL};
[1] "replications"
function (formula, data = NULL, na.action) 
{
    if (missing(data) && inherits(formula, "data.frame")) {
        data <- formula
        formula <- ~.
    }
    if (!inherits(formula, "terms")) {
        formula <- as.formula(formula)
        if (length(formula) < 3L) {
            f <- y ~ x
            f[[3L]] <- formula[[2L]]
            formula <- f
        }
        formula <- terms(formula, data = data)
    }
    if (missing(na.action)) 
        if (!is.null(tj <- attr(data, "na.action")) && is.function(tj)) 
            na.action <- tj
        else {
            naa <- getOption("na.action")
            if (!is.null(naa)) 
                na.action <- match.fun(naa)
            else na.action <- na.fail
        }
    f <- attr(formula, "factors")
    o <- attr(formula, "order")
    labels <- attr(formula, "term.labels")
    vars <- as.character(attr(formula, "variables"))[-1L]
    if (is.null(data)) {
        v <- c(as.name("data.frame"), attr(formula, "variables"))
        data <- eval(as.call(v), parent.frame())
    }
    if (!is.function(na.action)) 
        stop("na.action must be a function")
    data <- na.action(data)
    class(data) <- NULL
    n <- length(o)
    z <- vector("list", n)
    names(z) <- labels
    dummy <- numeric(.row_names_info(data, 2L))
    notfactor <- !sapply(data, function(x) inherits(x, "factor"))
    balance <- TRUE
    for (i in seq_len(n)) {
        l <- labels[i]
        if (o[i] < 1 || substring(l, 1L, 5L) == "Error") {
            z[[l]] <- NULL
            next
        }
        select <- vars[f[, i] > 0]
        if (any(nn <- notfactor[select])) {
            warning("non-factors ignored: ", paste(names(nn), 
                collapse = ", "))
            next
        }
        if (length(select)) 
            tble <- tapply(dummy, unclass(data[select]), length)
        nrep <- unique(as.vector(tble))
        if (length(nrep) > 1L) {
            balance <- FALSE
            tble[is.na(tble)] <- 0
            z[[l]] <- tble
        }
        else z[[l]] <- as.vector(nrep)
    }
    if (balance) 
        unlist(z)
    else z
}
<environment: namespace:stats>
> print("reshape"); if(is.function(try(reshape))) {reshape;} else{ NULL};
[1] "reshape"
function (data, varying = NULL, v.names = NULL, timevar = "time", 
    idvar = "id", ids = 1L:NROW(data), times = seq_along(varying[[1L]]), 
    drop = NULL, direction, new.row.names = NULL, sep = ".", 
    split = if (sep == "") {
        list(regexp = "[A-Za-z][0-9]", include = TRUE)
    } else {
        list(regexp = sep, include = FALSE, fixed = TRUE)
    }) 
{
    if (!is.character(sep) || length(sep) != 1L) 
        stop("'sep' must be a character string")
    ix2names <- function(ix) if (is.character(ix)) 
        ix
    else names(data)[ix]
    guess <- function(nms, re = split$regexp, drop = !split$include, 
        fixed = if (is.null(split$fixed)) 
            FALSE
        else split$fixed) {
        if (drop) 
            nn <- do.call("rbind", strsplit(nms, re, fixed = fixed))
        else nn <- cbind(substr(nms, 1L, regexpr(re, nms)), substr(nms, 
            regexpr(re, nms) + 1L, 10000L))
        if (ncol(nn) != 2) 
            stop("Failed to guess time-varying variables from their names")
        vn <- unique(nn[, 1])
        v.names <- split(nms, factor(nn[, 1], levels = vn))
        times <- unique(nn[, 2])
        attr(v.names, "v.names") <- vn
        tt <- tryCatch(as.numeric(times), warning = function(w) times)
        attr(v.names, "times") <- tt
        v.names
    }
    reshapeLong <- function(data, varying, v.names = NULL, timevar, 
        idvar, ids = 1L:NROW(data), times, drop = NULL, new.row.names = NULL) {
        ll <- unlist(lapply(varying, length))
        if (any(ll != ll[1L])) 
            stop("'varying' arguments must be the same length")
        if (ll[1L] != length(times)) 
            stop("'times' is wrong length")
        if (!is.null(drop)) {
            if (is.character(drop)) 
                drop <- names(data) %in% drop
            data <- data[, if (is.logical(drop)) 
                !drop
            else -drop, drop = FALSE]
        }
        undoInfo <- list(varying = varying, v.names = v.names, 
            idvar = idvar, timevar = timevar)
        if (length(idvar) > 1L) {
            repeat ({
                tempidname <- basename(tempfile("tempID"))
                if (!(tempidname %in% names(data))) 
                  break
            })
            data[, tempidname] <- interaction(data[, idvar], 
                drop = TRUE)
            idvar <- tempidname
            drop.idvar <- TRUE
        }
        else drop.idvar <- FALSE
        d <- data
        all.varying <- unlist(varying)
        d <- d[, !(names(data) %in% all.varying), drop = FALSE]
        d[, timevar] <- times[1L]
        if (is.null(v.names)) 
            v.names <- unlist(lapply(varying, function(x) x[1L]))
        for (i in seq_along(v.names)) d[, v.names[i]] <- data[, 
            varying[[i]][1L]]
        if (!(idvar %in% names(data))) 
            d[, idvar] <- ids
        rval <- d
        if (length(times) == 1L) {
            if (drop.idvar) 
                rval[, idvar] <- NULL
            return(rval)
        }
        if (is.null(new.row.names)) 
            row.names(rval) <- paste(d[, idvar], times[1L], sep = ".")
        else row.names(rval) <- new.row.names[1L:NROW(rval)]
        for (i in 2:length(times)) {
            d[, timevar] <- times[i]
            for (j in seq_along(v.names)) d[, v.names[j]] <- data[, 
                varying[[j]][i]]
            if (is.null(new.row.names)) 
                row.names(d) <- paste(d[, idvar], times[i], sep = ".")
            else row.names(d) <- new.row.names[NROW(rval) + 1L:NROW(d)]
            rval <- rbind(rval, d)
        }
        if (drop.idvar) 
            rval[, idvar] <- NULL
        attr(rval, "reshapeLong") <- undoInfo
        return(rval)
    }
    reshapeWide <- function(data, timevar, idvar, varying = NULL, 
        v.names = NULL, drop = NULL, new.row.names = NULL) {
        if (!is.null(drop)) {
            if (is.character(drop)) 
                drop <- names(data) %in% drop
            data <- data[, if (is.logical(drop)) 
                !drop
            else -drop, drop = FALSE]
        }
        undoInfo <- list(v.names = v.names, timevar = timevar, 
            idvar = idvar)
        orig.idvar <- idvar
        if (length(idvar) > 1L) {
            repeat ({
                tempidname <- basename(tempfile("tempID"))
                if (!(tempidname %in% names(data))) 
                  break
            })
            data[, tempidname] <- interaction(data[, idvar], 
                drop = TRUE)
            idvar <- tempidname
            drop.idvar <- TRUE
        }
        else drop.idvar <- FALSE
        times <- unique(data[, timevar])
        if (any(is.na(times))) 
            warning("there are records with missing times, which will be dropped.")
        undoInfo$times <- times
        if (is.null(v.names)) 
            v.names <- names(data)[!(names(data) %in% c(timevar, 
                idvar, orig.idvar))]
        if (is.null(varying)) 
            varying <- outer(v.names, times, paste, sep = sep)
        if (is.list(varying)) 
            varying <- do.call("rbind", varying)
        undoInfo$varying <- varying
        CHECK <- TRUE
        if (CHECK) {
            keep <- !(names(data) %in% c(timevar, v.names, idvar, 
                orig.idvar))
            if (any(keep)) {
                rval <- data[keep]
                tmp <- data[, idvar]
                really.constant <- unlist(lapply(rval, function(a) all(tapply(a, 
                  as.vector(tmp), function(b) length(unique(b)) == 
                    1L))))
                if (!all(really.constant)) 
                  warning(gettextf("some constant variables (%s) are really varying", 
                    paste(names(rval)[!really.constant], collapse = ",")), 
                    domain = NA)
            }
        }
        rval <- data[!duplicated(data[, idvar]), !(names(data) %in% 
            c(timevar, v.names)), drop = FALSE]
        for (i in seq_along(times)) {
            thistime <- data[data[, timevar] %in% times[i], ]
            rval[, varying[, i]] <- thistime[match(rval[, idvar], 
                thistime[, idvar]), v.names]
        }
        if (!is.null(new.row.names)) 
            row.names(rval) <- new.row.names
        if (drop.idvar) 
            rval[, idvar] <- NULL
        attr(rval, "reshapeWide") <- undoInfo
        rval
    }
    if (missing(direction)) {
        undo <- c("wide", "long")[c("reshapeLong", "reshapeWide") %in% 
            names(attributes(data))]
        if (length(undo) == 1L) 
            direction <- undo
    }
    direction <- match.arg(direction, c("wide", "long"))
    switch(direction, wide = {
        back <- attr(data, "reshapeLong")
        if (missing(timevar) && missing(idvar) && !is.null(back)) {
            reshapeWide(data, idvar = back$idvar, timevar = back$timevar, 
                varying = back$varying, v.names = back$v.names, 
                new.row.names = new.row.names)
        } else {
            reshapeWide(data, idvar = idvar, timevar = timevar, 
                varying = varying, v.names = v.names, drop = drop, 
                new.row.names = new.row.names)
        }
    }, long = {
        if (missing(varying)) {
            back <- attr(data, "reshapeWide")
            if (is.null(back)) stop("no 'reshapeWide' attribute, must specify 'varying'")
            varying <- back$varying
            idvar <- back$idvar
            timevar <- back$timevar
            v.names <- back$v.names
            times <- back$times
        }
        if (is.matrix(varying)) varying <- split(varying, row(varying))
        if (is.null(varying)) stop("'varying' must be nonempty list or vector")
        if (is.atomic(varying)) {
            varying <- ix2names(varying)
            if (missing(v.names)) varying <- guess(varying) else {
                if (length(varying)%%length(v.names)) stop("length of v.names does not evenly divide length of varying")
                ntimes <- length(varying)%/%length(v.names)
                if (missing(times)) times <- seq_len(ntimes) else if (length(times) != 
                  ntimes) stop("length of varying must be the product of length of v.names and length of times")
                varying <- split(varying, rep(v.names, ntimes))
                attr(varying, "v.names") <- v.names
                attr(varying, "times") <- times
            }
        } else varying <- lapply(varying, ix2names)
        if (missing(v.names) && !is.null(attr(varying, "v.names"))) {
            v.names <- attr(varying, "v.names")
            times <- attr(varying, "times")
        }
        reshapeLong(data, idvar = idvar, timevar = timevar, varying = varying, 
            v.names = v.names, drop = drop, times = times, ids = ids, 
            new.row.names = new.row.names)
    })
}
<environment: namespace:stats>
> print("residuals"); if(is.function(try(residuals))) {residuals;} else{ NULL};
[1] "residuals"
function (object, ...) 
UseMethod("residuals")
<environment: namespace:stats>
> print("runmed"); if(is.function(try(runmed))) {runmed;} else{ NULL};
[1] "runmed"
function (x, k, endrule = c("median", "keep", "constant"), algorithm = NULL, 
    print.level = 0) 
{
    n <- length(x)
    k <- as.integer(k)
    if (k < 0) 
        stop("'k' must be positive")
    if (k%%2 == 0) 
        warning("'k' must be odd!  Changing 'k' to ", k <- as.integer(1 + 
            2 * (k%/%2)))
    if (n == 0) {
        x <- double()
        attr(x, "k") <- k
        return(x)
    }
    if (k > n) 
        warning("'k' is bigger than 'n'!  Changing 'k' to ", 
            k <- as.integer(1 + 2 * ((n - 1)%/%2)))
    algorithm <- if (missing(algorithm)) {
        if (k < 20 || n < 300) 
            "Stuetzle"
        else "Turlach"
    }
    else {
        match.arg(algorithm, c("Stuetzle", "Turlach"))
    }
    endrule <- match.arg(endrule)
    iend <- switch(endrule, median = , keep = 0, constant = 1)
    if (print.level) 
        cat("runmed(*, endrule=", endrule, ", algorithm=", algorithm, 
            ", iend=", iend, ")\n")
    res <- switch(algorithm, Turlach = {
        .C(R_Trunmed, n, k, as.double(x), rmed = double(n), tmp1 = integer(k + 
            1), tmp2 = integer(2 * k + 1), tmp3 = double(2 * 
            k + 1), as.integer(iend), as.integer(print.level), 
            DUP = FALSE)$rmed
    }, Stuetzle = {
        .C(R_Srunmed, as.double(x), smo = double(n), n, k, as.integer(iend), 
            debug = (print.level > 0), DUP = FALSE)$smo
    })
    if (endrule == "median") 
        res <- smoothEnds(res, k = k)
    attr(res, "k") <- k
    res
}
<environment: namespace:stats>
> print("scatter.smooth"); if(is.function(try(scatter.smooth))) {scatter.smooth;} else{ NULL};
[1] "scatter.smooth"
function (x, y = NULL, span = 2/3, degree = 1, family = c("symmetric", 
    "gaussian"), xlab = NULL, ylab = NULL, ylim = range(y, prediction$y, 
    na.rm = TRUE), evaluation = 50, ...) 
{
    xlabel <- if (!missing(x)) 
        deparse(substitute(x))
    ylabel <- if (!missing(y)) 
        deparse(substitute(y))
    xy <- xy.coords(x, y, xlabel, ylabel)
    x <- xy$x
    y <- xy$y
    xlab <- if (is.null(xlab)) 
        xy$xlab
    else xlab
    ylab <- if (is.null(ylab)) 
        xy$ylab
    else ylab
    prediction <- loess.smooth(x, y, span, degree, family, evaluation)
    plot(x, y, ylim = ylim, xlab = xlab, ylab = ylab, ...)
    lines(prediction)
    invisible()
}
<environment: namespace:stats>
> print("screeplot"); if(is.function(try(screeplot))) {screeplot;} else{ NULL};
[1] "screeplot"
function (x, ...) 
UseMethod("screeplot")
<environment: namespace:stats>
> print("sd"); if(is.function(try(sd))) {sd;} else{ NULL};
[1] "sd"
function (x, na.rm = FALSE) 
{
    if (is.matrix(x)) 
        apply(x, 2, sd, na.rm = na.rm)
    else if (is.vector(x)) 
        sqrt(var(x, na.rm = na.rm))
    else if (is.data.frame(x)) 
        sapply(x, sd, na.rm = na.rm)
    else sqrt(var(as.vector(x), na.rm = na.rm))
}
<environment: namespace:stats>
> print("se.contrast"); if(is.function(try(se.contrast))) {se.contrast;} else{ NULL};
[1] "se.contrast"
function (object, ...) 
UseMethod("se.contrast")
<environment: namespace:stats>
> print("selfStart"); if(is.function(try(selfStart))) {selfStart;} else{ NULL};
[1] "selfStart"
function (model, initial, parameters, template) 
UseMethod("selfStart")
<environment: namespace:stats>
> print("setNames"); if(is.function(try(setNames))) {setNames;} else{ NULL};
[1] "setNames"
function (object, nm) 
{
    names(object) <- nm
    object
}
<environment: namespace:stats>
> print("shapiro.test"); if(is.function(try(shapiro.test))) {shapiro.test;} else{ NULL};
[1] "shapiro.test"
function (x) 
{
    DNAME <- deparse(substitute(x))
    x <- sort(x[complete.cases(x)])
    stopifnot(is.numeric(x))
    n <- length(x)
    if (n < 3 || n > 5000) 
        stop("sample size must be between 3 and 5000")
    rng <- x[n] - x[1L]
    if (rng == 0) 
        stop("all 'x' values are identical")
    if (rng < 1e-10) 
        x <- x/rng
    n2 <- n%/%2L
    sw <- .C(R_swilk, init = FALSE, as.single(x), n, n1 = n, 
        n2, a = single(n2), w = double(1), pw = double(1), ifault = integer(1L))
    if (sw$ifault && sw$ifault != 7) 
        stop(gettextf("ifault=%d. This should not happen", sw$ifault), 
            domain = NA)
    RVAL <- list(statistic = c(W = sw$w), p.value = sw$pw, method = "Shapiro-Wilk normality test", 
        data.name = DNAME)
    class(RVAL) <- "htest"
    return(RVAL)
}
<environment: namespace:stats>
> print("simulate"); if(is.function(try(simulate))) {simulate;} else{ NULL};
[1] "simulate"
function (object, nsim = 1, seed = NULL, ...) 
UseMethod("simulate")
<environment: namespace:stats>
> print("smooth"); if(is.function(try(smooth))) {smooth;} else{ NULL};
[1] "smooth"
function (x, kind = c("3RS3R", "3RSS", "3RSR", "3R", "3", "S"), 
    twiceit = FALSE, endrule = "Tukey", do.ends = FALSE) 
{
    if (!is.numeric(x)) 
        stop("attempt to smooth non-numeric values")
    if (any(is.na(x))) 
        stop("attempt to smooth NA values")
    rules <- c("copy", "Tukey")
    if (is.na(iend <- pmatch(endrule, rules))) 
        stop("wrong endrule")
    n <- length(x)
    kind <- match.arg(kind)
    if (substr(kind, 1L, 3L) == "3RS" && !do.ends) 
        iend <- -iend
    else if (kind == "S") 
        iend <- as.logical(do.ends)
    smo <- .C(paste("Rsm", kind, sep = "_"), as.double(x), y = double(n), 
        n, iend, iter = integer(1L), DUP = FALSE, PACKAGE = "stats")[c("y", 
        "iter")]
    if (any(kind == c("R", "S"))) {
        smo$iter <- as.logical(smo$iter)
        names(smo)[names(smo) == "iter"] <- "changed"
    }
    if (twiceit) {
        r <- smooth(x - smo$y, kind = kind, twiceit = FALSE, 
            endrule = endrule, do.ends = do.ends)
        smo$y <- smo$y + r
        if (!is.null(smo$iter)) 
            smo$iter <- smo$iter + attr(r, "iter")
        if (!is.null(smo$changed)) 
            smo$changed <- smo$changed || attr(r, "changed")
    }
    if (is.ts(x)) 
        smo$y <- ts(smo$y, start = start(x), frequency = frequency(x))
    structure(smo$y, kind = kind, twiced = twiceit, iter = smo$iter, 
        changed = smo$changed, endrule = if (substr(kind, 1L, 
            1L) == "3") 
            rules[iend], call = match.call(), class = c("tukeysmooth", 
            if (is.ts(x)) "ts"))
}
<environment: namespace:stats>
> print("smooth.spline"); if(is.function(try(smooth.spline))) {smooth.spline;} else{ NULL};
[1] "smooth.spline"
function (x, y = NULL, w = NULL, df, spar = NULL, cv = FALSE, 
    all.knots = FALSE, nknots = NULL, keep.data = TRUE, df.offset = 0, 
    penalty = 1, control.spar = list()) 
{
    contr.sp <- list(low = -1.5, high = 1.5, tol = 1e-04, eps = 2e-08, 
        maxit = 500, trace = getOption("verbose"))
    contr.sp[names(control.spar)] <- control.spar
    if (!all(sapply(contr.sp[1:4], is.numeric)) || contr.sp$tol < 
        0 || contr.sp$eps <= 0 || contr.sp$maxit <= 0) 
        stop("invalid 'control.spar'")
    xy <- xy.coords(x, y)
    y <- xy$y
    x <- xy$x
    if (!all(is.finite(c(x, y)))) 
        stop("missing or infinite values in inputs are not allowed")
    n <- length(x)
    w <- if (is.null(w)) 
        rep(1, n)
    else {
        if (n != length(w)) 
            stop("lengths of 'x' and 'w' must match")
        if (any(w < 0)) 
            stop("all weights should be non-negative")
        if (all(w == 0)) 
            stop("some weights should be positive")
        (w * sum(w > 0))/sum(w)
    }
    x <- signif(x, 6L)
    ux <- unique(sort(x))
    nx <- length(ux)
    if (nx <= 3L) 
        stop("need at least four unique 'x' values")
    if (nx == n) {
        ox <- TRUE
        tmp <- cbind(w, w * y, w * y^2)[order(x), ]
    }
    else {
        ox <- match(x, ux)
        tapply1 <- function(X, INDEX, FUN = NULL, ..., simplify = TRUE) {
            sapply(unname(split(X, INDEX)), FUN, ..., simplify = simplify, 
                USE.NAMES = FALSE)
        }
        tmp <- matrix(unlist(tapply1(seq_len(n), ox, function(i, 
            y, w) c(sum(w[i]), sum(w[i] * y[i]), sum(w[i] * y[i]^2)), 
            y = y, w = w)), ncol = 3, byrow = TRUE)
    }
    wbar <- tmp[, 1L]
    ybar <- tmp[, 2L]/ifelse(wbar > 0, wbar, 1)
    yssw <- sum(tmp[, 3L] - wbar * ybar^2)
    if (is.na(cv) && !missing(df)) 
        stop("'cv' must not be NA when 'df' is specified")
    CV <- !is.na(cv) && cv
    if (CV && nx < n) 
        warning("crossvalidation with non-unique 'x' values seems doubtful")
    r.ux <- ux[nx] - ux[1L]
    xbar <- (ux - ux[1L])/r.ux
    if (all.knots) {
        if (!is.null(nknots)) 
            warning("'all.knots' is TRUE; 'nknots' specification is disregarded")
        nknots <- nx
    }
    else {
        if (is.null(nknots)) 
            nknots <- n.knots(nx)
        else if (!is.numeric(nknots)) 
            stop("'nknots' must be numeric (in {1,..,n})")
        else if (nknots < 1) 
            stop("'nknots' must be at least 1")
        else if (nknots > nx) 
            stop("cannot use more inner knots than unique 'x' values")
    }
    knot <- c(rep(xbar[1], 3), if (all.knots) xbar else xbar[seq.int(1, 
        nx, length.out = nknots)], rep(xbar[nx], 3))
    nk <- nknots + 2L
    ispar <- if (is.null(spar) || missing(spar)) {
        if (contr.sp$trace) 
            -1L
        else 0L
    }
    else 1L
    spar <- if (ispar == 1L) 
        as.double(spar)
    else double(1)
    icrit <- if (is.na(cv)) 
        0L
    else if (cv) 
        2L
    else 1L
    dofoff <- df.offset
    if (!missing(df)) {
        if (df > 1 && df <= nx) {
            if (!missing(cv)) 
                warning("specified both 'df' and 'cv'; will disregard the latter")
            icrit <- 3L
            dofoff <- df
        }
        else warning("you must supply 1 < df <= n,  n = #{unique x} = ", 
            nx)
    }
    iparms <- as.integer(c(icrit, ispar, contr.sp$maxit))
    names(iparms) <- c("icrit", "ispar", "iter")
    keep.stuff <- FALSE
    ans.names <- c("coef", "ty", "lev", "spar", "parms", "crit", 
        "iparms", "ier", if (keep.stuff) "scratch")
    fit <- .Fortran(R_qsbart, as.double(penalty), as.double(dofoff), 
        x = as.double(xbar), y = as.double(ybar), w = as.double(wbar), 
        ssw = as.double(yssw), as.integer(nx), as.double(knot), 
        as.integer(nk), coef = double(nk), ty = double(nx), lev = double(if (is.na(cv)) 1L else nx), 
        crit = double(1), iparms = iparms, spar = spar, parms = unlist(contr.sp[1:4]), 
        isetup = as.integer(0), scratch = double(17L * nk + 1L), 
        ld4 = 4L, ldnk = 1L, ier = integer(1), DUP = FALSE)[ans.names]
    wbar <- tmp[, 1]
    if (is.na(cv)) 
        lev <- df <- NA
    else {
        lev <- fit$lev
        df <- sum(lev)
        if (is.na(df)) 
            stop("NA lev[]; probably smoothing parameter 'spar' way too large!")
    }
    if (fit$ier > 0L) {
        sml <- fit$spar < 0.5
        wtxt <- paste("smoothing parameter value too", if (sml) 
            "small"
        else "large")
        if (sml) {
            stop(wtxt)
        }
        else {
            fit$ty <- rep(mean(y), nx)
            df <- 1
            warning(wtxt, "\nsetting df = 1  __use with care!__")
        }
    }
    cv.crit <- if (is.na(cv)) 
        NA
    else if (cv) {
        ww <- wbar
        ww[!(ww > 0)] <- 1
        weighted.mean(((y - fit$ty[ox])/(1 - (lev[ox] * w)/ww[ox]))^2, 
            w)
    }
    else weighted.mean((y - fit$ty[ox])^2, w)/(1 - (df.offset + 
        penalty * df)/n)^2
    pen.crit <- sum(wbar * (ybar - fit$ty)^2)
    fit.object <- list(knot = knot, nk = nk, min = ux[1L], range = r.ux, 
        coef = fit$coef)
    class(fit.object) <- "smooth.spline.fit"
    object <- list(x = ux, y = fit$ty, w = wbar, yin = ybar, 
        data = if (keep.data) list(x = x, y = y, w = w), lev = lev, 
        cv.crit = cv.crit, pen.crit = pen.crit, crit = fit$crit, 
        df = df, spar = fit$spar, lambda = unname(fit$parms["low"]), 
        iparms = fit$iparms, fit = fit.object, call = match.call())
    class(object) <- "smooth.spline"
    object
}
<environment: namespace:stats>
> print("smoothEnds"); if(is.function(try(smoothEnds))) {smoothEnds;} else{ NULL};
[1] "smoothEnds"
function (y, k = 3) 
{
    med3 <- function(a, b, c) {
        m <- b
        if (a < b) {
            if (c < b) 
                m <- if (a >= c) 
                  a
                else c
        }
        else {
            if (c > b) 
                m <- if (a <= c) 
                  a
                else c
        }
        m
    }
    med.odd <- function(x, n = length(x)) {
        half <- (n + 1)%/%2
        sort(x, partial = half)[half]
    }
    k <- as.integer(k)
    if (k < 0 || k%%2 == 0) 
        stop("bandwidth 'k' must be >= 1 and odd!")
    k <- k%/%2
    if (k < 1) 
        return(y)
    n <- length(y)
    sm <- y
    if (k >= 2) {
        sm[2L] <- med3(y[1L], y[2L], y[3L])
        sm[n - 1] <- med3(y[n], y[n - 1], y[n - 2])
        if (k >= 3) {
            for (i in 3:k) {
                j <- 2 * i - 1
                sm[i] <- med.odd(y[1L:j], j)
                sm[n - i + 1] <- med.odd(y[(n + 1 - j):n], j)
            }
        }
    }
    sm[1L] <- med3(y[1L], sm[2L], 3 * sm[2L] - 2 * sm[3L])
    sm[n] <- med3(y[n], sm[n - 1], 3 * sm[n - 1] - 2 * sm[n - 
        2])
    return(sm)
}
<environment: namespace:stats>
> print("sortedXyData"); if(is.function(try(sortedXyData))) {sortedXyData;} else{ NULL};
[1] "sortedXyData"
function (x, y, data) 
UseMethod("sortedXyData")
<environment: namespace:stats>
> print("spec.ar"); if(is.function(try(spec.ar))) {spec.ar;} else{ NULL};
[1] "spec.ar"
function (x, n.freq, order = NULL, plot = TRUE, na.action = na.fail, 
    method = "yule-walker", ...) 
{
    if (!is.list(x)) {
        series <- deparse(substitute(x))
        x <- na.action(as.ts(x))
        xfreq <- frequency(x)
        nser <- NCOL(x)
        x <- ar(x, is.null(order), order, na.action = na.action, 
            method = method)
    }
    else {
        cn <- match(c("ar", "var.pred", "order"), names(x))
        if (any(is.na(cn))) 
            stop("'x' must be a time series or an ar() fit")
        series <- x$series
        xfreq <- x$frequency
        if (is.array(x$ar)) 
            nser <- dim(x$ar)[2L]
        else nser <- 1
    }
    order <- x$order
    if (missing(n.freq)) 
        n.freq <- 500
    freq <- seq.int(0, 0.5, length.out = n.freq)
    if (nser == 1) {
        coh <- phase <- NULL
        var.p <- as.vector(x$var.pred)
        spec <- if (order >= 1) {
            cs <- outer(freq, 1L:order, function(x, y) cos(2 * 
                pi * x * y)) %*% x$ar
            sn <- outer(freq, 1L:order, function(x, y) sin(2 * 
                pi * x * y)) %*% x$ar
            var.p/(xfreq * ((1 - cs)^2 + sn^2))
        }
        else rep.int(var.p/xfreq, length(freq))
    }
    else .NotYetImplemented()
    spg.out <- list(freq = freq * xfreq, spec = spec, coh = coh, 
        phase = phase, n.used = nrow(x), series = series, method = paste("AR (", 
            order, ") spectrum ", sep = ""))
    class(spg.out) <- "spec"
    if (plot) {
        plot(spg.out, ci = 0, ...)
        invisible(spg.out)
    }
    else spg.out
}
<environment: namespace:stats>
> print("spec.pgram"); if(is.function(try(spec.pgram))) {spec.pgram;} else{ NULL};
[1] "spec.pgram"
function (x, spans = NULL, kernel = NULL, taper = 0.1, pad = 0, 
    fast = TRUE, demean = FALSE, detrend = TRUE, plot = TRUE, 
    na.action = na.fail, ...) 
{
    series <- deparse(substitute(x))
    x <- na.action(as.ts(x))
    xfreq <- frequency(x)
    x <- as.matrix(x)
    N <- N0 <- nrow(x)
    nser <- ncol(x)
    if (!is.null(spans)) 
        kernel <- {
            if (is.tskernel(spans)) 
                spans
            else kernel("modified.daniell", spans%/%2)
        }
    if (!is.null(kernel) && !is.tskernel(kernel)) 
        stop("must specify 'spans' or a valid kernel")
    if (detrend) {
        t <- 1L:N - (N + 1)/2
        sumt2 <- N * (N^2 - 1)/12
        for (i in 1L:ncol(x)) x[, i] <- x[, i] - mean(x[, i]) - 
            sum(x[, i] * t) * t/sumt2
    }
    else if (demean) {
        x <- sweep(x, 2, colMeans(x), check.margin = FALSE)
    }
    x <- spec.taper(x, taper)
    u2 <- (1 - (5/8) * taper * 2)
    u4 <- (1 - (93/128) * taper * 2)
    if (pad > 0) {
        x <- rbind(x, matrix(0, nrow = N * pad, ncol = ncol(x)))
        N <- nrow(x)
    }
    NewN <- if (fast) 
        nextn(N)
    else N
    x <- rbind(x, matrix(0, nrow = (NewN - N), ncol = ncol(x)))
    N <- nrow(x)
    Nspec <- floor(N/2)
    freq <- seq.int(from = xfreq/N, by = xfreq/N, length.out = Nspec)
    xfft <- mvfft(x)
    pgram <- array(NA, dim = c(N, ncol(x), ncol(x)))
    for (i in 1L:ncol(x)) {
        for (j in 1L:ncol(x)) {
            pgram[, i, j] <- xfft[, i] * Conj(xfft[, j])/(N0 * 
                xfreq)
            pgram[1, i, j] <- 0.5 * (pgram[2, i, j] + pgram[N, 
                i, j])
        }
    }
    if (!is.null(kernel)) {
        for (i in 1L:ncol(x)) for (j in 1L:ncol(x)) pgram[, i, 
            j] <- kernapply(pgram[, i, j], kernel, circular = TRUE)
        df <- df.kernel(kernel)
        bandwidth <- bandwidth.kernel(kernel)
    }
    else {
        df <- 2
        bandwidth <- sqrt(1/12)
    }
    df <- df/(u4/u2^2)
    df <- df * (N0/N)
    bandwidth <- bandwidth * xfreq/N
    pgram <- pgram[2:(Nspec + 1), , , drop = FALSE]
    spec <- matrix(NA, nrow = Nspec, ncol = nser)
    for (i in 1L:nser) spec[, i] <- Re(pgram[1L:Nspec, i, i])
    if (nser == 1) {
        coh <- phase <- NULL
    }
    else {
        coh <- phase <- matrix(NA, nrow = Nspec, ncol = nser * 
            (nser - 1)/2)
        for (i in 1L:(nser - 1)) {
            for (j in (i + 1):nser) {
                coh[, i + (j - 1) * (j - 2)/2] <- Mod(pgram[, 
                  i, j])^2/(spec[, i] * spec[, j])
                phase[, i + (j - 1) * (j - 2)/2] <- Arg(pgram[, 
                  i, j])
            }
        }
    }
    for (i in 1L:nser) spec[, i] <- spec[, i]/u2
    spec <- drop(spec)
    spg.out <- list(freq = freq, spec = spec, coh = coh, phase = phase, 
        kernel = kernel, df = df, bandwidth = bandwidth, n.used = N, 
        orig.n = N0, series = series, snames = colnames(x), method = ifelse(!is.null(kernel), 
            "Smoothed Periodogram", "Raw Periodogram"), taper = taper, 
        pad = pad, detrend = detrend, demean = demean)
    class(spg.out) <- "spec"
    if (plot) {
        plot(spg.out, ...)
        return(invisible(spg.out))
    }
    else return(spg.out)
}
<environment: namespace:stats>
> print("spec.taper"); if(is.function(try(spec.taper))) {spec.taper;} else{ NULL};
[1] "spec.taper"
function (x, p = 0.1) 
{
    if (any(p < 0) || any(p > 0.5)) 
        stop("'p' must be between 0 and 0.5")
    a <- attributes(x)
    x <- as.matrix(x)
    nc <- ncol(x)
    if (length(p) == 1L) 
        p <- rep(p, nc)
    else if (length(p) != nc) 
        stop("length of 'p' must be 1 or equal the number of columns of 'x'")
    nr <- nrow(x)
    for (i in 1L:nc) {
        m <- floor(nr * p[i])
        if (m == 0) 
            next
        w <- 0.5 * (1 - cos(pi * seq.int(1, 2 * m - 1, by = 2)/(2 * 
            m)))
        x[, i] <- c(w, rep(1, nr - 2 * m), rev(w)) * x[, i]
    }
    attributes(x) <- a
    x
}
<environment: namespace:stats>
> print("spectrum"); if(is.function(try(spectrum))) {spectrum;} else{ NULL};
[1] "spectrum"
function (x, ..., method = c("pgram", "ar")) 
{
    switch(match.arg(method), pgram = spec.pgram(x, ...), ar = spec.ar(x, 
        ...))
}
<environment: namespace:stats>
> print("splinefun"); if(is.function(try(splinefun))) {splinefun;} else{ NULL};
[1] "splinefun"
function (x, y = NULL, method = c("fmm", "periodic", "natural", 
    "monoH.FC"), ties = mean) 
{
    x <- regularize.values(x, y, ties)
    y <- x$y
    x <- x$x
    nx <- length(x)
    if (nx == 0) 
        stop("zero non-NA points")
    method <- match.arg(method)
    if (method == "periodic" && y[1L] != y[nx]) {
        warning("spline: first and last y values differ - using y[1L] for both")
        y[nx] <- y[1L]
    }
    if (method == "monoH.FC") {
        n1 <- nx - 1L
        dy <- y[-1L] - y[-nx]
        dx <- x[-1L] - x[-nx]
        Sx <- dy/dx
        m <- c(Sx[1L], (Sx[-1L] + Sx[-n1])/2, Sx[n1])
        m <- .Call("R_monoFC_m", m, Sx, PACKAGE = "stats")
        return(splinefunH0(x = x, y = y, m = m, dx = dx))
    }
    iMeth <- match(method, c("periodic", "natural", "fmm", "monoH.FC"))
    z <- .C("spline_coef", method = as.integer(iMeth), n = as.integer(nx), 
        x = x, y = y, b = double(nx), c = double(nx), d = double(nx), 
        e = double(if (iMeth == 1) nx else 0), PACKAGE = "stats")
    rm(x, y, nx, method, iMeth, ties)
    z$e <- NULL
    function(x, deriv = 0) {
        deriv <- as.integer(deriv)
        if (deriv < 0 || deriv > 3) 
            stop("'deriv' must be between 0 and 3")
        if (deriv > 0) {
            z0 <- double(z$n)
            z[c("y", "b", "c")] <- switch(deriv, list(y = z$b, 
                b = 2 * z$c, c = 3 * z$d), list(y = 2 * z$c, 
                b = 6 * z$d, c = z0), list(y = 6 * z$d, b = z0, 
                c = z0))
            z[["d"]] <- z0
        }
        res <- .C("spline_eval", z$method, as.integer(length(x)), 
            x = as.double(x), y = double(length(x)), z$n, z$x, 
            z$y, z$b, z$c, z$d, PACKAGE = "stats")$y
        if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L])) 
            res[ind] <- ifelse(deriv == 1, z$y[1L], 0)
        res
    }
}
<environment: namespace:stats>
> print("start"); if(is.function(try(start))) {start;} else{ NULL};
[1] "start"
function (x, ...) 
UseMethod("start")
<environment: namespace:stats>
> print("stat.anova"); if(is.function(try(stat.anova))) {stat.anova;} else{ NULL};
[1] "stat.anova"
function (table, test = c("Chisq", "F", "Cp"), scale, df.scale, 
    n) 
{
    test <- match.arg(test)
    dev.col <- match("Deviance", colnames(table))
    if (is.na(dev.col)) 
        dev.col <- match("Sum of Sq", colnames(table))
    switch(test, Chisq = {
        dfs <- table[, "Df"]
        vals <- table[, dev.col]/scale * sign(dfs)
        vals[dfs %in% 0] <- NA
        vals[!is.na(vals) & vals < 0] <- NA
        cbind(table, `P(>|Chi|)` = pchisq(vals, abs(dfs), lower.tail = FALSE))
    }, F = {
        dfs <- table[, "Df"]
        Fvalue <- (table[, dev.col]/dfs)/scale
        Fvalue[dfs %in% 0] <- NA
        Fvalue[!is.na(Fvalue) & Fvalue < 0] <- NA
        cbind(table, F = Fvalue, `Pr(>F)` = pf(Fvalue, abs(dfs), 
            df.scale, lower.tail = FALSE))
    }, Cp = {
        cbind(table, Cp = table[, "Resid. Dev"] + 2 * scale * 
            (n - table[, "Resid. Df"]))
    })
}
<environment: namespace:stats>
> print("stats-deprecated"); if(is.function(try(stats-deprecated))) {stats-deprecated;} else{ NULL};
[1] "stats-deprecated"
NULL
> print("stats-package"); if(is.function(try(stats-package))) {stats-package;} else{ NULL};
[1] "stats-package"
NULL
> print("step"); if(is.function(try(step))) {step;} else{ NULL};
[1] "step"
function (object, scope, scale = 0, direction = c("both", "backward", 
    "forward"), trace = 1, keep = NULL, steps = 1000, k = 2, 
    ...) 
{
    mydeviance <- function(x, ...) {
        dev <- deviance(x)
        if (!is.null(dev)) 
            dev
        else extractAIC(x, k = 0)[2L]
    }
    cut.string <- function(string) {
        if (length(string) > 1L) 
            string[-1L] <- paste("\n", string[-1L], sep = "")
        string
    }
    re.arrange <- function(keep) {
        namr <- names(k1 <- keep[[1L]])
        namc <- names(keep)
        nc <- length(keep)
        nr <- length(k1)
        array(unlist(keep, recursive = FALSE), c(nr, nc), list(namr, 
            namc))
    }
    step.results <- function(models, fit, object, usingCp = FALSE) {
        change <- sapply(models, "[[", "change")
        rd <- sapply(models, "[[", "deviance")
        dd <- c(NA, abs(diff(rd)))
        rdf <- sapply(models, "[[", "df.resid")
        ddf <- c(NA, diff(rdf))
        AIC <- sapply(models, "[[", "AIC")
        heading <- c("Stepwise Model Path \nAnalysis of Deviance Table", 
            "\nInitial Model:", deparse(formula(object)), "\nFinal Model:", 
            deparse(formula(fit)), "\n")
        aod <- data.frame(Step = I(change), Df = ddf, Deviance = dd, 
            `Resid. Df` = rdf, `Resid. Dev` = rd, AIC = AIC, 
            check.names = FALSE)
        if (usingCp) {
            cn <- colnames(aod)
            cn[cn == "AIC"] <- "Cp"
            colnames(aod) <- cn
        }
        attr(aod, "heading") <- heading
        fit$anova <- aod
        fit
    }
    Terms <- terms(object)
    object$call$formula <- object$formula <- Terms
    md <- missing(direction)
    direction <- match.arg(direction)
    backward <- direction == "both" | direction == "backward"
    forward <- direction == "both" | direction == "forward"
    if (missing(scope)) {
        fdrop <- numeric()
        fadd <- attr(Terms, "factors")
        if (md) 
            forward <- FALSE
    }
    else {
        if (is.list(scope)) {
            fdrop <- if (!is.null(fdrop <- scope$lower)) 
                attr(terms(update.formula(object, fdrop)), "factors")
            else numeric()
            fadd <- if (!is.null(fadd <- scope$upper)) 
                attr(terms(update.formula(object, fadd)), "factors")
        }
        else {
            fadd <- if (!is.null(fadd <- scope)) 
                attr(terms(update.formula(object, scope)), "factors")
            fdrop <- numeric()
        }
    }
    models <- vector("list", steps)
    if (!is.null(keep)) 
        keep.list <- vector("list", steps)
    n <- nobs(object, use.fallback = TRUE)
    fit <- object
    bAIC <- extractAIC(fit, scale, k = k, ...)
    edf <- bAIC[1L]
    bAIC <- bAIC[2L]
    if (is.na(bAIC)) 
        stop("AIC is not defined for this model, so 'step' cannot proceed")
    nm <- 1
    if (trace) {
        cat("Start:  AIC=", format(round(bAIC, 2)), "\n", cut.string(deparse(formula(fit))), 
            "\n\n", sep = "")
        utils::flush.console()
    }
    models[[nm]] <- list(deviance = mydeviance(fit), df.resid = n - 
        edf, change = "", AIC = bAIC)
    if (!is.null(keep)) 
        keep.list[[nm]] <- keep(fit, bAIC)
    usingCp <- FALSE
    while (steps > 0) {
        steps <- steps - 1
        AIC <- bAIC
        ffac <- attr(Terms, "factors")
        scope <- factor.scope(ffac, list(add = fadd, drop = fdrop))
        aod <- NULL
        change <- NULL
        if (backward && length(scope$drop)) {
            aod <- drop1(fit, scope$drop, scale = scale, trace = trace, 
                k = k, ...)
            rn <- row.names(aod)
            row.names(aod) <- c(rn[1L], paste("-", rn[-1L], sep = " "))
            if (any(aod$Df == 0, na.rm = TRUE)) {
                zdf <- aod$Df == 0 & !is.na(aod$Df)
                change <- rev(rownames(aod)[zdf])[1L]
            }
        }
        if (is.null(change)) {
            if (forward && length(scope$add)) {
                aodf <- add1(fit, scope$add, scale = scale, trace = trace, 
                  k = k, ...)
                rn <- row.names(aodf)
                row.names(aodf) <- c(rn[1L], paste("+", rn[-1L], 
                  sep = " "))
                aod <- if (is.null(aod)) 
                  aodf
                else rbind(aod, aodf[-1, , drop = FALSE])
            }
            attr(aod, "heading") <- NULL
            nzdf <- if (!is.null(aod$Df)) 
                aod$Df != 0 | is.na(aod$Df)
            aod <- aod[nzdf, ]
            if (is.null(aod) || ncol(aod) == 0) 
                break
            nc <- match(c("Cp", "AIC"), names(aod))
            nc <- nc[!is.na(nc)][1L]
            o <- order(aod[, nc])
            if (trace) 
                print(aod[o, ])
            if (o[1L] == 1) 
                break
            change <- rownames(aod)[o[1L]]
        }
        usingCp <- match("Cp", names(aod), 0L) > 0L
        fit <- update(fit, paste("~ .", change), evaluate = FALSE)
        fit <- eval.parent(fit)
        nnew <- nobs(fit, use.fallback = TRUE)
        if (all(is.finite(c(n, nnew))) && nnew != n) 
            stop("number of rows in use has changed: remove missing values?")
        Terms <- terms(fit)
        bAIC <- extractAIC(fit, scale, k = k, ...)
        edf <- bAIC[1L]
        bAIC <- bAIC[2L]
        if (trace) {
            cat("\nStep:  AIC=", format(round(bAIC, 2)), "\n", 
                cut.string(deparse(formula(fit))), "\n\n", sep = "")
            utils::flush.console()
        }
        if (bAIC >= AIC + 1e-07) 
            break
        nm <- nm + 1
        models[[nm]] <- list(deviance = mydeviance(fit), df.resid = n - 
            edf, change = change, AIC = bAIC)
        if (!is.null(keep)) 
            keep.list[[nm]] <- keep(fit, bAIC)
    }
    if (!is.null(keep)) 
        fit$keep <- re.arrange(keep.list[seq(nm)])
    step.results(models = models[seq(nm)], fit, object, usingCp)
}
<environment: namespace:stats>
> print("stepfun"); if(is.function(try(stepfun))) {stepfun;} else{ NULL};
[1] "stepfun"
function (x, y, f = as.numeric(right), ties = "ordered", right = FALSE) 
{
    if (is.unsorted(x)) 
        stop("stepfun: 'x' must be ordered increasingly")
    n <- length(x)
    if (n < 1) 
        stop("'x' must have length >= 1")
    n1 <- n + 1L
    if (length(y) != n1) 
        stop("'y' must be one longer than 'x'")
    rval <- approxfun(x, y[-if (right) 
        n1
    else 1], method = "constant", yleft = y[1L], yright = y[n1], 
        f = f, ties = ties)
    class(rval) <- c("stepfun", class(rval))
    attr(rval, "call") <- sys.call()
    rval
}
<environment: namespace:stats>
> print("stl"); if(is.function(try(stl))) {stl;} else{ NULL};
[1] "stl"
function (x, s.window, s.degree = 0, t.window = NULL, t.degree = 1, 
    l.window = nextodd(period), l.degree = t.degree, s.jump = ceiling(s.window/10), 
    t.jump = ceiling(t.window/10), l.jump = ceiling(l.window/10), 
    robust = FALSE, inner = if (robust) 1 else 2, outer = if (robust) 15 else 0, 
    na.action = na.fail) 
{
    nextodd <- function(x) {
        x <- round(x)
        if (x%%2 == 0) 
            x <- x + 1
        as.integer(x)
    }
    deg.check <- function(deg) {
        degname <- deparse(substitute(deg))
        deg <- as.integer(deg)
        if (deg < 0 || deg > 1) 
            stop(degname, " must be 0 or 1")
        deg
    }
    x <- na.action(as.ts(x))
    if (is.matrix(x)) 
        stop("only univariate series are allowed")
    n <- length(x)
    period <- frequency(x)
    if (period < 2 || n <= 2 * period) 
        stop("series is not periodic or has less than two periods")
    periodic <- FALSE
    if (is.character(s.window)) {
        if (is.na(pmatch(s.window, "periodic"))) 
            stop("unknown string value for s.window")
        else {
            periodic <- TRUE
            s.window <- 10 * n + 1
            s.degree <- 0
        }
    }
    s.degree <- deg.check(s.degree)
    t.degree <- deg.check(t.degree)
    l.degree <- deg.check(l.degree)
    if (is.null(t.window)) 
        t.window <- nextodd(ceiling(1.5 * period/(1 - 1.5/s.window)))
    z <- .Fortran(R_stl, as.double(x), as.integer(n), as.integer(period), 
        as.integer(s.window), as.integer(t.window), as.integer(l.window), 
        s.degree, t.degree, l.degree, nsjump = as.integer(s.jump), 
        ntjump = as.integer(t.jump), nljump = as.integer(l.jump), 
        ni = as.integer(inner), no = as.integer(outer), weights = double(n), 
        seasonal = double(n), trend = double(n), double((n + 
            2 * period) * 5))
    if (periodic) {
        which.cycle <- cycle(x)
        z$seasonal <- tapply(z$seasonal, which.cycle, mean)[which.cycle]
    }
    remainder <- as.vector(x) - z$seasonal - z$trend
    y <- cbind(seasonal = z$seasonal, trend = z$trend, remainder = remainder)
    res <- list(time.series = ts(y, start = start(x), frequency = period), 
        weights = z$weights, call = match.call(), win = c(s = s.window, 
            t = t.window, l = l.window), deg = c(s = s.degree, 
            t = t.degree, l = l.degree), jump = c(s = s.jump, 
            t = t.jump, l = l.jump), inner = z$ni, outer = z$no)
    class(res) <- "stl"
    res
}
<environment: namespace:stats>
> print("summary.aov"); if(is.function(try(summary.aov))) {summary.aov;} else{ NULL};
[1] "summary.aov"
function (object, intercept = FALSE, split, expand.split = TRUE, 
    keep.zero.df = TRUE, ...) 
{
    splitInteractions <- function(split, factors, names, asgn, 
        df.names) {
        ns <- names(split)
        for (i in unique(asgn)) {
            if (i == 0 || names[i + 1L] %in% ns) 
                next
            f <- rownames(factors)[factors[, i] > 0]
            sp <- f %in% ns
            if (any(sp)) {
                if (sum(sp) > 1) {
                  old <- split[f[sp]]
                  nn <- f[sp]
                  names(nn) <- nn
                  marg <- lapply(nn, function(x) df.names[asgn == 
                    (match(x, names) - 1L)])
                  term.coefs <- strsplit(df.names[asgn == i], 
                    ":", fixed = TRUE)
                  ttc <- sapply(term.coefs, function(x) x[sp])
                  rownames(ttc) <- nn
                  splitnames <- apply(expand.grid(lapply(old, 
                    names)), 1L, function(x) paste(x, collapse = "."))
                  names(splitnames) <- splitnames
                  tmp <- sapply(nn, function(i) names(old[[i]])[match(ttc[i, 
                    ], marg[[i]])])
                  tmp <- apply(tmp, 1L, function(x) paste(x, 
                    collapse = "."))
                  new <- lapply(splitnames, function(x) match(x, 
                    tmp))
                  split[[names[i + 1L]]] <- new[sapply(new, function(x) length(x) > 
                    0L)]
                }
                else {
                  old <- split[[f[sp]]]
                  marg.coefs <- df.names[asgn == (match(f[sp], 
                    names) - 1L)]
                  term.coefs <- strsplit(df.names[asgn == i], 
                    ":", fixed = TRUE)
                  ttc <- sapply(term.coefs, function(x) x[sp])
                  new <- lapply(old, function(x) seq_along(ttc)[ttc %in% 
                    marg.coefs[x]])
                  split[[names[i + 1L]]] <- new
                }
            }
        }
        split
    }
    asgn <- object$assign[object$qr$pivot[1L:object$rank]]
    uasgn <- unique(asgn)
    nterms <- length(uasgn)
    effects <- object$effects
    if (!is.null(effects)) 
        effects <- as.matrix(effects)[seq_along(asgn), , drop = FALSE]
    rdf <- object$df.residual
    nmeffect <- c("(Intercept)", attr(object$terms, "term.labels"))
    coef <- as.matrix(object$coefficients)
    resid <- as.matrix(object$residuals)
    wt <- object$weights
    if (!is.null(wt)) 
        resid <- resid * wt^0.5
    nresp <- NCOL(resid)
    ans <- vector("list", nresp)
    if (nresp > 1) {
        names(ans) <- character(nresp)
        for (y in 1L:nresp) {
            cn <- colnames(resid)[y]
            if (is.null(cn) || cn == "") 
                cn <- y
            names(ans)[y] <- paste(" Response", cn)
        }
    }
    if (!is.null(effects) && !missing(split)) {
        ns <- names(split)
        if (!is.null(Terms <- object$terms)) {
            if (!is.list(split)) 
                stop("the 'split' argument must be a list")
            if (!all(ns %in% nmeffect)) 
                stop("unknown name(s) in the 'split' list")
        }
        if (expand.split) {
            df.names <- names(coef(object))
            split <- splitInteractions(split, attr(Terms, "factors"), 
                nmeffect, asgn, df.names)
            ns <- names(split)
        }
    }
    for (y in 1L:nresp) {
        if (is.null(effects)) {
            nterms <- 0
            df <- ss <- ms <- numeric()
            nmrows <- character()
        }
        else {
            df <- ss <- numeric()
            nmrows <- character()
            for (i in seq(nterms)) {
                ai <- (asgn == uasgn[i])
                df <- c(df, sum(ai))
                ss <- c(ss, sum(effects[ai, y]^2))
                nmi <- nmeffect[1 + uasgn[i]]
                nmrows <- c(nmrows, nmi)
                if (!missing(split) && !is.na(int <- match(nmi, 
                  ns))) {
                  df <- c(df, unlist(lapply(split[[int]], length)))
                  if (is.null(nms <- names(split[[int]]))) 
                    nms <- paste("C", seq_along(split[[int]]), 
                      sep = "")
                  ss <- c(ss, unlist(lapply(split[[int]], function(i, 
                    e) sum(e[i]^2), effects[ai, y])))
                  nmrows <- c(nmrows, paste("  ", nmi, ": ", 
                    nms, sep = ""))
                }
            }
        }
        if (rdf > 0) {
            df <- c(df, rdf)
            ss <- c(ss, sum(resid[, y]^2))
            nmrows <- c(nmrows, "Residuals")
        }
        nt <- length(df)
        ms <- ifelse(df > 0L, ss/df, NA)
        x <- list(Df = df, `Sum Sq` = ss, `Mean Sq` = ms)
        if (rdf > 0) {
            TT <- ms/ms[nt]
            TP <- pf(TT, df, rdf, lower.tail = FALSE)
            TT[nt] <- TP[nt] <- NA
            x$"F value" <- TT
            x$"Pr(>F)" <- TP
        }
        class(x) <- c("anova", "data.frame")
        attr(x, "row.names") <- format(nmrows)
        if (!keep.zero.df) 
            x <- x[df > 0, ]
        pm <- pmatch("(Intercept)", row.names(x), 0L)
        if (!intercept && pm > 0) 
            x <- x[-pm, ]
        ans[[y]] <- x
    }
    class(ans) <- c("summary.aov", "listof")
    attr(ans, "na.action") <- object$na.action
    ans
}
<environment: namespace:stats>
> print("summary.glm"); if(is.function(try(summary.glm))) {summary.glm;} else{ NULL};
[1] "summary.glm"
function (object, dispersion = NULL, correlation = FALSE, symbolic.cor = FALSE, 
    ...) 
{
    est.disp <- FALSE
    df.r <- object$df.residual
    if (is.null(dispersion)) 
        dispersion <- if (object$family$family %in% c("poisson", 
            "binomial")) 
            1
        else if (df.r > 0) {
            est.disp <- TRUE
            if (any(object$weights == 0)) 
                warning("observations with zero weight not used for calculating dispersion")
            sum((object$weights * object$residuals^2)[object$weights > 
                0])/df.r
        }
        else {
            est.disp <- TRUE
            NaN
        }
    aliased <- is.na(coef(object))
    p <- object$rank
    if (p > 0) {
        p1 <- 1L:p
        Qr <- qr.lm(object)
        coef.p <- object$coefficients[Qr$pivot[p1]]
        covmat.unscaled <- chol2inv(Qr$qr[p1, p1, drop = FALSE])
        dimnames(covmat.unscaled) <- list(names(coef.p), names(coef.p))
        covmat <- dispersion * covmat.unscaled
        var.cf <- diag(covmat)
        s.err <- sqrt(var.cf)
        tvalue <- coef.p/s.err
        dn <- c("Estimate", "Std. Error")
        if (!est.disp) {
            pvalue <- 2 * pnorm(-abs(tvalue))
            coef.table <- cbind(coef.p, s.err, tvalue, pvalue)
            dimnames(coef.table) <- list(names(coef.p), c(dn, 
                "z value", "Pr(>|z|)"))
        }
        else if (df.r > 0) {
            pvalue <- 2 * pt(-abs(tvalue), df.r)
            coef.table <- cbind(coef.p, s.err, tvalue, pvalue)
            dimnames(coef.table) <- list(names(coef.p), c(dn, 
                "t value", "Pr(>|t|)"))
        }
        else {
            coef.table <- cbind(coef.p, NaN, NaN, NaN)
            dimnames(coef.table) <- list(names(coef.p), c(dn, 
                "t value", "Pr(>|t|)"))
        }
        df.f <- NCOL(Qr$qr)
    }
    else {
        coef.table <- matrix(, 0L, 4L)
        dimnames(coef.table) <- list(NULL, c("Estimate", "Std. Error", 
            "t value", "Pr(>|t|)"))
        covmat.unscaled <- covmat <- matrix(, 0L, 0L)
        df.f <- length(aliased)
    }
    keep <- match(c("call", "terms", "family", "deviance", "aic", 
        "contrasts", "df.residual", "null.deviance", "df.null", 
        "iter", "na.action"), names(object), 0L)
    ans <- c(object[keep], list(deviance.resid = residuals(object, 
        type = "deviance"), coefficients = coef.table, aliased = aliased, 
        dispersion = dispersion, df = c(object$rank, df.r, df.f), 
        cov.unscaled = covmat.unscaled, cov.scaled = covmat))
    if (correlation && p > 0) {
        dd <- sqrt(diag(covmat.unscaled))
        ans$correlation <- covmat.unscaled/outer(dd, dd)
        ans$symbolic.cor <- symbolic.cor
    }
    class(ans) <- "summary.glm"
    return(ans)
}
<environment: namespace:stats>
> print("summary.lm"); if(is.function(try(summary.lm))) {summary.lm;} else{ NULL};
[1] "summary.lm"
function (object, correlation = FALSE, symbolic.cor = FALSE, 
    ...) 
{
    z <- object
    p <- z$rank
    rdf <- z$df.residual
    if (p == 0) {
        r <- z$residuals
        n <- length(r)
        w <- z$weights
        if (is.null(w)) {
            rss <- sum(r^2)
        }
        else {
            rss <- sum(w * r^2)
            r <- sqrt(w) * r
        }
        resvar <- rss/rdf
        ans <- z[c("call", "terms")]
        class(ans) <- "summary.lm"
        ans$aliased <- is.na(coef(object))
        ans$residuals <- r
        ans$df <- c(0L, n, length(ans$aliased))
        ans$coefficients <- matrix(NA, 0L, 4L)
        dimnames(ans$coefficients) <- list(NULL, c("Estimate", 
            "Std. Error", "t value", "Pr(>|t|)"))
        ans$sigma <- sqrt(resvar)
        ans$r.squared <- ans$adj.r.squared <- 0
        return(ans)
    }
    if (is.null(z$terms)) 
        stop("invalid 'lm' object:  no 'terms' component")
    if (!inherits(object, "lm")) 
        warning("calling summary.lm(<fake-lm-object>) ...")
    Qr <- qr.lm(object)
    n <- NROW(Qr$qr)
    if (is.na(z$df.residual) || n - p != z$df.residual) 
        warning("residual degrees of freedom in object suggest this is not an \"lm\" fit")
    p1 <- 1L:p
    r <- z$residuals
    f <- z$fitted.values
    w <- z$weights
    if (is.null(w)) {
        mss <- if (attr(z$terms, "intercept")) 
            sum((f - mean(f))^2)
        else sum(f^2)
        rss <- sum(r^2)
    }
    else {
        mss <- if (attr(z$terms, "intercept")) {
            m <- sum(w * f/sum(w))
            sum(w * (f - m)^2)
        }
        else sum(w * f^2)
        rss <- sum(w * r^2)
        r <- sqrt(w) * r
    }
    resvar <- rss/rdf
    R <- chol2inv(Qr$qr[p1, p1, drop = FALSE])
    se <- sqrt(diag(R) * resvar)
    est <- z$coefficients[Qr$pivot[p1]]
    tval <- est/se
    ans <- z[c("call", "terms")]
    ans$residuals <- r
    ans$coefficients <- cbind(est, se, tval, 2 * pt(abs(tval), 
        rdf, lower.tail = FALSE))
    dimnames(ans$coefficients) <- list(names(z$coefficients)[Qr$pivot[p1]], 
        c("Estimate", "Std. Error", "t value", "Pr(>|t|)"))
    ans$aliased <- is.na(coef(object))
    ans$sigma <- sqrt(resvar)
    ans$df <- c(p, rdf, NCOL(Qr$qr))
    if (p != attr(z$terms, "intercept")) {
        df.int <- if (attr(z$terms, "intercept")) 
            1L
        else 0L
        ans$r.squared <- mss/(mss + rss)
        ans$adj.r.squared <- 1 - (1 - ans$r.squared) * ((n - 
            df.int)/rdf)
        ans$fstatistic <- c(value = (mss/(p - df.int))/resvar, 
            numdf = p - df.int, dendf = rdf)
    }
    else ans$r.squared <- ans$adj.r.squared <- 0
    ans$cov.unscaled <- R
    dimnames(ans$cov.unscaled) <- dimnames(ans$coefficients)[c(1, 
        1)]
    if (correlation) {
        ans$correlation <- (R * resvar)/outer(se, se)
        dimnames(ans$correlation) <- dimnames(ans$cov.unscaled)
        ans$symbolic.cor <- symbolic.cor
    }
    if (!is.null(z$na.action)) 
        ans$na.action <- z$na.action
    class(ans) <- "summary.lm"
    ans
}
<environment: namespace:stats>
> print("summary.manova"); if(is.function(try(summary.manova))) {summary.manova;} else{ NULL};
[1] "summary.manova"
function (object, test = c("Pillai", "Wilks", "Hotelling-Lawley", 
    "Roy"), intercept = FALSE, tol = 1e-07, ...) 
{
    if (!inherits(object, "maov")) 
        stop("object must be of class \"manova\" or \"maov\"")
    test <- match.arg(test)
    asgn <- object$assign[object$qr$pivot[1L:object$rank]]
    uasgn <- unique(asgn)
    nterms <- length(uasgn)
    effects <- object$effects
    if (!is.null(effects)) 
        effects <- as.matrix(effects)[seq_along(asgn), , drop = FALSE]
    rdf <- object$df.residual
    nmeffect <- c("(Intercept)", attr(object$terms, "term.labels"))
    resid <- as.matrix(object$residuals)
    wt <- object$weights
    if (!is.null(wt)) 
        resid <- resid * wt^0.5
    nresp <- NCOL(resid)
    if (nresp <= 1) 
        stop("need multiple responses")
    if (is.null(effects)) {
        df <- nterms <- 0
        ss <- list(0)
        nmrows <- character()
    }
    else {
        df <- numeric(nterms)
        ss <- list(nterms)
        nmrows <- character(nterms)
        for (i in seq(nterms)) {
            ai <- (asgn == uasgn[i])
            nmrows[i] <- nmeffect[1 + uasgn[i]]
            df[i] <- sum(ai)
            ss[[i]] <- crossprod(effects[ai, , drop = FALSE])
        }
    }
    pm <- pmatch("(Intercept)", nmrows, 0L)
    if (!intercept && pm > 0) {
        nterms <- nterms - 1
        df <- df[-pm]
        nmrows <- nmrows[-pm]
        ss <- ss[-pm]
    }
    names(ss) <- nmrows
    nt <- nterms
    if (rdf > 0) {
        nt <- nterms + 1
        df[nt] <- rdf
        ss[[nt]] <- crossprod(resid)
        names(ss)[nt] <- nmrows[nt] <- "Residuals"
        ok <- df[-nt] > 0
        eigs <- array(NA, c(nterms, nresp))
        dimnames(eigs) <- list(nmrows[-nt], NULL)
        stats <- matrix(NA, nt, 5)
        dimnames(stats) <- list(nmrows, c(test, "approx F", "num Df", 
            "den Df", "Pr(>F)"))
        sc <- sqrt(diag(ss[[nt]]))
        sss <- sc^2
        for (i in seq_len(nterms)[ok]) sss <- sss + diag(ss[[i]])
        sc[sc < sqrt(sss) * 1e-06] <- 1
        D <- diag(1/sc)
        rss.qr <- qr(D %*% ss[[nt]] %*% D, tol = tol)
        if (rss.qr$rank < ncol(resid)) 
            stop(gettextf("residuals have rank %d < %d", rss.qr$rank, 
                ncol(resid)), domain = NA)
        if (!is.null(rss.qr)) 
            for (i in seq_len(nterms)[ok]) {
                A1 <- qr.coef(rss.qr, D %*% ss[[i]] %*% D)
                eigs[i, ] <- Re(eigen(A1, symmetric = FALSE)$values)
                stats[i, 1L:4] <- switch(test, Pillai = Pillai(eigs[i, 
                  ], df[i], df[nt]), Wilks = Wilks(eigs[i, ], 
                  df[i], df[nt]), `Hotelling-Lawley` = HL(eigs[i, 
                  ], df[i], df[nt]), Roy = Roy(eigs[i, ], df[i], 
                  df[nt]))
                ok <- stats[, 2] >= 0 & stats[, 3] > 0 & stats[, 
                  4] > 0
                ok <- !is.na(ok) & ok
                stats[ok, 5] <- pf(stats[ok, 2], stats[ok, 3], 
                  stats[ok, 4], lower.tail = FALSE)
            }
        x <- list(row.names = nmrows, SS = ss, Eigenvalues = eigs, 
            stats = cbind(Df = df, stats = stats))
    }
    else x <- list(row.names = nmrows, SS = ss, Df = df)
    class(x) <- "summary.manova"
    x
}
<environment: namespace:stats>
> print("summary.nls"); if(is.function(try(summary.nls))) {summary.nls;} else{ NULL};
[1] "summary.nls"
NULL
> print("summary.princomp"); if(is.function(try(summary.princomp))) {summary.princomp;} else{ NULL};
[1] "summary.princomp"
NULL
> print("supsmu"); if(is.function(try(supsmu))) {supsmu;} else{ NULL};
[1] "supsmu"
function (x, y, wt = rep(1, n), span = "cv", periodic = FALSE, 
    bass = 0) 
{
    if (span == "cv") 
        span <- 0
    n <- length(y)
    if (!n || !is.numeric(y)) 
        stop("'y' must be numeric vector")
    if (length(x) != n) 
        stop("number of observations in 'x' and 'y' must match.")
    if (length(wt) != n) 
        stop("number of weights must match number of observations.")
    if (span < 0 || span > 1) 
        stop("'span' must be between 0 and 1.")
    if (periodic) {
        iper <- 2L
        xrange <- range(x)
        if (xrange[1L] < 0 || xrange[2L] > 1) 
            stop("'x' must be between 0 and 1 for periodic smooth")
    }
    else iper <- 1L
    okay <- is.finite(x + y + wt)
    ord <- order(x[okay], y[okay])
    ord <- cumsum(!okay)[okay][ord] + ord
    xo <- x[ord]
    leno <- length(ord)
    if (leno == 0L) 
        stop("no finite observations")
    if (diff <- n - leno) 
        warning(diff, " observation(s) with NAs, NaNs and/or Infs deleted")
    .Fortran(R_setsmu)
    smo <- .Fortran(R_supsmu, as.integer(leno), as.double(xo), 
        as.double(y[ord]), as.double(wt[ord]), as.integer(iper), 
        as.double(span), as.double(bass), smo = double(leno), 
        double(n * 7L), double(1L))$smo
    dupx <- duplicated(xo)
    list(x = xo[!dupx], y = smo[!dupx])
}
<environment: namespace:stats>
> print("symnum"); if(is.function(try(symnum))) {symnum;} else{ NULL};
[1] "symnum"
function (x, cutpoints = c(0.3, 0.6, 0.8, 0.9, 0.95), symbols = if (numeric.x) c(" ", 
    ".", ",", "+", "*", "B") else c(".", "|"), legend = length(symbols) >= 
    3, na = "?", eps = 1e-05, numeric.x = is.numeric(x), corr = missing(cutpoints) && 
    numeric.x, show.max = if (corr) "1", show.min = NULL, abbr.colnames = has.colnames, 
    lower.triangular = corr && is.numeric(x) && is.matrix(x), 
    diag.lower.tri = corr && !is.null(show.max)) 
{
    if (length(x) == 0L) 
        return(noquote(if (is.null(d <- dim(x))) character() else array("", 
            dim = d)))
    has.na <- any(nax <- is.na(x))
    if (numeric.x) {
        force(corr)
        cutpoints <- sort(cutpoints)
        if (corr) 
            cutpoints <- c(0, cutpoints, 1)
        if (anyDuplicated(cutpoints) || (corr && (any(cutpoints > 
            1) || any(cutpoints < 0)))) 
            stop(if (corr) 
                gettext("'cutpoints' must be unique in 0 < cuts < 1, but are = ")
            else gettext("'cutpoints' must be unique, but are = "), 
                paste(format(cutpoints), collapse = "|"), domain = NA)
        nc <- length(cutpoints)
        minc <- cutpoints[1L]
        maxc <- cutpoints[nc]
        range.msg <- if (corr) 
            gettext("'x' must be between -1 and 1")
        else gettextf("'x' must be between %s and %s", format(minc), 
            format(maxc))
        if (corr) 
            x <- abs(x)
        else if (any(x < minc - eps, na.rm = TRUE)) 
            stop(range.msg, domain = NA)
        if (any(x > maxc + eps, na.rm = TRUE)) 
            stop(range.msg, domain = NA)
        ns <- length(symbols)
        symbols <- as.character(symbols)
        if (anyDuplicated(symbols)) 
            stop("'symbols' must be unique, but are = ", paste(symbols, 
                collapse = "|"), domain = NA)
        if (nc != ns + 1) 
            if (corr) 
                stop("number of 'cutpoints' must be one less than number of symbols")
            else stop("number of 'cutpoints' must be one more than number of symbols")
        iS <- cut(x, breaks = cutpoints, include.lowest = TRUE, 
            labels = FALSE)
        if (any(ii <- is.na(iS))) {
            iS[which(ii)[!is.na(x[ii]) & (abs(x[ii] - minc) < 
                eps)]] <- 1
        }
    }
    else {
        if (!missing(symbols) && length(symbols) != 2L) 
            stop("must have 2 'symbols' for logical 'x' argument")
        iS <- x + 1
    }
    if (has.na) {
        ans <- character(length(iS))
        if ((has.na <- is.character(na))) 
            ans[nax] <- na
        ans[!nax] <- symbols[iS[!nax]]
    }
    else ans <- symbols[iS]
    if (numeric.x) {
        if (!is.null(show.max)) 
            ans[x >= maxc - eps] <- if (is.character(show.max)) 
                show.max
            else format(maxc, dig = 1)
        if (!is.null(show.min)) 
            ans[x <= minc + eps] <- if (is.character(show.min)) 
                show.min
            else format(minc, dig = 1)
    }
    if (lower.triangular && is.matrix(x)) 
        ans[!lower.tri(x, diag = diag.lower.tri)] <- ""
    attributes(ans) <- attributes(x)
    if (is.array(ans) && (rank <- length(dim(x))) >= 2L) {
        has.colnames <- !is.null(dimnames(ans))
        if (!has.colnames) {
            dimnames(ans) <- vector("list", rank)
        }
        else {
            has.colnames <- length(dimnames(ans)[[2L]]) > 0L
        }
        if ((is.logical(abbr.colnames) || is.numeric(abbr.colnames)) && 
            abbr.colnames) {
            dimnames(ans)[[2L]] <- abbreviate(dimnames(ans)[[2L]], 
                minlength = abbr.colnames)
        }
        else if (is.null(abbr.colnames) || is.null(dimnames(ans)[[2L]])) 
            dimnames(ans)[[2L]] <- rep("", dim(ans)[2L])
        else if (!is.logical(abbr.colnames)) 
            stop("invalid 'abbr.colnames'")
    }
    if (legend) {
        legend <- c(rbind(sapply(cutpoints, format), c(sQuote(symbols), 
            "")), if (has.na) paste("\t    ## NA:", sQuote(na)))
        attr(ans, "legend") <- paste(legend[-2 * (ns + 1)], collapse = " ")
    }
    noquote(ans)
}
<environment: namespace:stats>
> print("t.test"); if(is.function(try(t.test))) {t.test;} else{ NULL};
[1] "t.test"
function (x, ...) 
UseMethod("t.test")
<environment: namespace:stats>
> print("termplot"); if(is.function(try(termplot))) {termplot;} else{ NULL};
[1] "termplot"
function (model, data = NULL, envir = environment(formula(model)), 
    partial.resid = FALSE, rug = FALSE, terms = NULL, se = FALSE, 
    xlabs = NULL, ylabs = NULL, main = NULL, col.term = 2, lwd.term = 1.5, 
    col.se = "orange", lty.se = 2, lwd.se = 1, col.res = "gray", 
    cex = 1, pch = par("pch"), col.smth = "darkred", lty.smth = 2, 
    span.smth = 2/3, ask = dev.interactive() && nb.fig < n.tms, 
    use.factor.levels = TRUE, smooth = NULL, ylim = "common", 
    ...) 
{
    which.terms <- terms
    terms <- if (is.null(terms)) 
        predict(model, type = "terms", se.fit = se)
    else predict(model, type = "terms", se.fit = se, terms = terms)
    n.tms <- ncol(tms <- as.matrix(if (se) 
        terms$fit
    else terms))
    mf <- model.frame(model)
    if (is.null(data)) 
        data <- eval(model$call$data, envir)
    if (is.null(data)) 
        data <- mf
    use.rows <- if (NROW(tms) < NROW(data)) 
        match(rownames(tms), rownames(data))
    nmt <- colnames(tms)
    cn <- parse(text = nmt)
    if (!is.null(smooth)) 
        smooth <- match.fun(smooth)
    if (is.null(ylabs)) 
        ylabs <- paste("Partial for", nmt)
    if (is.null(main)) 
        main <- ""
    else if (is.logical(main)) 
        main <- if (main) 
            deparse(model$call, 500)
        else ""
    else if (!is.character(main)) 
        stop("'main' must be TRUE, FALSE, NULL or character (vector).")
    main <- rep(main, length.out = n.tms)
    pf <- envir
    carrier <- function(term) {
        if (length(term) > 1L) 
            carrier(term[[2L]])
        else eval(term, data, enclos = pf)
    }
    carrier.name <- function(term) {
        if (length(term) > 1L) 
            carrier.name(term[[2L]])
        else as.character(term)
    }
    if (is.null(xlabs)) 
        xlabs <- unlist(lapply(cn, carrier.name))
    if (partial.resid || !is.null(smooth)) {
        pres <- residuals(model, "partial")
        if (!is.null(which.terms)) 
            pres <- pres[, which.terms, drop = FALSE]
    }
    is.fac <- sapply(nmt, function(i) is.factor(mf[, i]))
    se.lines <- function(x, iy, i, ff = 2) {
        tt <- ff * terms$se.fit[iy, i]
        lines(x, tms[iy, i] + tt, lty = lty.se, lwd = lwd.se, 
            col = col.se)
        lines(x, tms[iy, i] - tt, lty = lty.se, lwd = lwd.se, 
            col = col.se)
    }
    nb.fig <- prod(par("mfcol"))
    if (ask) {
        oask <- devAskNewPage(TRUE)
        on.exit(devAskNewPage(oask))
    }
    ylims <- ylim
    if (identical(ylims, "common")) {
        ylims <- if (!se) 
            range(tms, na.rm = TRUE)
        else range(tms + 1.05 * 2 * terms$se.fit, tms - 1.05 * 
            2 * terms$se.fit, na.rm = TRUE)
        if (partial.resid) 
            ylims <- range(ylims, pres, na.rm = TRUE)
        if (rug) 
            ylims[1L] <- ylims[1L] - 0.07 * diff(ylims)
    }
    for (i in 1L:n.tms) {
        if (identical(ylim, "free")) {
            ylims <- range(tms[, i], na.rm = TRUE)
            if (se) 
                ylims <- range(ylims, tms[, i] + 1.05 * 2 * terms$se.fit[, 
                  i], tms[, i] - 1.05 * 2 * terms$se.fit[, i], 
                  na.rm = TRUE)
            if (partial.resid) 
                ylims <- range(ylims, pres[, i], na.rm = TRUE)
            if (rug) 
                ylims[1L] <- ylims[1L] - 0.07 * diff(ylims)
        }
        if (is.fac[i]) {
            ff <- mf[, nmt[i]]
            if (!is.null(model$na.action)) 
                ff <- naresid(model$na.action, ff)
            ll <- levels(ff)
            xlims <- range(seq_along(ll)) + c(-0.5, 0.5)
            xx <- as.numeric(ff)
            if (rug) {
                xlims[1L] <- xlims[1L] - 0.07 * diff(xlims)
                xlims[2L] <- xlims[2L] + 0.03 * diff(xlims)
            }
            plot(1, 0, type = "n", xlab = xlabs[i], ylab = ylabs[i], 
                xlim = xlims, ylim = ylims, main = main[i], xaxt = "n", 
                ...)
            if (use.factor.levels) 
                axis(1, at = seq_along(ll), labels = ll, ...)
            else axis(1)
            for (j in seq_along(ll)) {
                ww <- which(ff == ll[j])[c(1, 1)]
                jf <- j + c(-0.4, 0.4)
                lines(jf, tms[ww, i], col = col.term, lwd = lwd.term, 
                  ...)
                if (se) 
                  se.lines(jf, iy = ww, i = i)
            }
        }
        else {
            xx <- carrier(cn[[i]])
            if (!is.null(use.rows)) 
                xx <- xx[use.rows]
            xlims <- range(xx, na.rm = TRUE)
            if (rug) 
                xlims[1L] <- xlims[1L] - 0.07 * diff(xlims)
            oo <- order(xx)
            plot(xx[oo], tms[oo, i], type = "l", xlab = xlabs[i], 
                ylab = ylabs[i], xlim = xlims, ylim = ylims, 
                main = main[i], col = col.term, lwd = lwd.term, 
                ...)
            if (se) 
                se.lines(xx[oo], iy = oo, i = i)
        }
        if (partial.resid) {
            if (!is.fac[i] && !is.null(smooth)) {
                smooth(xx, pres[, i], lty = lty.smth, cex = cex, 
                  pch = pch, col = col.res, col.smooth = col.smth, 
                  span = span.smth)
            }
            else points(xx, pres[, i], cex = cex, pch = pch, 
                col = col.res)
        }
        if (rug) {
            n <- length(xx)
            lines(rep.int(jitter(xx), rep.int(3, n)), rep.int(ylims[1L] + 
                c(0, 0.05, NA) * diff(ylims), n))
            if (partial.resid) 
                lines(rep.int(xlims[1L] + c(0, 0.05, NA) * diff(xlims), 
                  n), rep.int(pres[, i], rep.int(3, n)))
        }
    }
    invisible(n.tms)
}
<environment: namespace:stats>
> print("terms"); if(is.function(try(terms))) {terms;} else{ NULL};
[1] "terms"
function (x, ...) 
UseMethod("terms")
<environment: namespace:stats>
> print("terms.formula"); if(is.function(try(terms.formula))) {terms.formula;} else{ NULL};
[1] "terms.formula"
function (x, specials = NULL, abb = NULL, data = NULL, neg.out = TRUE, 
    keep.order = FALSE, simplify = FALSE, ..., allowDotAsName = FALSE) 
{
    fixFormulaObject <- function(object) {
        Terms <- terms(object)
        tmp <- attr(Terms, "term.labels")
        ind <- grep("|", tmp, fixed = TRUE)
        if (length(ind)) 
            tmp[ind] <- paste("(", tmp[ind], ")")
        if (length(ind <- attr(Terms, "offset"))) {
            tmp2 <- as.character(attr(Terms, "variables"))[-1L]
            tmp <- c(tmp, tmp2[ind])
        }
        rhs <- if (length(tmp)) 
            paste(tmp, collapse = " + ")
        else "1"
        if (!attr(terms(object), "intercept")) 
            rhs <- paste(rhs, "- 1")
        if (length(form <- formula(object)) > 2L) {
            res <- formula(paste("lhs ~", rhs))
            res[[2L]] <- form[[2L]]
            res
        }
        else formula(paste("~", rhs))
    }
    if (!is.null(data) && !is.environment(data) && !is.data.frame(data)) 
        data <- as.data.frame(data, optional = TRUE)
    terms <- .Internal(terms.formula(x, specials, data, keep.order, 
        allowDotAsName))
    if (simplify) {
        a <- attributes(terms)
        terms <- fixFormulaObject(terms)
        attributes(terms) <- a
    }
    environment(terms) <- environment(x)
    if (!inherits(terms, "formula")) 
        class(terms) <- c(oldClass(terms), "formula")
    terms
}
<environment: namespace:stats>
> print("terms.object"); if(is.function(try(terms.object))) {terms.object;} else{ NULL};
[1] "terms.object"
NULL
> print("time"); if(is.function(try(time))) {time;} else{ NULL};
[1] "time"
function (x, ...) 
UseMethod("time")
<environment: namespace:stats>
> print("toeplitz"); if(is.function(try(toeplitz))) {toeplitz;} else{ NULL};
[1] "toeplitz"
function (x) 
{
    if (!is.vector(x)) 
        stop("'x' is not a vector")
    n <- length(x)
    A <- matrix(0, n, n)
    matrix(x[abs(col(A) - row(A)) + 1], n, n)
}
<environment: namespace:stats>
> print("ts"); if(is.function(try(ts))) {ts;} else{ NULL};
[1] "ts"
function (data = NA, start = 1, end = numeric(0), frequency = 1, 
    deltat = 1, ts.eps = getOption("ts.eps"), class = if (nseries > 
        1) c("mts", "ts") else "ts", names = if (!is.null(dimnames(data))) colnames(data) else paste("Series", 
        seq(nseries))) 
{
    if (is.data.frame(data)) 
        data <- data.matrix(data)
    if (is.matrix(data)) {
        nseries <- ncol(data)
        ndata <- nrow(data)
        dimnames(data) <- list(NULL, names)
    }
    else {
        nseries <- 1
        ndata <- length(data)
    }
    if (ndata == 0) 
        stop("'ts' object must have one or more observations")
    if (missing(frequency)) 
        frequency <- 1/deltat
    else if (missing(deltat)) 
        deltat <- 1/frequency
    if (frequency > 1 && abs(frequency - round(frequency)) < 
        ts.eps) 
        frequency <- round(frequency)
    if (length(start) > 1L) {
        start <- start[1L] + (start[2L] - 1)/frequency
    }
    if (length(end) > 1L) {
        end <- end[1L] + (end[2L] - 1)/frequency
    }
    if (missing(end)) 
        end <- start + (ndata - 1)/frequency
    else if (missing(start)) 
        start <- end - (ndata - 1)/frequency
    if (start > end) 
        stop("'start' cannot be after 'end'")
    nobs <- floor((end - start) * frequency + 1.01)
    if (nobs != ndata) 
        data <- if (NCOL(data) == 1) {
            if (ndata < nobs) 
                rep(data, length.out = nobs)
            else if (ndata > nobs) 
                data[1L:nobs]
        }
        else {
            if (ndata < nobs) 
                data[rep(1L:ndata, length.out = nobs), ]
            else if (ndata > nobs) 
                data[1L:nobs, ]
        }
    attr(data, "tsp") <- c(start, end, frequency)
    if (!is.null(class) && class != "none") 
        attr(data, "class") <- class
    data
}
<environment: namespace:stats>
> print("ts.plot"); if(is.function(try(ts.plot))) {ts.plot;} else{ NULL};
[1] "ts.plot"
function (..., gpars = list()) 
{
    dots <- list(...)
    pars <- c("xlab", "ylab", "xlim", "ylim", "col", "lty", "lwd", 
        "type", "main", "sub", "log")
    m <- names(dots) %in% pars
    if (length(m)) {
        gpars <- c(gpars, dots[m])
        dots <- dots[!m]
    }
    sers <- do.call("ts.union", dots)
    if (is.null(gpars$ylab)) 
        gpars$ylab <- if (NCOL(sers) > 1) 
            ""
        else deparse(substitute(...))
    do.call("plot.ts", c(list(sers, plot.type = "single"), gpars))
}
<environment: namespace:stats>
> print("ts.union"); if(is.function(try(ts.union))) {ts.union;} else{ NULL};
[1] "ts.union"
function (..., dframe = FALSE) 
.cbind.ts(list(...), .makeNamesTs(...), dframe = dframe, union = TRUE)
<environment: namespace:stats>
> print("tsSmooth"); if(is.function(try(tsSmooth))) {tsSmooth;} else{ NULL};
[1] "tsSmooth"
function (object, ...) 
UseMethod("tsSmooth")
<environment: namespace:stats>
> print("tsdiag"); if(is.function(try(tsdiag))) {tsdiag;} else{ NULL};
[1] "tsdiag"
function (object, gof.lag, ...) 
UseMethod("tsdiag")
<environment: namespace:stats>
> print("tsp"); if(is.function(try(tsp))) {tsp;} else{ NULL};
[1] "tsp"
function (x) 
attr(x, "tsp")
<environment: namespace:stats>
> print("uniroot"); if(is.function(try(uniroot))) {uniroot;} else{ NULL};
[1] "uniroot"
function (f, interval, ..., lower = min(interval), upper = max(interval), 
    f.lower = f(lower, ...), f.upper = f(upper, ...), tol = .Machine$double.eps^0.25, 
    maxiter = 1000) 
{
    if (!missing(interval) && length(interval) != 2L) 
        stop("'interval' must be a vector of length 2")
    if (!is.numeric(lower) || !is.numeric(upper) || lower >= 
        upper) 
        stop("lower < upper  is not fulfilled")
    if (is.na(f.lower)) 
        stop("f.lower = f(lower) is NA")
    if (is.na(f.upper)) 
        stop("f.upper = f(upper) is NA")
    if (f.lower * f.upper > 0) 
        stop("f() values at end points not of opposite sign")
    val <- .Internal(zeroin2(function(arg) f(arg, ...), lower, 
        upper, f.lower, f.upper, tol, as.integer(maxiter)))
    iter <- as.integer(val[2L])
    if (iter < 0) {
        warning("_NOT_ converged in ", maxiter, " iterations")
        iter <- maxiter
    }
    list(root = val[1L], f.root = f(val[1L], ...), iter = iter, 
        estim.prec = val[3L])
}
<environment: namespace:stats>
> print("update"); if(is.function(try(update))) {update;} else{ NULL};
[1] "update"
function (object, ...) 
UseMethod("update")
<environment: namespace:stats>
> print("update.formula"); if(is.function(try(update.formula))) {update.formula;} else{ NULL};
[1] "update.formula"
function (old, new, ...) 
{
    tmp <- .Internal(update.formula(as.formula(old), as.formula(new)))
    out <- formula(terms.formula(tmp, simplify = TRUE))
    return(out)
}
<environment: namespace:stats>
> print("var.test"); if(is.function(try(var.test))) {var.test;} else{ NULL};
[1] "var.test"
function (x, ...) 
UseMethod("var.test")
<environment: namespace:stats>
> print("varimax"); if(is.function(try(varimax))) {varimax;} else{ NULL};
[1] "varimax"
function (x, normalize = TRUE, eps = 1e-05) 
{
    nc <- ncol(x)
    if (nc < 2) 
        return(x)
    if (normalize) {
        sc <- sqrt(drop(apply(x, 1L, function(x) sum(x^2))))
        x <- x/sc
    }
    p <- nrow(x)
    TT <- diag(nc)
    d <- 0
    for (i in 1L:1000L) {
        z <- x %*% TT
        B <- t(x) %*% (z^3 - z %*% diag(drop(rep(1, p) %*% z^2))/p)
        sB <- La.svd(B)
        TT <- sB$u %*% sB$vt
        dpast <- d
        d <- sum(sB$d)
        if (d < dpast * (1 + eps)) 
            break
    }
    z <- x %*% TT
    if (normalize) 
        z <- z * sc
    dimnames(z) <- dimnames(x)
    class(z) <- "loadings"
    list(loadings = z, rotmat = TT)
}
<environment: namespace:stats>
> print("vcov"); if(is.function(try(vcov))) {vcov;} else{ NULL};
[1] "vcov"
function (object, ...) 
UseMethod("vcov")
<environment: namespace:stats>
> print("weighted.mean"); if(is.function(try(weighted.mean))) {weighted.mean;} else{ NULL};
[1] "weighted.mean"
function (x, w, ...) 
UseMethod("weighted.mean")
<environment: namespace:stats>
> print("weighted.residuals"); if(is.function(try(weighted.residuals))) {weighted.residuals;} else{ NULL};
[1] "weighted.residuals"
function (obj, drop0 = TRUE) 
{
    w <- weights(obj)
    r <- residuals(obj, type = "deviance")
    if (drop0 && !is.null(w)) {
        if (is.matrix(r)) 
            r[w != 0, , drop = FALSE]
        else r[w != 0]
    }
    else r
}
<environment: namespace:stats>
> print("weights"); if(is.function(try(weights))) {weights;} else{ NULL};
[1] "weights"
function (object, ...) 
UseMethod("weights")
<environment: namespace:stats>
> print("wilcox.test"); if(is.function(try(wilcox.test))) {wilcox.test;} else{ NULL};
[1] "wilcox.test"
function (x, ...) 
UseMethod("wilcox.test")
<environment: namespace:stats>
> print("window"); if(is.function(try(window))) {window;} else{ NULL};
[1] "window"
function (x, ...) 
UseMethod("window")
<environment: namespace:stats>
> print(".checkMFClasses"); if(is.function(try(.checkMFClasses))) {.checkMFClasses;} else{ NULL};
[1] ".checkMFClasses"
function (cl, m, ordNotOK = FALSE) 
{
    new <- sapply(m, .MFclass)
    new <- new[names(new) %in% names(cl)]
    if (length(new) == 0L) 
        return()
    old <- cl[names(new)]
    if (!ordNotOK) {
        old[old == "ordered"] <- "factor"
        new[new == "ordered"] <- "factor"
    }
    new[new == "ordered" && old == "factor"] <- "factor"
    if (!identical(old, new)) {
        wrong <- old != new
        if (sum(wrong) == 1) 
            stop(gettextf("variable '%s' was fitted with type \"%s\" but type \"%s\" was supplied", 
                names(old)[wrong], old[wrong], new[wrong]), call. = FALSE, 
                domain = NA)
        else stop(gettextf("variables %s were specified with different types from the fit", 
            paste(sQuote(names(old)[wrong]), collapse = ", ")), 
            call. = FALSE, domain = NA)
    }
}
<environment: namespace:stats>
> print("AIC"); if(is.function(try(AIC))) {AIC;} else{ NULL};
[1] "AIC"
function (object, ..., k = 2) 
UseMethod("AIC")
<environment: namespace:stats>
> print("ARMAacf"); if(is.function(try(ARMAacf))) {ARMAacf;} else{ NULL};
[1] "ARMAacf"
function (ar = numeric(0), ma = numeric(0), lag.max = r, pacf = FALSE) 
{
    p <- length(ar)
    q <- length(ma)
    if (!p && !q) 
        stop("empty model supplied")
    r <- max(p, q + 1)
    if (p > 0) {
        if (r > 1) {
            if (r > p) {
                ar <- c(ar, rep(0, r - p))
                p <- r
            }
            A <- matrix(0, p + 1L, 2L * p + 1L)
            ind <- as.matrix(expand.grid(1L:(p + 1), 1L:(p + 
                1)))[, 2L:1L]
            ind[, 2] <- ind[, 1L] + ind[, 2L] - 1L
            A[ind] <- c(1, -ar)
            A[, 1L:p] <- A[, 1L:p] + A[, (2L * p + 1L):(p + 2L)]
            rhs <- c(1, rep(0, p))
            if (q > 0) {
                psi <- c(1, ARMAtoMA(ar, ma, q))
                theta <- c(1, ma, rep(0, q + 1L))
                for (k in 1 + 0:q) rhs[k] <- sum(psi * theta[k + 
                  0:q])
            }
            ind <- (p + 1):1
            Acf <- solve(A[ind, ind], rhs)
            Acf <- Acf[-1L]/Acf[1L]
        }
        else Acf <- ar
        if (lag.max > p) {
            xx <- rep(0, lag.max - p)
            Acf <- c(Acf, filter(xx, ar, "recursive", init = rev(Acf)))
        }
        Acf <- c(1, Acf[1L:lag.max])
    }
    else if (q > 0) {
        x <- c(1, ma)
        Acf <- filter(c(x, rep(0, q)), rev(x), sides = 1)[-(1L:q)]
        if (lag.max > q) 
            Acf <- c(Acf, rep(0, lag.max - q))
        Acf <- Acf/Acf[1L]
    }
    names(Acf) <- 0:lag.max
    if (pacf) 
        .C(R_uni_pacf, as.double(Acf), pacf = double(lag.max), 
            as.integer(lag.max))$pacf
    else Acf
}
<environment: namespace:stats>
> print("ARMAtoMA"); if(is.function(try(ARMAtoMA))) {ARMAtoMA;} else{ NULL};
[1] "ARMAtoMA"
function (ar = numeric(0), ma = numeric(0), lag.max) 
.Call(R_ARMAtoMA, as.double(ar), as.double(ma), as.integer(lag.max))
<environment: namespace:stats>
> print("Beta"); if(is.function(try(Beta))) {Beta;} else{ NULL};
[1] "Beta"
NULL
> print("Binomial"); if(is.function(try(Binomial))) {Binomial;} else{ NULL};
[1] "Binomial"
NULL
> print("Box.test"); if(is.function(try(Box.test))) {Box.test;} else{ NULL};
[1] "Box.test"
function (x, lag = 1, type = c("Box-Pierce", "Ljung-Box"), fitdf = 0) 
{
    if (NCOL(x) > 1) 
        stop("x is not a vector or univariate time series")
    DNAME <- deparse(substitute(x))
    type <- match.arg(type)
    cor <- acf(x, lag.max = lag, plot = FALSE, na.action = na.pass)
    n <- sum(!is.na(x))
    PARAMETER <- lag - fitdf
    obs <- cor$acf[2:(lag + 1)]
    if (type == "Box-Pierce") {
        METHOD <- "Box-Pierce test"
        STATISTIC <- n * sum(obs^2)
        PVAL <- 1 - pchisq(STATISTIC, lag - fitdf)
    }
    else {
        METHOD <- "Box-Ljung test"
        STATISTIC <- n * (n + 2) * sum(1/seq.int(n - 1, n - lag) * 
            obs^2)
        PVAL <- 1 - pchisq(STATISTIC, lag - fitdf)
    }
    names(STATISTIC) <- "X-squared"
    names(PARAMETER) <- "df"
    structure(list(statistic = STATISTIC, parameter = PARAMETER, 
        p.value = PVAL, method = METHOD, data.name = DNAME), 
        class = "htest")
}
<environment: namespace:stats>
> print("C"); if(is.function(try(C))) {C;} else{ NULL};
[1] "C"
function (object, contr, how.many, ...) 
{
    if (!nlevels(object)) 
        stop("object not interpretable as a factor")
    if (!missing(contr) && is.name(Xcontr <- substitute(contr))) 
        contr <- switch(as.character(Xcontr), poly = "contr.poly", 
            helmert = "contr.helmert", sum = "contr.sum", treatment = "contr.treatment", 
            SAS = "contr.SAS", contr)
    if (missing(contr)) {
        oc <- getOption("contrasts")
        contr <- if (length(oc) < 2L) 
            if (is.ordered(object)) 
                contr.poly
            else contr.treatment
        else oc[1 + is.ordered(object)]
    }
    if (missing(how.many) && !length(list(...))) 
        contrasts(object) <- contr
    else {
        if (is.character(contr)) 
            contr <- get(contr, mode = "function")
        if (is.function(contr)) 
            contr <- contr(nlevels(object), ...)
        contrasts(object, how.many) <- contr
    }
    object
}
<environment: namespace:stats>
> print("Cauchy"); if(is.function(try(Cauchy))) {Cauchy;} else{ NULL};
[1] "Cauchy"
NULL
> print("Chisquare"); if(is.function(try(Chisquare))) {Chisquare;} else{ NULL};
[1] "Chisquare"
NULL
> print("Distributions"); if(is.function(try(Distributions))) {Distributions;} else{ NULL};
[1] "Distributions"
NULL
> print("Exponential"); if(is.function(try(Exponential))) {Exponential;} else{ NULL};
[1] "Exponential"
NULL
> print("FDist"); if(is.function(try(FDist))) {FDist;} else{ NULL};
[1] "FDist"
NULL
> print("GammaDist"); if(is.function(try(GammaDist))) {GammaDist;} else{ NULL};
[1] "GammaDist"
NULL
> print("Geometric"); if(is.function(try(Geometric))) {Geometric;} else{ NULL};
[1] "Geometric"
NULL
> print("HoltWinters"); if(is.function(try(HoltWinters))) {HoltWinters;} else{ NULL};
[1] "HoltWinters"
function (x, alpha = NULL, beta = NULL, gamma = NULL, seasonal = c("additive", 
    "multiplicative"), start.periods = 2, l.start = NULL, b.start = NULL, 
    s.start = NULL, optim.start = c(alpha = 0.3, beta = 0.1, 
        gamma = 0.1), optim.control = list()) 
{
    x <- as.ts(x)
    seasonal <- match.arg(seasonal)
    f <- frequency(x)
    if (!is.null(alpha) && (alpha == 0)) 
        stop("cannot fit models without level ('alpha' must not be 0 or FALSE).")
    if (!all(is.null(c(alpha, beta, gamma))) && any(c(alpha, 
        beta, gamma) < 0 || c(alpha, beta, gamma) > 1)) 
        stop("'alpha', 'beta' and 'gamma' must be within the unit interval.")
    if ((is.null(gamma) || gamma > 0)) {
        if (seasonal == "multiplicative" && any(x == 0)) 
            stop("data must be non-zero for multiplicative Holt-Winters.")
        if (start.periods < 2) 
            stop("need at least 2 periods to compute seasonal start values.")
    }
    if (!is.null(gamma) && is.logical(gamma) && !gamma) {
        expsmooth <- !is.null(beta) && is.logical(beta) && !beta
        if (is.null(l.start)) 
            l.start <- if (expsmooth) 
                x[1L]
            else x[2L]
        if (is.null(b.start)) 
            if (is.null(beta) || !is.logical(beta) || beta) 
                b.start <- x[2L] - x[1L]
        start.time <- 3 - expsmooth
        s.start <- 0
    }
    else {
        start.time <- f + 1
        wind <- start.periods * f
        st <- decompose(ts(x[1L:wind], start = start(x), frequency = f), 
            seasonal)
        dat <- na.omit(st$trend)
        m <- lm(dat ~ seq_along(dat))
        if (is.null(l.start)) 
            l.start <- as.vector(coef(m)[1L])
        if (is.null(b.start)) 
            b.start <- as.vector(coef(m)[2L])
        if (is.null(s.start)) 
            s.start <- st$figure
    }
    len <- length(x) - start.time + 1
    hw <- function(alpha, beta, gamma) .C("HoltWinters", as.double(x), 
        as.integer(length(x)), as.double(alpha), as.double(beta), 
        as.double(gamma), as.integer(start.time), as.integer(!+(seasonal == 
            "multiplicative")), as.integer(f), as.integer(!is.logical(beta) || 
            beta), as.integer(!is.logical(gamma) || gamma), a = as.double(l.start), 
        b = as.double(b.start), s = as.double(s.start), SSE = as.double(0), 
        level = double(len + 1L), trend = double(len + 1L), seasonal = double(len + 
            f), PACKAGE = "stats")
    if (is.null(gamma)) {
        if (is.null(alpha)) {
            if (is.null(beta)) {
                error <- function(p) hw(p[1L], p[2L], p[3L])$SSE
                sol <- optim(optim.start, error, method = "L-BFGS-B", 
                  lower = c(0, 0, 0), upper = c(1, 1, 1), control = optim.control)
                alpha <- sol$par[1L]
                beta <- sol$par[2L]
                gamma <- sol$par[3L]
            }
            else {
                error <- function(p) hw(p[1L], beta, p[2L])$SSE
                sol <- optim(c(optim.start["alpha"], optim.start["gamma"]), 
                  error, method = "L-BFGS-B", lower = c(0, 0), 
                  upper = c(1, 1), control = optim.control)
                alpha <- sol$par[1L]
                gamma <- sol$par[2L]
            }
        }
        else {
            if (is.null(beta)) {
                error <- function(p) hw(alpha, p[1L], p[2L])$SSE
                sol <- optim(c(optim.start["beta"], optim.start["gamma"]), 
                  error, method = "L-BFGS-B", lower = c(0, 0), 
                  upper = c(1, 1), control = optim.control)
                beta <- sol$par[1L]
                gamma <- sol$par[2L]
            }
            else {
                error <- function(p) hw(alpha, beta, p)$SSE
                gamma <- optimize(error, lower = 0, upper = 1)$minimum
            }
        }
    }
    else {
        if (is.null(alpha)) {
            if (is.null(beta)) {
                error <- function(p) hw(p[1L], p[2L], gamma)$SSE
                sol <- optim(c(optim.start["alpha"], optim.start["beta"]), 
                  error, method = "L-BFGS-B", lower = c(0, 0), 
                  upper = c(1, 1), control = optim.control)
                alpha <- sol$par[1L]
                beta <- sol$par[2L]
            }
            else {
                error <- function(p) hw(p, beta, gamma)$SSE
                alpha <- optimize(error, lower = 0, upper = 1)$minimum
            }
        }
        else {
            if (is.null(beta)) {
                error <- function(p) hw(alpha, p, gamma)$SSE
                beta <- optimize(error, lower = 0, upper = 1)$minimum
            }
        }
    }
    final.fit <- hw(alpha, beta, gamma)
    fitted <- ts(cbind(xhat = final.fit$level[-len - 1], level = final.fit$level[-len - 
        1], trend = if (!is.logical(beta) || beta) 
        final.fit$trend[-len - 1], season = if (!is.logical(gamma) || 
        gamma) 
        final.fit$seasonal[1L:len]), start = start(lag(x, k = 1 - 
        start.time)), frequency = frequency(x))
    if (!is.logical(beta) || beta) 
        fitted[, 1] <- fitted[, 1] + fitted[, "trend"]
    if (!is.logical(gamma) || gamma) 
        fitted[, 1] <- if (seasonal == "multiplicative") 
            fitted[, 1] * fitted[, "season"]
        else fitted[, 1] + fitted[, "season"]
    structure(list(fitted = fitted, x = x, alpha = alpha, beta = beta, 
        gamma = gamma, coefficients = c(a = final.fit$level[len + 
            1], b = if (!is.logical(beta) || beta) final.fit$trend[len + 
            1], s = if (!is.logical(gamma) || gamma) final.fit$seasonal[len + 
            1L:f]), seasonal = seasonal, SSE = final.fit$SSE, 
        call = match.call()), class = "HoltWinters")
}
<environment: namespace:stats>
> print("Hypergeometric"); if(is.function(try(Hypergeometric))) {Hypergeometric;} else{ NULL};
[1] "Hypergeometric"
NULL
> print("IQR"); if(is.function(try(IQR))) {IQR;} else{ NULL};
[1] "IQR"
function (x, na.rm = FALSE, type = 7) 
diff(quantile(as.numeric(x), c(0.25, 0.75), na.rm = na.rm, names = FALSE, 
    type = type))
<environment: namespace:stats>
> print("KalmanLike"); if(is.function(try(KalmanLike))) {KalmanLike;} else{ NULL};
[1] "KalmanLike"
function (y, mod, nit = 0, fast = TRUE) 
{
    x <- .Call("KalmanLike", y, mod$Z, mod$a, mod$P, mod$T, mod$V, 
        mod$h, mod$Pn, as.integer(nit), FALSE, fast = fast, PACKAGE = "stats")
    names(x) <- c("ssq", "sumlog")
    s2 <- x[1L]/length(y)
    list(Lik = 0.5 * (log(x[1L]/length(y)) + x[2L]/length(y)), 
        s2 = s2)
}
<environment: namespace:stats>
> print("Logistic"); if(is.function(try(Logistic))) {Logistic;} else{ NULL};
[1] "Logistic"
NULL
> print("Lognormal"); if(is.function(try(Lognormal))) {Lognormal;} else{ NULL};
[1] "Lognormal"
NULL
> print("Multinomial"); if(is.function(try(Multinomial))) {Multinomial;} else{ NULL};
[1] "Multinomial"
NULL
> print("NLSstAsymptotic"); if(is.function(try(NLSstAsymptotic))) {NLSstAsymptotic;} else{ NULL};
[1] "NLSstAsymptotic"
function (xy) 
UseMethod("NLSstAsymptotic")
<environment: namespace:stats>
> print("NLSstClosestX"); if(is.function(try(NLSstClosestX))) {NLSstClosestX;} else{ NULL};
[1] "NLSstClosestX"
function (xy, yval) 
UseMethod("NLSstClosestX")
<environment: namespace:stats>
> print("NLSstLfAsymptote"); if(is.function(try(NLSstLfAsymptote))) {NLSstLfAsymptote;} else{ NULL};
[1] "NLSstLfAsymptote"
function (xy) 
UseMethod("NLSstLfAsymptote")
<environment: namespace:stats>
> print("NLSstRtAsymptote"); if(is.function(try(NLSstRtAsymptote))) {NLSstRtAsymptote;} else{ NULL};
[1] "NLSstRtAsymptote"
function (xy) 
UseMethod("NLSstRtAsymptote")
<environment: namespace:stats>
> print("NegBinomial"); if(is.function(try(NegBinomial))) {NegBinomial;} else{ NULL};
[1] "NegBinomial"
NULL
> print("Normal"); if(is.function(try(Normal))) {Normal;} else{ NULL};
[1] "Normal"
NULL
> print("PP.test"); if(is.function(try(PP.test))) {PP.test;} else{ NULL};
[1] "PP.test"
function (x, lshort = TRUE) 
{
    if (NCOL(x) > 1) 
        stop("x is not a vector or univariate time series")
    DNAME <- deparse(substitute(x))
    z <- embed(x, 2)
    yt <- z[, 1]
    yt1 <- z[, 2]
    n <- length(yt)
    tt <- (1L:n) - n/2
    res <- lm(yt ~ 1 + tt + yt1)
    if (res$rank < 3) 
        stop("singularities in regression")
    res.sum <- summary(res)
    tstat <- (res.sum$coefficients[3, 1] - 1)/res.sum$coefficients[3, 
        2]
    u <- residuals(res)
    ssqru <- sum(u^2)/n
    if (lshort) 
        l <- trunc(4 * (n/100)^0.25)
    else l <- trunc(12 * (n/100)^0.25)
    ssqrtl <- .C("R_pp_sum", as.vector(u, mode = "double"), as.integer(n), 
        as.integer(l), trm = as.double(ssqru), PACKAGE = "stats")
    ssqrtl <- ssqrtl$trm
    n2 <- n^2
    trm1 <- n2 * (n2 - 1) * sum(yt1^2)/12
    trm2 <- n * sum(yt1 * (1L:n))^2
    trm3 <- n * (n + 1) * sum(yt1 * (1L:n)) * sum(yt1)
    trm4 <- (n * (n + 1) * (2 * n + 1) * sum(yt1)^2)/6
    Dx <- trm1 - trm2 + trm3 - trm4
    STAT <- sqrt(ssqru)/sqrt(ssqrtl) * tstat - (n^3)/(4 * sqrt(3) * 
        sqrt(Dx) * sqrt(ssqrtl)) * (ssqrtl - ssqru)
    table <- cbind(c(4.38, 4.15, 4.04, 3.99, 3.98, 3.96), c(3.95, 
        3.8, 3.73, 3.69, 3.68, 3.66), c(3.6, 3.5, 3.45, 3.43, 
        3.42, 3.41), c(3.24, 3.18, 3.15, 3.13, 3.13, 3.12), c(1.14, 
        1.19, 1.22, 1.23, 1.24, 1.25), c(0.8, 0.87, 0.9, 0.92, 
        0.93, 0.94), c(0.5, 0.58, 0.62, 0.64, 0.65, 0.66), c(0.15, 
        0.24, 0.28, 0.31, 0.32, 0.33))
    table <- -table
    tablen <- dim(table)[2L]
    tableT <- c(25, 50, 100, 250, 500, 1e+05)
    tablep <- c(0.01, 0.025, 0.05, 0.1, 0.9, 0.95, 0.975, 0.99)
    tableipl <- numeric(tablen)
    for (i in (1L:tablen)) tableipl[i] <- approx(tableT, table[, 
        i], n, rule = 2)$y
    PVAL <- approx(tableipl, tablep, STAT, rule = 2)$y
    PARAMETER <- l
    METHOD <- "Phillips-Perron Unit Root Test"
    names(STAT) <- "Dickey-Fuller"
    names(PARAMETER) <- "Truncation lag parameter"
    structure(list(statistic = STAT, parameter = PARAMETER, p.value = PVAL, 
        method = METHOD, data.name = DNAME), class = "htest")
}
<environment: namespace:stats>
> print("Poisson"); if(is.function(try(Poisson))) {Poisson;} else{ NULL};
[1] "Poisson"
NULL
> print("SSD"); if(is.function(try(SSD))) {SSD;} else{ NULL};
[1] "SSD"
function (object, ...) 
UseMethod("SSD")
<environment: namespace:stats>
> print("SSasymp"); if(is.function(try(SSasymp))) {SSasymp;} else{ NULL};
[1] "SSasymp"
function (input, Asym, R0, lrc) 
{
    .expr1 <- R0 - Asym
    .expr2 <- exp(lrc)
    .expr5 <- exp(((-.expr2) * input))
    .value <- Asym + (.expr1 * .expr5)
    .actualArgs <- as.list(match.call()[c("Asym", "R0", "lrc")])
    if (all(unlist(lapply(.actualArgs, is.name)))) {
        .grad <- array(0, c(length(.value), 3L), list(NULL, c("Asym", 
            "R0", "lrc")))
        .grad[, "Asym"] <- 1 - .expr5
        .grad[, "R0"] <- .expr5
        .grad[, "lrc"] <- -(.expr1 * (.expr5 * (.expr2 * input)))
        dimnames(.grad) <- list(NULL, .actualArgs)
        attr(.value, "gradient") <- .grad
    }
    .value
}
<environment: namespace:stats>
attr(,"initial")
function (mCall, data, LHS) 
{
    xy <- sortedXyData(mCall[["input"]], LHS, data)
    if (nrow(xy) < 3) {
        stop("too few distinct input values to fit an asymptotic regression model")
    }
    if (nrow(xy) > 3) {
        xy$ydiff <- abs(xy$y - NLSstRtAsymptote(xy))
        xy <- data.frame(xy)
        lrc <- log(-coef(lm(log(ydiff) ~ x, data = xy))[2L])
        names(lrc) <- NULL
        pars <- coef(nls(y ~ cbind(1 - exp(-exp(lrc) * x), exp(-exp(lrc) * 
            x)), data = xy, start = list(lrc = lrc), algorithm = "plinear"))
    }
    else {
        ydiff <- diff(xy$y)
        if (prod(ydiff) <= 0) {
            stop("cannot fit an asymptotic regression model to these data")
        }
        avg.resp <- xy$y
        frac <- (avg.resp[3L] - avg.resp[1L])/(avg.resp[2L] - 
            avg.resp[1L])
        xunique <- unique(xy$x)
        xdiff <- diff(xunique)
        if (xdiff[1L] == xdiff[2L]) {
            expmRd <- frac - 1
            rc <- -log(expmRd)/xdiff[1L]
            lrc <- log(rc)
            expmRx1 <- exp(-rc * xunique[1L])
            bma <- ydiff[1L]/(expmRx1 * (expmRd - 1))
            Asym <- avg.resp[1L] - bma * expmRx1
            pars <- c(lrc = lrc, Asym = Asym, R0 = bma + Asym)
        }
        else {
            stop("too few observations to fit an asymptotic regression model")
        }
    }
    names(pars) <- NULL
    val <- list(pars[2L], pars[3L], pars[1L])
    names(val) <- mCall[c("Asym", "R0", "lrc")]
    val
}
<environment: namespace:stats>
attr(,"pnames")
[1] "Asym" "R0"   "lrc" 
attr(,"class")
[1] "selfStart"
> print("SSasympOff"); if(is.function(try(SSasympOff))) {SSasympOff;} else{ NULL};
[1] "SSasympOff"
function (input, Asym, lrc, c0) 
{
    .expr1 <- exp(lrc)
    .expr3 <- input - c0
    .expr5 <- exp(((-.expr1) * .expr3))
    .expr6 <- 1 - .expr5
    .value <- Asym * .expr6
    .actualArgs <- as.list(match.call()[c("Asym", "lrc", "c0")])
    if (all(unlist(lapply(.actualArgs, is.name)))) {
        .grad <- array(0, c(length(.value), 3L), list(NULL, c("Asym", 
            "lrc", "c0")))
        .grad[, "Asym"] <- .expr6
        .grad[, "lrc"] <- Asym * (.expr5 * (.expr1 * .expr3))
        .grad[, "c0"] <- -(Asym * (.expr5 * .expr1))
        dimnames(.grad) <- list(NULL, .actualArgs)
        attr(.value, "gradient") <- .grad
    }
    .value
}
<environment: namespace:stats>
attr(,"initial")
function (mCall, data, LHS) 
{
    xy <- sortedXyData(mCall[["input"]], LHS, data)
    if (nrow(xy) < 4) {
        stop("too few distinct input values to fit the 'asympOff' model")
    }
    xy$ydiff <- abs(xy$y - NLSstRtAsymptote(xy))
    xy <- data.frame(xy)
    lrc <- log(-coef(lm(log(ydiff) ~ x, data = xy))[2L])
    pars <- as.vector(coef(nls(y ~ cbind(1, exp(-exp(lrc) * x)), 
        data = xy, algorithm = "plinear", start = list(lrc = lrc))))
    val <- list(pars[2L], pars[1L], exp(-pars[1L]) * log(-pars[3L]/pars[2L]))
    names(val) <- mCall[c("Asym", "lrc", "c0")]
    val
}
<environment: namespace:stats>
attr(,"pnames")
[1] "Asym" "lrc"  "c0"  
attr(,"class")
[1] "selfStart"
> print("SSasympOrig"); if(is.function(try(SSasympOrig))) {SSasympOrig;} else{ NULL};
[1] "SSasympOrig"
function (input, Asym, lrc) 
{
    .expr1 <- exp(lrc)
    .expr4 <- exp(((-.expr1) * input))
    .expr5 <- 1 - .expr4
    .value <- Asym * .expr5
    .actualArgs <- as.list(match.call()[c("Asym", "lrc")])
    if (all(unlist(lapply(.actualArgs, is.name)))) {
        .grad <- array(0, c(length(.value), 2L), list(NULL, c("Asym", 
            "lrc")))
        .grad[, "Asym"] <- .expr5
        .grad[, "lrc"] <- Asym * (.expr4 * (.expr1 * input))
        dimnames(.grad) <- list(NULL, .actualArgs)
        attr(.value, "gradient") <- .grad
    }
    .value
}
<environment: namespace:stats>
attr(,"initial")
function (mCall, data, LHS) 
{
    xy <- sortedXyData(mCall[["input"]], LHS, data)
    if (nrow(xy) < 3) {
        stop("too few distinct input values to fit the 'asympOrig' model")
    }
    A0 <- NLSstRtAsymptote(xy)
    lrc <- log(abs(mean(log(1 - xy$y/A0)/xy$x, na.rm = TRUE)))
    xy <- data.frame(xy)
    pars <- as.vector(coef(nls(y ~ 1 - exp(-exp(lrc) * x), data = xy, 
        start = list(lrc = lrc), algorithm = "plinear")))
    value <- c(pars[2L], pars[1L])
    names(value) <- mCall[c("Asym", "lrc")]
    value
}
<environment: namespace:stats>
attr(,"pnames")
[1] "Asym" "lrc" 
attr(,"class")
[1] "selfStart"
> print("SSbiexp"); if(is.function(try(SSbiexp))) {SSbiexp;} else{ NULL};
[1] "SSbiexp"
function (input, A1, lrc1, A2, lrc2) 
{
    .expr1 <- exp(lrc1)
    .expr4 <- exp(((-.expr1) * input))
    .expr6 <- exp(lrc2)
    .expr9 <- exp(((-.expr6) * input))
    .value <- (A1 * .expr4) + (A2 * .expr9)
    .actualArgs <- as.list(match.call()[c("A1", "lrc1", "A2", 
        "lrc2")])
    if (all(unlist(lapply(.actualArgs, is.name)))) {
        .grad <- array(0, c(length(.value), 4L), list(NULL, c("A1", 
            "lrc1", "A2", "lrc2")))
        .grad[, "A1"] <- .expr4
        .grad[, "lrc1"] <- -(A1 * (.expr4 * (.expr1 * input)))
        .grad[, "A2"] <- .expr9
        .grad[, "lrc2"] <- -(A2 * (.expr9 * (.expr6 * input)))
        dimnames(.grad) <- list(NULL, .actualArgs)
        attr(.value, "gradient") <- .grad
    }
    .value
}
<environment: namespace:stats>
attr(,"initial")
function (mCall, data, LHS) 
{
    xy <- data.frame(sortedXyData(mCall[["input"]], LHS, data))
    if (nrow(xy) < 5) {
        stop("too few distinct input values to fit a biexponential")
    }
    ndistinct <- nrow(xy)
    nlast <- max(3, round(ndistinct/2))
    dlast <- xy[(ndistinct + 1 - nlast):ndistinct, ]
    pars2 <- coef(lm(log(y) ~ x, data = dlast))
    lrc2 <- log(abs(pars2[2L]))
    xy[["res"]] <- xy[["y"]] - exp(pars2[1L]) * exp(-exp(lrc2) * 
        xy[["x"]])
    dfirst <- xy[1L:(ndistinct - nlast), ]
    pars1 <- coef(lm(log(abs(res)) ~ x, data = dfirst))
    lrc1 <- log(abs(pars1[2L]))
    pars <- coef(nls(y ~ cbind(exp(-exp(lrc1) * x), exp(-exp(lrc2) * 
        x)), data = xy, start = list(lrc1 = lrc1, lrc2 = lrc2), 
        algorithm = "plinear"))
    value <- c(pars[3L], pars[1L], pars[4L], pars[2L])
    names(value) <- mCall[c("A1", "lrc1", "A2", "lrc2")]
    value
}
<environment: namespace:stats>
attr(,"pnames")
[1] "A1"   "lrc1" "A2"   "lrc2"
attr(,"class")
[1] "selfStart"
> print("SSfol"); if(is.function(try(SSfol))) {SSfol;} else{ NULL};
[1] "SSfol"
function (Dose, input, lKe, lKa, lCl) 
{
    .expr4 <- Dose * exp((lKe + lKa) - lCl)
    .expr5 <- exp(lKe)
    .expr8 <- exp(-.expr5 * input)
    .expr9 <- exp(lKa)
    .expr12 <- exp(-.expr9 * input)
    .expr14 <- .expr4 * (.expr8 - .expr12)
    .expr15 <- .expr9 - .expr5
    .expr16 <- .expr14/.expr15
    .expr23 <- .expr15^2
    .value <- .expr16
    .actualArgs <- as.list(match.call()[c("lKe", "lKa", "lCl")])
    if (all(unlist(lapply(.actualArgs, is.name)))) {
        .grad <- array(0, c(length(.value), 3L), list(NULL, c("lKe", 
            "lKa", "lCl")))
        .grad[, "lKe"] <- (.expr14 - .expr4 * (.expr8 * (.expr5 * 
            input)))/.expr15 + .expr14 * .expr5/.expr23
        .grad[, "lKa"] <- (.expr14 + .expr4 * (.expr12 * (.expr9 * 
            input)))/.expr15 - .expr14 * .expr9/.expr23
        .grad[, "lCl"] <- -.expr16
        dimnames(.grad) <- list(NULL, .actualArgs)
        attr(.value, "gradient") <- .grad
    }
    .value
}
<environment: namespace:stats>
attr(,"initial")
function (mCall, data, LHS) 
{
    data <- data.frame(data)
    resp <- eval(LHS, data)
    input <- eval(mCall[["input"]], data)
    Dose <- eval(mCall[["Dose"]], data)
    n <- length(resp)
    if (length(input) != n) {
        stop("must have length of response = length of second argument to 'SSfol'")
    }
    if (n < 4) {
        stop("must have at least 4 observations to fit an 'SSfol' model")
    }
    rmaxind <- order(resp)[n]
    lresp <- log(resp)
    if (rmaxind == n) {
        lKe <- -2.5
    }
    else {
        lKe <- log((lresp[rmaxind] - lresp[n])/(input[n] - input[rmaxind]))
    }
    cond.lin <- nls(resp ~ (exp(-input * exp(lKe)) - exp(-input * 
        exp(lKa))) * Dose, data = list(resp = resp, input = input, 
        Dose = Dose, lKe = lKe), start = list(lKa = lKe + 1), 
        algorithm = "plinear")
    pars <- coef(cond.lin)
    names(pars) <- NULL
    cond.lin <- nls(resp ~ (Dose * (exp(-input * exp(lKe)) - 
        exp(-input * exp(lKa))))/(exp(lKa) - exp(lKe)), data = data.frame(list(resp = resp, 
        input = input, Dose = Dose)), start = list(lKa = pars[1L], 
        lKe = lKe), algorithm = "plinear")
    pars <- coef(cond.lin)
    names(pars) <- NULL
    lKa <- pars[1L]
    lKe <- pars[2L]
    Ka <- exp(lKa)
    Ke <- exp(lKe)
    value <- list(lKe, lKa, log((Ke * Ka)/(pars[3L])))
    names(value) <- as.character(mCall)[4:6]
    value
}
<environment: namespace:stats>
attr(,"pnames")
[1] "lKe" "lKa" "lCl"
attr(,"class")
[1] "selfStart"
> print("SSfpl"); if(is.function(try(SSfpl))) {SSfpl;} else{ NULL};
[1] "SSfpl"
function (input, A, B, xmid, scal) 
{
    .expr1 <- B - A
    .expr2 <- xmid - input
    .expr4 <- exp(.expr2/scal)
    .expr5 <- 1 + .expr4
    .expr8 <- 1/.expr5
    .expr13 <- .expr5^2
    .value <- A + .expr1/.expr5
    .actualArgs <- as.list(match.call()[c("A", "B", "xmid", "scal")])
    if (all(unlist(lapply(.actualArgs, is.name)))) {
        .grad <- array(0, c(length(.value), 4L), list(NULL, c("A", 
            "B", "xmid", "scal")))
        .grad[, "A"] <- 1 - .expr8
        .grad[, "B"] <- .expr8
        .grad[, "xmid"] <- -(.expr1 * (.expr4 * (1/scal))/.expr13)
        .grad[, "scal"] <- .expr1 * (.expr4 * (.expr2/scal^2))/.expr13
        dimnames(.grad) <- list(NULL, .actualArgs)
        attr(.value, "gradient") <- .grad
    }
    .value
}
<environment: namespace:stats>
attr(,"initial")
function (mCall, data, LHS) 
{
    xy <- sortedXyData(mCall[["input"]], LHS, data)
    if (nrow(xy) < 5) {
        stop("too few distinct input values to fit a four-parameter logistic")
    }
    rng <- range(xy$y)
    drng <- diff(rng)
    xy$prop <- (xy$y - rng[1L] + 0.05 * drng)/(1.1 * drng)
    ir <- as.vector(coef(lm(x ~ I(log(prop/(1 - prop))), data = xy)))
    pars <- as.vector(coef(nls(y ~ cbind(1, 1/(1 + exp((xmid - 
        x)/exp(lscal)))), data = xy, start = list(xmid = ir[1L], 
        lscal = log(abs(ir[2L]))), algorithm = "plinear")))
    value <- c(pars[3L], pars[3L] + pars[4L], pars[1L], exp(pars[2L]))
    names(value) <- mCall[c("A", "B", "xmid", "scal")]
    value
}
<environment: namespace:stats>
attr(,"pnames")
[1] "A"    "B"    "xmid" "scal"
attr(,"class")
[1] "selfStart"
> print("SSgompertz"); if(is.function(try(SSgompertz))) {SSgompertz;} else{ NULL};
[1] "SSgompertz"
function (x, Asym, b2, b3) 
{
    .expr2 <- b3^x
    .expr4 <- exp(-b2 * .expr2)
    .value <- Asym * .expr4
    .actualArgs <- as.list(match.call()[c("Asym", "b2", "b3")])
    if (all(unlist(lapply(.actualArgs, is.name)))) {
        .grad <- array(0, c(length(.value), 3L), list(NULL, c("Asym", 
            "b2", "b3")))
        .grad[, "Asym"] <- .expr4
        .grad[, "b2"] <- -Asym * (.expr4 * .expr2)
        .grad[, "b3"] <- -Asym * (.expr4 * (b2 * (b3^(x - 1) * 
            x)))
        dimnames(.grad) <- list(NULL, .actualArgs)
        attr(.value, "gradient") <- .grad
    }
    .value
}
<environment: namespace:stats>
attr(,"initial")
function (mCall, data, LHS) 
{
    xy <- sortedXyData(mCall[["x"]], LHS, data)
    if (nrow(xy) < 4) {
        stop("too few distinct input values to fit the Gompertz model")
    }
    xyL <- xy
    xyL$y <- log(abs(xyL$y))
    pars <- NLSstAsymptotic(xyL)
    pars <- coef(nls(y ~ exp(-b2 * b3^x), data = xy, algorithm = "plinear", 
        start = c(b2 = pars[["b1"]], b3 = exp(-exp(pars[["lrc"]])))))
    val <- pars[c(3, 1, 2)]
    names(val) <- mCall[c("Asym", "b2", "b3")]
    val
}
<environment: namespace:stats>
attr(,"pnames")
[1] "Asym" "b2"   "b3"  
attr(,"class")
[1] "selfStart"
> print("SSlogis"); if(is.function(try(SSlogis))) {SSlogis;} else{ NULL};
[1] "SSlogis"
function (input, Asym, xmid, scal) 
{
    .expr1 <- xmid - input
    .expr3 <- exp(.expr1/scal)
    .expr4 <- 1 + .expr3
    .expr10 <- .expr4^2
    .value <- Asym/.expr4
    .actualArgs <- as.list(match.call()[c("Asym", "xmid", "scal")])
    if (all(unlist(lapply(.actualArgs, is.name)))) {
        .grad <- array(0, c(length(.value), 3L), list(NULL, c("Asym", 
            "xmid", "scal")))
        .grad[, "Asym"] <- 1/.expr4
        .grad[, "xmid"] <- -(Asym * (.expr3 * (1/scal))/.expr10)
        .grad[, "scal"] <- Asym * (.expr3 * (.expr1/scal^2))/.expr10
        dimnames(.grad) <- list(NULL, .actualArgs)
        attr(.value, "gradient") <- .grad
    }
    .value
}
<environment: namespace:stats>
attr(,"initial")
function (mCall, data, LHS) 
{
    xy <- data.frame(sortedXyData(mCall[["input"]], LHS, data))
    if (nrow(xy) < 4) {
        stop("too few distinct input values to fit a logistic model")
    }
    z <- xy[["y"]]
    if (min(z) <= 0) {
        z <- z - 1.05 * min(z)
    }
    z <- z/(1.05 * max(z))
    xy[["z"]] <- log(z/(1 - z))
    aux <- coef(lm(x ~ z, xy))
    pars <- as.vector(coef(nls(y ~ 1/(1 + exp((xmid - x)/scal)), 
        data = xy, start = list(xmid = aux[1L], scal = aux[2L]), 
        algorithm = "plinear")))
    value <- c(pars[3L], pars[1L], pars[2L])
    names(value) <- mCall[c("Asym", "xmid", "scal")]
    value
}
<environment: namespace:stats>
attr(,"pnames")
[1] "Asym" "xmid" "scal"
attr(,"class")
[1] "selfStart"
> print("SSmicmen"); if(is.function(try(SSmicmen))) {SSmicmen;} else{ NULL};
[1] "SSmicmen"
function (input, Vm, K) 
{
    .expr1 <- Vm * input
    .expr2 <- K + input
    .value <- .expr1/.expr2
    .actualArgs <- as.list(match.call()[c("Vm", "K")])
    if (all(unlist(lapply(.actualArgs, is.name)))) {
        .grad <- array(0, c(length(.value), 2L), list(NULL, c("Vm", 
            "K")))
        .grad[, "Vm"] <- input/.expr2
        .grad[, "K"] <- -(.expr1/.expr2^2)
        dimnames(.grad) <- list(NULL, .actualArgs)
        attr(.value, "gradient") <- .grad
    }
    .value
}
<environment: namespace:stats>
attr(,"initial")
function (mCall, data, LHS) 
{
    xy <- data.frame(sortedXyData(mCall[["input"]], LHS, data))
    if (nrow(xy) < 3) {
        stop("too few distinct input values to fit a Michaelis-Menten model")
    }
    pars <- as.vector(coef(lm(1/y ~ I(1/x), data = xy)))
    pars <- as.vector(coef(nls(y ~ x/(K + x), data = xy, start = list(K = abs(pars[2L]/pars[1L])), 
        algorithm = "plinear")))
    value <- c(pars[2L], pars[1L])
    names(value) <- mCall[c("Vm", "K")]
    value
}
<environment: namespace:stats>
attr(,"pnames")
[1] "Vm" "K" 
attr(,"class")
[1] "selfStart"
> print("SSweibull"); if(is.function(try(SSweibull))) {SSweibull;} else{ NULL};
[1] "SSweibull"
function (x, Asym, Drop, lrc, pwr) 
{
    .expr1 <- exp(lrc)
    .expr3 <- x^pwr
    .expr5 <- exp(-.expr1 * .expr3)
    .value <- Asym - Drop * .expr5
    .actualArgs <- as.list(match.call()[c("Asym", "Drop", "lrc", 
        "pwr")])
    if (all(unlist(lapply(.actualArgs, is.name)))) {
        .grad <- array(0, c(length(.value), 4L), list(NULL, c("Asym", 
            "Drop", "lrc", "pwr")))
        .grad[, "Asym"] <- 1
        .grad[, "Drop"] <- -.expr5
        .grad[, "lrc"] <- Drop * (.expr5 * (.expr1 * .expr3))
        .grad[, "pwr"] <- Drop * (.expr5 * (.expr1 * (.expr3 * 
            log(x))))
        dimnames(.grad) <- list(NULL, .actualArgs)
        attr(.value, "gradient") <- .grad
    }
    .value
}
<environment: namespace:stats>
attr(,"initial")
function (mCall, data, LHS) 
{
    xy <- sortedXyData(mCall[["x"]], LHS, data)
    if (nrow(xy) < 5) {
        stop("too few distinct input values to fit the Weibull growth model")
    }
    if (any(xy[["x"]] < 0)) {
        stop("all 'x' values must be non-negative to fit the Weibull growth model")
    }
    Rasym <- NLSstRtAsymptote(xy)
    Lasym <- NLSstLfAsymptote(xy)
    pars <- coef(lm(log(-log((Rasym - y)/(Rasym - Lasym))) ~ 
        log(x), data = xy, subset = x > 0))
    val <- coef(nls(y ~ cbind(1, -exp(-exp(lrc) * x^pwr)), data = xy, 
        algorithm = "plinear", start = c(lrc = pars[[1L]], pwr = pars[[2L]])))[c(3, 
        4, 1, 2)]
    names(val) <- mCall[c("Asym", "Drop", "lrc", "pwr")]
    val
}
<environment: namespace:stats>
attr(,"pnames")
[1] "Asym" "Drop" "lrc"  "pwr" 
attr(,"class")
[1] "selfStart"
> print("SignRank"); if(is.function(try(SignRank))) {SignRank;} else{ NULL};
[1] "SignRank"
NULL
> print("StructTS"); if(is.function(try(StructTS))) {StructTS;} else{ NULL};
[1] "StructTS"
function (x, type = c("level", "trend", "BSM"), init = NULL, 
    fixed = NULL, optim.control = NULL) 
{
    KalmanLike2 <- function(y, mod, nit = 0) {
        x <- .Call(R_KalmanLike, y, mod$Z, mod$a, mod$P, mod$T, 
            mod$V, mod$h, mod$Pn, as.integer(nit), FALSE, fast = TRUE)
        0.5 * sum(x)/length(y)
    }
    makeLevel <- function(x) {
        T <- matrix(1, 1L, 1L)
        Z <- 1
        xm <- if (is.na(x[1L])) 
            mean(x, na.rm = TRUE)
        else x[1L]
        if (is.na(xm)) 
            stop("the series is entirely NA")
        a <- xm
        P <- Pn <- matrix(0, 1L, 1L)
        h <- 1
        V <- diag(1)
        return(list(Z = Z, a = a, P = P, T = T, V = V, h = h, 
            Pn = Pn))
    }
    makeTrend <- function(x) {
        T <- matrix(c(1, 0, 1, 1), 2L, 2L)
        Z <- c(1, 0)
        xm <- if (is.na(x[1L])) 
            mean(x, na.rm = TRUE)
        else x[1L]
        if (is.na(xm)) 
            stop("the series is entirely NA")
        a <- c(xm, 0)
        P <- Pn <- matrix(0, 2L, 2L)
        h <- 1
        V <- diag(2)
        return(list(Z = Z, a = a, P = P, T = T, V = V, h = h, 
            Pn = Pn))
    }
    makeBSM <- function(x, nf) {
        if (nf <= 1L) 
            stop("frequency must be a positive integer >= 2 for BSM")
        T <- matrix(0, nf + 1L, nf + 1L)
        T[1L:2L, 1L:2L] <- c(1, 0, 1, 1)
        T[3L, ] <- c(0, 0, rep(-1, nf - 1L))
        if (nf >= 3L) {
            ind <- 3:nf
            T[cbind(ind + 1L, ind)] <- 1
        }
        Z <- c(1, 0, 1, rep(0, nf - 2L))
        xm <- if (is.na(x[1L])) 
            mean(x, na.rm = TRUE)
        else x[1L]
        if (is.na(xm)) 
            stop("the series is entirely NA")
        a <- c(xm, rep(0, nf))
        P <- Pn <- matrix(0, nf + 1L, nf + 1L)
        h <- 1
        V <- diag(c(1, 1, 1, rep(0, nf - 2L)))
        return(list(Z = Z, a = a, P = P, T = T, V = V, h = h, 
            Pn = Pn))
    }
    getLike <- function(par) {
        p <- cf
        p[mask] <- par
        if (all(p == 0)) 
            return(1000)
        Z$V[cbind(1L:np, 1L:np)] <- p[-(np + 1L)] * vx
        Z$h <- p[np + 1] * vx
        Z$P[] <- 1e+06 * vx
        Z$a <- a0
        KalmanLike2(y, Z, -1)
    }
    series <- deparse(substitute(x))
    if (NCOL(x) > 1L) 
        stop("only implemented for univariate time series")
    x <- as.ts(x)
    if (!is.numeric(x)) 
        stop("'x' must be numeric")
    storage.mode(x) <- "double"
    if (is.na(x[1L])) 
        stop("the first value of the time series must not be missing")
    type <- if (missing(type)) 
        if (frequency(x) > 1) 
            "BSM"
        else "trend"
    else match.arg(type)
    dim(x) <- NULL
    xtsp <- tsp(x)
    nf <- frequency(x)
    Z <- switch(type, level = makeLevel(x), trend = makeTrend(x), 
        BSM = makeBSM(x, nf))
    a0 <- Z$a
    vx <- var(x, na.rm = TRUE)/100
    np <- switch(type, level = 1L, trend = 2L, BSM = 3L)
    if (is.null(fixed)) 
        fixed <- rep(NA_real_, np + 1L)
    mask <- is.na(fixed)
    if (!any(mask)) 
        stop("all parameters were fixed")
    cf <- fixed/vx
    if (is.null(init)) 
        init <- rep(1, np + 1)
    else init <- init/vx
    y <- x
    res <- optim(init[mask], getLike, method = "L-BFGS-B", lower = rep(0, 
        np + 1L), upper = rep(Inf, np + 1L), control = optim.control)
    if (res$convergence > 0) 
        warning("possible convergence problem: optim gave code=", 
            res$convergence, " ", res$message)
    coef <- cf
    coef[mask] <- res$par
    Z$V[cbind(1L:np, 1L:np)] <- coef[1L:np] * vx
    Z$h <- coef[np + 1] * vx
    Z$P[] <- 1e+06 * vx
    Z$a <- a0
    z <- KalmanRun(y, Z, -1)
    resid <- ts(z$resid)
    tsp(resid) <- xtsp
    Z0 <- Z
    Z0$P[] <- 1e+06 * vx
    Z0$a <- a0
    cn <- switch(type, level = c("level"), trend = c("level", 
        "slope"), BSM = c("level", "slope", "sea"))
    states <- z$states
    if (type == "BSM") 
        states <- states[, 1L:3L]
    dimnames(states) <- list(time(x), cn)
    states <- ts(states, start = xtsp[1L], frequency = nf)
    coef <- pmax(coef * vx, 0)
    names(coef) <- switch(type, level = c("level", "epsilon"), 
        trend = c("level", "slope", "epsilon"), BSM = c("level", 
            "slope", "seas", "epsilon"))
    loglik <- -length(y) * res$value + length(y) * log(2 * pi)
    res <- list(coef = coef, loglik = loglik, data = y, residuals = resid, 
        fitted = states, call = match.call(), series = series, 
        code = res$convergence, model = Z, model0 = Z0, xtsp = xtsp)
    class(res) <- "StructTS"
    res
}
<environment: namespace:stats>
> print("TDist"); if(is.function(try(TDist))) {TDist;} else{ NULL};
[1] "TDist"
NULL
> print("Tukey"); if(is.function(try(Tukey))) {Tukey;} else{ NULL};
[1] "Tukey"
NULL
> print("TukeyHSD"); if(is.function(try(TukeyHSD))) {TukeyHSD;} else{ NULL};
[1] "TukeyHSD"
function (x, which, ordered = FALSE, conf.level = 0.95, ...) 
UseMethod("TukeyHSD")
<environment: namespace:stats>
> print("Uniform"); if(is.function(try(Uniform))) {Uniform;} else{ NULL};
[1] "Uniform"
NULL
> print("Weibull"); if(is.function(try(Weibull))) {Weibull;} else{ NULL};
[1] "Weibull"
NULL
> print("Wilcoxon"); if(is.function(try(Wilcoxon))) {Wilcoxon;} else{ NULL};
[1] "Wilcoxon"
NULL
> print("acf"); if(is.function(try(acf))) {acf;} else{ NULL};
[1] "acf"
function (x, lag.max = NULL, type = c("correlation", "covariance", 
    "partial"), plot = TRUE, na.action = na.fail, demean = TRUE, 
    ...) 
{
    type <- match.arg(type)
    if (type == "partial") {
        m <- match.call()
        m[[1L]] <- as.name("pacf")
        m$type <- NULL
        return(eval(m, parent.frame()))
    }
    series <- deparse(substitute(x))
    x <- na.action(as.ts(x))
    x.freq <- frequency(x)
    x <- as.matrix(x)
    if (!is.numeric(x)) 
        stop("'x' must be numeric")
    sampleT <- nrow(x)
    nser <- ncol(x)
    if (is.null(lag.max)) 
        lag.max <- floor(10 * (log10(sampleT) - log10(nser)))
    lag.max <- min(lag.max, sampleT - 1)
    if (lag.max < 0) 
        stop("'lag.max' must be at least 0")
    if (demean) 
        x <- sweep(x, 2, colMeans(x, na.rm = TRUE), check.margin = FALSE)
    lag <- matrix(1, nser, nser)
    lag[lower.tri(lag)] <- -1
    acf <- array(.C(R_acf, as.double(x), as.integer(sampleT), 
        as.integer(nser), as.integer(lag.max), as.integer(type == 
            "correlation"), acf = double((lag.max + 1L) * nser * 
            nser), NAOK = TRUE)$acf, c(lag.max + 1L, nser, nser))
    lag <- outer(0:lag.max, lag/x.freq)
    acf.out <- structure(.Data = list(acf = acf, type = type, 
        n.used = sampleT, lag = lag, series = series, snames = colnames(x)), 
        class = "acf")
    if (plot) {
        plot.acf(acf.out, ...)
        return(invisible(acf.out))
    }
    else return(acf.out)
}
<environment: namespace:stats>
> print("acf2AR"); if(is.function(try(acf2AR))) {acf2AR;} else{ NULL};
[1] "acf2AR"
function (acf) 
{
    r <- as.double(drop(acf))
    order.max <- length(r) - 1
    if (order.max <= 0) 
        stop("'acf' must be of length two or more")
    z <- .Fortran(R_eureka, as.integer(order.max), r, r, coefs = double(order.max^2), 
        vars = double(order.max), double(order.max))
    nm <- paste("ar(", 1L:order.max, ")", sep = "")
    matrix(z$coefs, order.max, order.max, dimnames = list(nm, 
        1L:order.max))
}
<environment: namespace:stats>
> print("add1"); if(is.function(try(add1))) {add1;} else{ NULL};
[1] "add1"
function (object, scope, ...) 
UseMethod("add1")
<environment: namespace:stats>
> print("addmargins"); if(is.function(try(addmargins))) {addmargins;} else{ NULL};
[1] "addmargins"
function (A, margin = seq_along(dim(A)), FUN = sum, quiet = FALSE) 
{
    if (is.null(dim(A))) 
        stop("'A' must be an array or table")
    n.sid <- length(margin)
    miss.FUN <- missing(FUN)
    if (length(FUN) == 1 && !is.list(FUN)) {
        fname <- if (!miss.FUN) 
            deparse(substitute(FUN))
        else "Sum"
        FUN <- list(FUN)
        names(FUN) <- fname
    }
    if (!miss.FUN) {
        add.names <- function(thelist) {
            n <- names(thelist)
            if (is.null(n)) 
                n <- rep("", length(thelist))
            for (i in seq_along(thelist)[-1L]) {
                if (!is.call(thelist[[i]])) {
                  if (n[i] == "") 
                    n[i] <- as.character(thelist[[i]])
                }
                else if (as.character(thelist[[i]][[1L]]) == 
                  "list") 
                  thelist[[i]] <- add.names(thelist[[i]])
            }
            names(thelist) <- n
            thelist
        }
        if (mode(substitute(FUN)) == "call") 
            FUN <- eval(add.names(substitute(FUN)))
        if (is.null(names(FUN))) 
            names(FUN) <- rep("", length(FUN))
    }
    if (length(FUN) != n.sid) {
        if (length(FUN) == 1L) 
            FUN <- rep(FUN, n.sid)
        else stop(gettextf("length of FUN, %d,\n does not match the length of the margins, %d", 
            length(FUN), n.sid), domain = NA)
    }
    fnames <- vector("list", n.sid)
    for (i in seq_along(FUN)) {
        fnames[[i]] <- names(FUN)[i]
        if (is.list(FUN[[i]])) {
            topname <- fnames[[i]]
            fnames[[i]] <- names(FUN[[i]])
            blank <- fnames[[i]] == ""
            fnames[[i]][blank] <- seq_along(blank)[blank]
            if (topname == "") {
                fnames[[i]][blank] <- paste("Margin ", margin[i], 
                  ".", fnames[[i]][blank], sep = "")
            }
            else {
                fnames[[i]] <- paste(topname, ".", fnames[[i]], 
                  sep = "")
            }
        }
        else if (fnames[[i]] == "") 
            fnames[[i]] <- paste("Margin", margin[i])
    }
    expand.one <- function(A, margin, FUN, fnames) {
        if (class(FUN) != "list") 
            FUN <- list(FUN)
        d <- dim(A)
        n.dim <- length(d)
        n.mar <- length(FUN)
        newdim <- d
        newdim[margin] <- newdim[margin] + n.mar
        newdimnames <- dimnames(A)
        newdimnames[[margin]] <- c(newdimnames[[margin]], fnames)
        n.new <- prod(newdim)
        skip <- prod(d[1L:margin])
        runl <- skip/d[margin]
        apos <- rep(c(rep(TRUE, skip), rep(FALSE, n.mar * runl)), 
            n.new/(skip + n.mar * runl))
        values <- double(length(apos))
        values[apos] <- as.vector(A)
        for (i in 1L:n.mar) {
            mtab <- if (n.dim > 1) {
                apply(A, (1L:n.dim)[-margin], FUN[[i]])
            }
            else FUN[[i]](A)
            select <- rep(FALSE, n.mar)
            select[i] <- TRUE
            mpos <- rep(c(rep(FALSE, skip), rep(select, each = runl)), 
                prod(dim(A))/skip)
            values[mpos] <- as.vector(mtab)
        }
        new.A <- array(values, dim = newdim, dimnames = newdimnames)
        if (inherits(A, "table")) 
            class(new.A) <- c("table", class(new.A))
        new.A
    }
    new.A <- A
    for (i in 1L:n.sid) new.A <- expand.one(A = new.A, margin = margin[i], 
        FUN = FUN[[i]], fnames = fnames[[i]])
    if (!quiet && !miss.FUN && n.sid > 1) {
        cat("Margins computed over dimensions\nin the following order:\n")
        for (i in 1L:n.sid) cat(paste(i), ": ", names(dimnames(A))[margin[i]], 
            "\n", sep = "")
    }
    new.A
}
<environment: namespace:stats>
> print("aggregate"); if(is.function(try(aggregate))) {aggregate;} else{ NULL};
[1] "aggregate"
function (x, ...) 
UseMethod("aggregate")
<environment: namespace:stats>
> print("alias"); if(is.function(try(alias))) {alias;} else{ NULL};
[1] "alias"
function (object, ...) 
UseMethod("alias")
<environment: namespace:stats>
> print("anova"); if(is.function(try(anova))) {anova;} else{ NULL};
[1] "anova"
function (object, ...) 
UseMethod("anova")
<environment: namespace:stats>
> print("anova.glm"); if(is.function(try(anova.glm))) {anova.glm;} else{ NULL};
[1] "anova.glm"
function (object, ..., dispersion = NULL, test = NULL) 
{
    dotargs <- list(...)
    named <- if (is.null(names(dotargs))) 
        rep(FALSE, length(dotargs))
    else (names(dotargs) != "")
    if (any(named)) 
        warning("the following arguments to 'anova.glm' are invalid and dropped: ", 
            paste(deparse(dotargs[named]), collapse = ", "))
    dotargs <- dotargs[!named]
    is.glm <- unlist(lapply(dotargs, function(x) inherits(x, 
        "glm")))
    dotargs <- dotargs[is.glm]
    if (length(dotargs)) 
        return(anova.glmlist(c(list(object), dotargs), dispersion = dispersion, 
            test = test))
    varlist <- attr(object$terms, "variables")
    x <- if (n <- match("x", names(object), 0L)) 
        object[[n]]
    else model.matrix(object)
    varseq <- attr(x, "assign")
    nvars <- max(0, varseq)
    resdev <- resdf <- NULL
    if (nvars > 1) {
        method <- object$method
        y <- object$y
        if (is.null(y)) {
            mu.eta <- object$family$mu.eta
            eta <- object$linear.predictors
            y <- object$fitted.values + object$residuals * mu.eta(eta)
        }
        for (i in seq_len(nvars - 1L)) {
            fit <- eval(call(if (is.function(method)) "method" else method, 
                x = x[, varseq <= i, drop = FALSE], y = y, weights = object$prior.weights, 
                start = object$start, offset = object$offset, 
                family = object$family, control = object$control))
            resdev <- c(resdev, fit$deviance)
            resdf <- c(resdf, fit$df.residual)
        }
    }
    resdf <- c(object$df.null, resdf, object$df.residual)
    resdev <- c(object$null.deviance, resdev, object$deviance)
    table <- data.frame(c(NA, -diff(resdf)), c(NA, pmax(0, -diff(resdev))), 
        resdf, resdev)
    tl <- attr(object$terms, "term.labels")
    if (length(tl) == 0L) 
        table <- table[1, , drop = FALSE]
    dimnames(table) <- list(c("NULL", tl), c("Df", "Deviance", 
        "Resid. Df", "Resid. Dev"))
    title <- paste("Analysis of Deviance Table", "\n\nModel: ", 
        object$family$family, ", link: ", object$family$link, 
        "\n\nResponse: ", as.character(varlist[-1L])[1L], "\n\nTerms added sequentially (first to last)\n\n", 
        sep = "")
    df.dispersion <- Inf
    if (is.null(dispersion)) {
        dispersion <- summary(object, dispersion = dispersion)$dispersion
        df.dispersion <- if (dispersion == 1) 
            Inf
        else object$df.residual
    }
    if (!is.null(test)) {
        if (test == "F" && df.dispersion == Inf) {
            fam <- object$family$family
            if (fam == "binomial" || fam == "poisson") 
                warning(gettextf("using F test with a %s family is inappropriate", 
                  fam), domain = NA)
            else warning("using F test with a fixed dispersion is inappropriate")
        }
        table <- stat.anova(table = table, test = test, scale = dispersion, 
            df.scale = df.dispersion, n = NROW(x))
    }
    structure(table, heading = title, class = c("anova", "data.frame"))
}
<environment: namespace:stats>
> print("anova.lm"); if(is.function(try(anova.lm))) {anova.lm;} else{ NULL};
[1] "anova.lm"
function (object, ...) 
{
    if (length(list(object, ...)) > 1L) 
        return(anova.lmlist(object, ...))
    if (!inherits(object, "lm")) 
        warning("calling anova.lm(<fake-lm-object>) ...")
    w <- object$weights
    ssr <- sum(if (is.null(w)) object$residuals^2 else w * object$residuals^2)
    mss <- sum(if (is.null(w)) object$fitted.values^2 else w * 
        object$fitted.values^2)
    if (ssr < 1e-10 * mss) 
        warning("ANOVA F-tests on an essentially perfect fit are unreliable")
    dfr <- df.residual(object)
    p <- object$rank
    if (p > 0L) {
        p1 <- 1L:p
        comp <- object$effects[p1]
        asgn <- object$assign[qr.lm(object)$pivot][p1]
        nmeffects <- c("(Intercept)", attr(object$terms, "term.labels"))
        tlabels <- nmeffects[1 + unique(asgn)]
        ss <- c(unlist(lapply(split(comp^2, asgn), sum)), ssr)
        df <- c(unlist(lapply(split(asgn, asgn), length)), dfr)
    }
    else {
        ss <- ssr
        df <- dfr
        tlabels <- character()
    }
    ms <- ss/df
    f <- ms/(ssr/dfr)
    P <- pf(f, df, dfr, lower.tail = FALSE)
    table <- data.frame(df, ss, ms, f, P)
    table[length(P), 4:5] <- NA
    dimnames(table) <- list(c(tlabels, "Residuals"), c("Df", 
        "Sum Sq", "Mean Sq", "F value", "Pr(>F)"))
    if (attr(object$terms, "intercept")) 
        table <- table[-1, ]
    structure(table, heading = c("Analysis of Variance Table\n", 
        paste("Response:", deparse(formula(object)[[2L]]))), 
        class = c("anova", "data.frame"))
}
<environment: namespace:stats>
> print("anova.mlm"); if(is.function(try(anova.mlm))) {anova.mlm;} else{ NULL};
[1] "anova.mlm"
function (object, ..., test = c("Pillai", "Wilks", "Hotelling-Lawley", 
    "Roy", "Spherical"), Sigma = diag(nrow = p), T = Thin.row(proj(M) - 
    proj(X)), M = diag(nrow = p), X = ~0, idata = data.frame(index = seq_len(p)), 
    tol = 1e-07) 
{
    if (length(list(object, ...)) > 1) {
        cl <- match.call()
        cl[[1L]] <- anova.mlmlist
        return(eval.parent(cl))
    }
    else {
        p <- ncol(SSD(object)$SSD)
        Xmis <- missing(X)
        Mmis <- missing(M)
        if (missing(T)) {
            orig.M <- M
            orig.X <- X
            if (class(M) == "formula") 
                M <- model.matrix(M, idata)
            if (class(X) == "formula") 
                X <- model.matrix(X, idata)
            if (Rank(cbind(M, X)) != Rank(M)) 
                stop("X does not define a subspace of M")
        }
        title <- "Analysis of Variance Table\n"
        transformnote <- if (!missing(T)) 
            c("\nContrast matrix", apply(format(T), 1L, paste, 
                collapse = " "))
        else c(if (!Xmis) c("\nContrasts orthogonal to", if (is.matrix(orig.X)) apply(format(X), 
            2L, paste, collapse = " ") else deparse(formula(orig.X)), 
            "", if (!Mmis) c("\nContrasts spanned by", if (is.matrix(orig.M)) apply(format(M), 
                2L, paste, collapse = " ") else deparse(formula(orig.M)), 
                "")))
        epsnote <- NULL
        ssd <- SSD(object)
        rk <- object$rank
        pp <- nrow(T)
        if (rk > 0) {
            p1 <- 1L:rk
            comp <- object$effects[p1, , drop = FALSE]
            asgn <- object$assign[object$qr$pivot][p1]
            nmeffects <- c("(Intercept)", attr(object$terms, 
                "term.labels"))
            tlabels <- nmeffects[1 + unique(asgn)]
            ix <- split(seq_len(nrow(comp)), asgn)
            ss <- lapply(ix, function(i) crossprod(comp[i, , 
                drop = FALSE]))
            df <- sapply(split(asgn, asgn), length)
        }
        else {
        }
        test <- match.arg(test)
        nmodels <- length(ss)
        if (test == "Spherical") {
            df.res <- ssd$df
            sph <- sphericity(ssd, T = T, Sigma = Sigma)
            epsnote <- c(paste(format(c("Greenhouse-Geisser epsilon:", 
                "Huynh-Feldt epsilon:")), format(c(sph$GG.eps, 
                sph$HF.eps), digits = 4)), "")
            Psi <- T %*% Sigma %*% t(T)
            stats <- matrix(NA, nmodels + 1, 6L)
            colnames(stats) <- c("F", "num Df", "den Df", "Pr(>F)", 
                "G-G Pr", "H-F Pr")
            for (i in 1L:nmodels) {
                s2 <- Tr(solve(Psi, T %*% ss[[i]] %*% t(T)))/pp/df[i]
                Fval <- s2/sph$sigma
                stats[i, 1L:3L] <- abs(c(Fval, df[i] * pp, df.res * 
                  pp))
            }
            stats[, 4] <- pf(stats[, 1L], stats[, 2L], stats[, 
                3L], lower.tail = FALSE)
            stats[, 5] <- pf(stats[, 1L], stats[, 2L] * sph$GG.eps, 
                stats[, 3L] * sph$GG.eps, lower.tail = FALSE)
            stats[, 6] <- pf(stats[, 1L], stats[, 2L] * min(1, 
                sph$HF.eps), stats[, 3L] * min(1, sph$HF.eps), 
                lower.tail = FALSE)
        }
        else {
            sc <- sqrt(diag(T %*% ssd$SSD %*% t(T)))
            D <- sqrt(sc^2 + rowSums(as.matrix(sapply(ss, function(X) diag(T %*% 
                X %*% t(T))))))
            sc <- ifelse(sc/D < 1e-06, 1, 1/sc)
            scm <- tcrossprod(sc)
            df.res <- ssd$df
            rss.qr <- qr((T %*% ssd$SSD %*% t(T)) * scm, tol = tol)
            if (rss.qr$rank < pp) 
                stop("residuals have rank ", rss.qr$rank, " < ", 
                  pp)
            eigs <- array(NA, c(nmodels, pp))
            stats <- matrix(NA, nmodels + 1L, 5L)
            colnames(stats) <- c(test, "approx F", "num Df", 
                "den Df", "Pr(>F)")
            for (i in 1L:nmodels) {
                eigs[i, ] <- Re(eigen(qr.coef(rss.qr, (T %*% 
                  ss[[i]] %*% t(T)) * scm), symmetric = FALSE)$values)
                stats[i, 1L:4L] <- switch(test, Pillai = Pillai(eigs[i, 
                  ], df[i], df.res), Wilks = Wilks(eigs[i, ], 
                  df[i], df.res), `Hotelling-Lawley` = HL(eigs[i, 
                  ], df[i], df.res), Roy = Roy(eigs[i, ], df[i], 
                  df.res))
                ok <- stats[, 2L] >= 0 & stats[, 3L] > 0 & stats[, 
                  4L] > 0
                ok <- !is.na(ok) & ok
                stats[ok, 5L] <- pf(stats[ok, 2], stats[ok, 3L], 
                  stats[ok, 4L], lower.tail = FALSE)
            }
        }
        table <- data.frame(Df = c(df, ssd$df), stats, check.names = FALSE)
        row.names(table) <- c(tlabels, "Residuals")
        structure(table, heading = c(title, transformnote, epsnote), 
            class = c("anova", "data.frame"))
    }
}
<environment: namespace:stats>
> print("ansari.test"); if(is.function(try(ansari.test))) {ansari.test;} else{ NULL};
[1] "ansari.test"
function (x, ...) 
UseMethod("ansari.test")
<environment: namespace:stats>
> print("aov"); if(is.function(try(aov))) {aov;} else{ NULL};
[1] "aov"
function (formula, data = NULL, projections = FALSE, qr = TRUE, 
    contrasts = NULL, ...) 
{
    Terms <- if (missing(data)) 
        terms(formula, "Error")
    else terms(formula, "Error", data = data)
    indError <- attr(Terms, "specials")$Error
    if (length(indError) > 1L) 
        stop(sprintf(ngettext(length(indError), "there are %d Error terms: only 1 is allowed", 
            "there are %d Error terms: only 1 is allowed"), length(indError)), 
            domain = NA)
    lmcall <- Call <- match.call()
    lmcall[[1L]] <- as.name("lm")
    lmcall$singular.ok <- TRUE
    if (projections) 
        qr <- lmcall$qr <- TRUE
    lmcall$projections <- NULL
    if (is.null(indError)) {
        fit <- eval(lmcall, parent.frame())
        if (projections) 
            fit$projections <- proj(fit)
        class(fit) <- if (inherits(fit, "mlm")) 
            c("maov", "aov", oldClass(fit))
        else c("aov", oldClass(fit))
        fit$call <- Call
        return(fit)
    }
    else {
        if (pmatch("weights", names(match.call()), 0L)) 
            stop("weights are not supported in a multistratum aov() fit")
        opcons <- options("contrasts")
        options(contrasts = c("contr.helmert", "contr.poly"))
        on.exit(options(opcons))
        allTerms <- Terms
        errorterm <- attr(Terms, "variables")[[1 + indError]]
        eTerm <- deparse(errorterm[[2L]], width.cutoff = 500L, 
            backtick = TRUE)
        intercept <- attr(Terms, "intercept")
        ecall <- lmcall
        ecall$formula <- as.formula(paste(deparse(formula[[2L]], 
            width.cutoff = 500L, backtick = TRUE), "~", eTerm, 
            if (!intercept) 
                "- 1"), env = environment(formula))
        ecall$method <- "qr"
        ecall$qr <- TRUE
        ecall$contrasts <- NULL
        er.fit <- eval(ecall, parent.frame())
        options(opcons)
        nmstrata <- attr(terms(er.fit), "term.labels")
        nmstrata <- sub("^`(.*)`$", "\\1", nmstrata)
        nmstrata <- c("(Intercept)", nmstrata)
        qr.e <- er.fit$qr
        rank.e <- er.fit$rank
        if (rank.e < length(er.fit$coefficients)) 
            warning("Error() model is singular")
        qty <- er.fit$residuals
        maov <- is.matrix(qty)
        asgn.e <- er.fit$assign[qr.e$pivot[1L:rank.e]]
        maxasgn <- length(nmstrata) - 1L
        nobs <- NROW(qty)
        if (nobs > rank.e) {
            result <- vector("list", maxasgn + 2L)
            asgn.e[(rank.e + 1):nobs] <- maxasgn + 1L
            nmstrata <- c(nmstrata, "Within")
        }
        else result <- vector("list", maxasgn + 1L)
        names(result) <- nmstrata
        lmcall$formula <- form <- update(formula, paste(". ~ .-", 
            deparse(errorterm, width.cutoff = 500L, backtick = TRUE)))
        Terms <- terms(form)
        lmcall$method <- "model.frame"
        mf <- eval(lmcall, parent.frame())
        xvars <- as.character(attr(Terms, "variables"))[-1L]
        if ((yvar <- attr(Terms, "response")) > 0L) 
            xvars <- xvars[-yvar]
        if (length(xvars)) {
            xlev <- lapply(mf[xvars], levels)
            xlev <- xlev[!sapply(xlev, is.null)]
        }
        else xlev <- NULL
        resp <- model.response(mf)
        qtx <- model.matrix(Terms, mf, contrasts)
        cons <- attr(qtx, "contrasts")
        dnx <- colnames(qtx)
        asgn.t <- attr(qtx, "assign")
        if (length(wts <- model.weights(mf))) {
            wts <- sqrt(wts)
            resp <- resp * wts
            qtx <- qtx * wts
        }
        qty <- as.matrix(qr.qty(qr.e, resp))
        if ((nc <- ncol(qty)) > 1) {
            dny <- colnames(resp)
            if (is.null(dny)) 
                dny <- paste("Y", 1L:nc, sep = "")
            dimnames(qty) <- list(seq(nrow(qty)), dny)
        }
        else dimnames(qty) <- list(seq(nrow(qty)), NULL)
        qtx <- qr.qty(qr.e, qtx)
        dimnames(qtx) <- list(seq(nrow(qtx)), dnx)
        for (i in seq_along(nmstrata)) {
            select <- asgn.e == (i - 1)
            ni <- sum(select)
            if (!ni) 
                next
            xi <- qtx[select, , drop = FALSE]
            cols <- colSums(xi^2) > 1e-05
            if (any(cols)) {
                xi <- xi[, cols, drop = FALSE]
                attr(xi, "assign") <- asgn.t[cols]
                fiti <- lm.fit(xi, qty[select, , drop = FALSE])
                fiti$terms <- Terms
            }
            else {
                y <- qty[select, , drop = FALSE]
                fiti <- list(coefficients = numeric(), residuals = y, 
                  fitted.values = 0 * y, weights = wts, rank = 0L, 
                  df.residual = NROW(y))
            }
            if (projections) 
                fiti$projections <- proj(fiti)
            class(fiti) <- c(if (maov) "maov", "aov", oldClass(er.fit))
            result[[i]] <- fiti
        }
        result <- result[!sapply(result, is.null)]
        class(result) <- c("aovlist", "listof")
        if (qr) 
            attr(result, "error.qr") <- qr.e
        attr(result, "call") <- Call
        if (length(wts)) 
            attr(result, "weights") <- wts
        attr(result, "terms") <- allTerms
        attr(result, "contrasts") <- cons
        attr(result, "xlevels") <- xlev
        result
    }
}
<environment: namespace:stats>
> print("approxfun"); if(is.function(try(approxfun))) {approxfun;} else{ NULL};
[1] "approxfun"
function (x, y = NULL, method = "linear", yleft, yright, rule = 1, 
    f = 0, ties = mean) 
{
    method <- pmatch(method, c("linear", "constant"))
    if (is.na(method)) 
        stop("invalid interpolation method")
    stopifnot(is.numeric(rule), (lenR <- length(rule)) >= 1L, 
        lenR <= 2L)
    if (lenR == 1) 
        rule <- rule[c(1, 1)]
    x <- regularize.values(x, y, ties)
    y <- x$y
    x <- x$x
    n <- length(x)
    if (n <= 1) {
        if (method == 1) 
            stop("need at least two non-NA values to interpolate")
        if (n == 0) 
            stop("zero non-NA points")
    }
    if (missing(yleft)) 
        yleft <- if (rule[1L] == 1) 
            NA
        else y[1L]
    if (missing(yright)) 
        yright <- if (rule[2L] == 1) 
            NA
        else y[length(y)]
    force(f)
    stopifnot(length(yleft) == 1L, length(yright) == 1L, length(f) == 
        1L)
    rm(rule, ties, lenR)
    .C("R_approxtest", as.double(x), as.double(y), as.integer(n), 
        as.integer(method), as.double(f), NAOK = TRUE, PACKAGE = "stats")
    function(v) .C("R_approxfun", as.double(x), as.double(y), 
        as.integer(n), xout = as.double(v), as.integer(length(v)), 
        as.integer(method), as.double(yleft), as.double(yright), 
        as.double(f), NAOK = TRUE, PACKAGE = "stats")$xout
}
<environment: namespace:stats>
> print("ar"); if(is.function(try(ar))) {ar;} else{ NULL};
[1] "ar"
function (x, aic = TRUE, order.max = NULL, method = c("yule-walker", 
    "burg", "ols", "mle", "yw"), na.action = na.fail, series = deparse(substitute(x)), 
    ...) 
{
    res <- switch(match.arg(method), `yule-walker` = ar.yw(x, 
        aic = aic, order.max = order.max, na.action = na.action, 
        series = series, ...), burg = ar.burg(x, aic = aic, order.max = order.max, 
        na.action = na.action, series = series, ...), ols = ar.ols(x, 
        aic = aic, order.max = order.max, na.action = na.action, 
        series = series, ...), mle = ar.mle(x, aic = aic, order.max = order.max, 
        na.action = na.action, series = series, ...), yw = ar.yw(x, 
        aic = aic, order.max = order.max, na.action = na.action, 
        series = series, ...))
    res$call <- match.call()
    res
}
<environment: namespace:stats>
> print("ar.ols"); if(is.function(try(ar.ols))) {ar.ols;} else{ NULL};
[1] "ar.ols"
function (x, aic = TRUE, order.max = NULL, na.action = na.fail, 
    demean = TRUE, intercept = demean, series = NULL, ...) 
{
    if (is.null(series)) 
        series <- deparse(substitute(x))
    rescale <- TRUE
    ists <- is.ts(x)
    x <- na.action(as.ts(x))
    if (any(is.na(x))) 
        stop("NAs in 'x'")
    if (ists) 
        xtsp <- tsp(x)
    xfreq <- frequency(x)
    x <- as.matrix(x)
    if (!is.numeric(x)) 
        stop("'x' must be numeric")
    n.used <- nrow(x)
    nser <- ncol(x)
    iser <- seq_len(nser)
    if (rescale) {
        sc <- sqrt(drop(apply(x, 2L, var)))
        x <- x/rep.int(sc, rep.int(n.used, nser))
    }
    else sc <- rep.int(1, nser)
    order.max <- if (is.null(order.max)) 
        min(n.used - 1L, floor(10 * log10(n.used)))
    else round(order.max)
    if (order.max < 0L) 
        stop("'order.max' must be >= 0")
    if (order.max >= n.used) 
        stop("'order.max' must be < 'n.used'")
    order.min <- if (aic) 
        0L
    else order.max
    varE <- seA <- A <- vector("list", order.max - order.min + 
        1L)
    xaic <- rep.int(Inf, order.max - order.min + 1L)
    det <- function(x) max(0, prod(diag(qr(x)$qr)) * (-1)^(ncol(x) - 
        1))
    if (demean) {
        xm <- colMeans(x)
        x <- sweep(x, 2L, xm, check.margin = FALSE)
    }
    else xm <- rep.int(0, nser)
    for (m in order.min:order.max) {
        y <- embed(x, m + 1L)
        if (intercept) {
            if (m) 
                X <- cbind(rep.int(1, nrow(y)), y[, (nser + 1L):ncol(y)])
            else X <- as.matrix(rep.int(1, nrow(y)))
        }
        else {
            if (m) 
                X <- y[, (nser + 1L):ncol(y)]
            else X <- matrix(0, nrow(y), 0)
        }
        Y <- t(y[, iser])
        N <- ncol(Y)
        XX <- t(X) %*% X
        rank <- qr(XX)$rank
        if (rank != nrow(XX)) {
            warning(paste("model order: ", m, "singularities in the computation of the projection matrix", 
                "results are only valid up to model order", m - 
                  1L), domain = NA)
            break
        }
        P <- if (ncol(XX) > 0) 
            solve(XX)
        else XX
        A[[m - order.min + 1L]] <- Y %*% X %*% P
        YH <- A[[m - order.min + 1L]] %*% t(X)
        E <- (Y - YH)
        varE[[m - order.min + 1L]] <- tcrossprod(E)/N
        varA <- P %x% (varE[[m - order.min + 1L]])
        seA[[m - order.min + 1L]] <- if (ncol(varA) > 0) 
            sqrt(diag(varA))
        else numeric()
        xaic[m - order.min + 1L] <- n.used * log(det(varE[[m - 
            order.min + 1L]])) + 2 * nser * (nser * m + intercept)
    }
    m <- if (aic) 
        which(xaic == min(xaic))[1L] + order.min - 1L
    else order.max
    y <- embed(x, m + 1L)
    AA <- A[[m - order.min + 1L]]
    if (intercept) {
        xint <- AA[, 1L]
        ar <- AA[, -1L]
        X <- if (m) 
            cbind(rep.int(1, nrow(y)), y[, (nser + 1L):ncol(y)])
        else as.matrix(rep.int(1, nrow(y)))
    }
    else {
        X <- if (m) 
            y[, (nser + 1L):ncol(y)]
        else matrix(0, nrow(y), 0L)
        xint <- NULL
        ar <- AA
    }
    Y <- t(y[, iser, drop = FALSE])
    YH <- AA %*% t(X)
    E <- drop(rbind(matrix(NA, m, nser), t(Y - YH)))
    maic <- min(aic)
    xaic <- if (is.finite(maic)) 
        xaic - min(xaic)
    else ifelse(xaic == maic, 0, Inf)
    names(xaic) <- order.min:order.max
    dim(ar) <- c(nser, nser, m)
    ar <- aperm(ar, c(3L, 1L, 2L))
    ses <- seA[[m - order.min + 1L]]
    if (intercept) {
        sem <- ses[iser]
        ses <- ses[-iser]
    }
    else sem <- rep.int(0, nser)
    dim(ses) <- c(nser, nser, m)
    ses <- aperm(ses, c(3, 1, 2))
    var.pred <- varE[[m - order.min + 1L]]
    if (nser > 1L) {
        snames <- colnames(x)
        dimnames(ses) <- dimnames(ar) <- list(seq_len(m), snames, 
            snames)
        dimnames(var.pred) <- list(snames, snames)
        names(sem) <- colnames(E) <- snames
    }
    if (ists) {
        attr(E, "tsp") <- xtsp
        attr(E, "class") <- "ts"
    }
    if (rescale) {
        xm <- xm * sc
        if (!is.null(xint)) 
            xint <- xint * sc
        aa <- outer(sc, 1/sc)
        if (nser > 1L && m) 
            for (i in seq_len(m)) ar[i, , ] <- ar[i, , ] * aa
        var.pred <- var.pred * drop(outer(sc, sc))
        E <- E * rep.int(sc, rep.int(NROW(E), nser))
        sem <- sem * sc
        if (m) 
            for (i in seq_len(m)) ses[i, , ] <- ses[i, , ] * 
                aa
    }
    res <- list(order = m, ar = ar, var.pred = var.pred, x.mean = xm, 
        x.intercept = xint, aic = xaic, n.used = n.used, order.max = order.max, 
        partialacf = NULL, resid = E, method = "Unconstrained LS", 
        series = series, frequency = xfreq, call = match.call(), 
        asy.se.coef = list(x.mean = sem, ar = drop(ses)))
    class(res) <- "ar"
    res
}
<environment: namespace:stats>
> print("arima"); if(is.function(try(arima))) {arima;} else{ NULL};
[1] "arima"
function (x, order = c(0, 0, 0), seasonal = list(order = c(0, 
    0, 0), period = NA), xreg = NULL, include.mean = TRUE, transform.pars = TRUE, 
    fixed = NULL, init = NULL, method = c("CSS-ML", "ML", "CSS"), 
    n.cond, optim.method = "BFGS", optim.control = list(), kappa = 1e+06) 
{
    "%+%" <- function(a, b) .Call(R_TSconv, a, b)
    upARIMA <- function(mod, phi, theta) {
        p <- length(phi)
        q <- length(theta)
        mod$phi <- phi
        mod$theta <- theta
        r <- max(p, q + 1L)
        if (p > 0) 
            mod$T[1L:p, 1L] <- phi
        if (r > 1L) 
            mod$Pn[1L:r, 1L:r] <- .Call(R_getQ0, phi, theta)
        else if (p > 0) 
            mod$Pn[1L, 1L] <- 1/(1 - phi^2)
        else mod$Pn[1, 1] <- 1
        mod$a[] <- 0
        mod
    }
    arimaSS <- function(y, mod) {
        .Call(R_ARIMA_Like, y, mod$phi, mod$theta, mod$Delta, 
            mod$a, mod$P, mod$Pn, 0L, TRUE)
    }
    armafn <- function(p, trans) {
        par <- coef
        par[mask] <- p
        trarma <- .Call(R_ARIMA_transPars, par, arma, trans)
        Z <- upARIMA(mod, trarma[[1L]], trarma[[2L]])
        if (ncxreg > 0) 
            x <- x - xreg %*% par[narma + (1L:ncxreg)]
        res <- .Call(R_ARIMA_Like, x, Z$phi, Z$theta, Z$Delta, 
            Z$a, Z$P, Z$Pn, 0L, FALSE)
        s2 <- res[1L]/res[3L]
        0.5 * (log(s2) + res[2L]/res[3L])
    }
    armaCSS <- function(p) {
        par <- as.double(fixed)
        par[mask] <- p
        trarma <- .Call(R_ARIMA_transPars, par, arma, FALSE)
        if (ncxreg > 0) 
            x <- x - xreg %*% par[narma + (1L:ncxreg)]
        res <- .Call(R_ARIMA_CSS, x, arma, trarma[[1L]], trarma[[2L]], 
            as.integer(ncond), FALSE)
        0.5 * log(res)
    }
    arCheck <- function(ar) {
        p <- max(which(c(1, -ar) != 0)) - 1
        if (!p) 
            return(TRUE)
        all(Mod(polyroot(c(1, -ar[1L:p]))) > 1)
    }
    maInvert <- function(ma) {
        q <- length(ma)
        q0 <- max(which(c(1, ma) != 0)) - 1L
        if (!q0) 
            return(ma)
        roots <- polyroot(c(1, ma[1L:q0]))
        ind <- Mod(roots) < 1
        if (all(!ind)) 
            return(ma)
        if (q0 == 1) 
            return(c(1/ma[1L], rep(0, q - q0)))
        roots[ind] <- 1/roots[ind]
        x <- 1
        for (r in roots) x <- c(x, 0) - c(0, x)/r
        c(Re(x[-1L]), rep(0, q - q0))
    }
    series <- deparse(substitute(x))
    if (NCOL(x) > 1L) 
        stop("only implemented for univariate time series")
    method <- match.arg(method)
    x <- as.ts(x)
    if (!is.numeric(x)) 
        stop("'x' must be numeric")
    storage.mode(x) <- "double"
    dim(x) <- NULL
    n <- length(x)
    if (!missing(order)) 
        if (!is.numeric(order) || length(order) != 3L || any(order < 
            0)) 
            stop("'order' must be a non-negative numeric vector of length 3")
    if (!missing(seasonal)) 
        if (is.list(seasonal)) {
            if (is.null(seasonal$order)) 
                stop("'seasonal' must be a list with component 'order'")
            if (!is.numeric(seasonal$order) || length(seasonal$order) != 
                3L || any(seasonal$order < 0L)) 
                stop("'seasonal$order' must be a non-negative numeric vector of length 3")
        }
        else if (is.numeric(order)) {
            if (length(order) == 3L) 
                seasonal <- list(order = seasonal)
            else ("'seasonal' is of the wrong length")
        }
        else stop("'seasonal' must be a list with component 'order'")
    if (is.null(seasonal$period) || is.na(seasonal$period) || 
        seasonal$period == 0) 
        seasonal$period <- frequency(x)
    arma <- as.integer(c(order[-2L], seasonal$order[-2L], seasonal$period, 
        order[2L], seasonal$order[2L]))
    narma <- sum(arma[1L:4L])
    xtsp <- tsp(x)
    tsp(x) <- NULL
    Delta <- 1
    for (i in seq_len(order[2L])) Delta <- Delta %+% c(1, -1)
    for (i in seq_len(seasonal$order[2L])) Delta <- Delta %+% 
        c(1, rep(0, seasonal$period - 1), -1)
    Delta <- -Delta[-1L]
    nd <- order[2L] + seasonal$order[2L]
    n.used <- sum(!is.na(x)) - length(Delta)
    if (is.null(xreg)) {
        ncxreg <- 0L
    }
    else {
        nmxreg <- deparse(substitute(xreg))
        if (NROW(xreg) != n) 
            stop("lengths of 'x' and 'xreg' do not match")
        ncxreg <- NCOL(xreg)
        xreg <- as.matrix(xreg)
        storage.mode(xreg) <- "double"
    }
    class(xreg) <- NULL
    if (ncxreg > 0L && is.null(colnames(xreg))) 
        colnames(xreg) <- if (ncxreg == 1L) 
            nmxreg
        else paste(nmxreg, 1L:ncxreg, sep = "")
    if (include.mean && (nd == 0L)) {
        xreg <- cbind(intercept = rep(1, n), xreg = xreg)
        ncxreg <- ncxreg + 1L
    }
    if (method == "CSS-ML") {
        anyna <- any(is.na(x))
        if (ncxreg) 
            anyna <- anyna || any(is.na(xreg))
        if (anyna) 
            method <- "ML"
    }
    if (method == "CSS" || method == "CSS-ML") {
        ncond <- order[2L] + seasonal$order[2L] * seasonal$period
        ncond1 <- order[1L] + seasonal$period * seasonal$order[1L]
        ncond <- if (!missing(n.cond)) 
            ncond + max(n.cond, ncond1)
        else ncond + ncond1
    }
    else ncond <- 0
    if (is.null(fixed)) 
        fixed <- rep(NA_real_, narma + ncxreg)
    else if (length(fixed) != narma + ncxreg) 
        stop("wrong length for 'fixed'")
    mask <- is.na(fixed)
    no.optim <- !any(mask)
    if (no.optim) 
        transform.pars <- FALSE
    if (transform.pars) {
        ind <- arma[1L] + arma[2L] + seq_len(arma[3L])
        if (any(!mask[seq_len(arma[1L])]) || any(!mask[ind])) {
            warning("some AR parameters were fixed: setting transform.pars = FALSE")
            transform.pars <- FALSE
        }
    }
    init0 <- rep(0, narma)
    parscale <- rep(1, narma)
    if (ncxreg) {
        cn <- colnames(xreg)
        orig.xreg <- (ncxreg == 1L) || any(!mask[narma + 1L:ncxreg])
        if (!orig.xreg) {
            S <- svd(na.omit(xreg))
            xreg <- xreg %*% S$v
        }
        fit <- lm(x ~ xreg - 1, na.action = na.omit)
        n.used <- sum(!is.na(resid(fit))) - length(Delta)
        init0 <- c(init0, coef(fit))
        ses <- summary(fit)$coefficients[, 2L]
        parscale <- c(parscale, 10 * ses)
    }
    if (n.used <= 0) 
        stop("too few non-missing observations")
    if (!is.null(init)) {
        if (length(init) != length(init0)) 
            stop("'init' is of the wrong length")
        if (any(ind <- is.na(init))) 
            init[ind] <- init0[ind]
        if (method == "ML") {
            if (arma[1L] > 0) 
                if (!arCheck(init[1L:arma[1L]])) 
                  stop("non-stationary AR part")
            if (arma[3L] > 0) 
                if (!arCheck(init[sum(arma[1L:2L]) + 1L:arma[3L]])) 
                  stop("non-stationary seasonal AR part")
            if (transform.pars) 
                init <- .Call(R_ARIMA_Invtrans, as.double(init), 
                  arma)
        }
    }
    else init <- init0
    coef <- as.double(fixed)
    if (!("parscale" %in% names(optim.control))) 
        optim.control$parscale <- parscale[mask]
    if (method == "CSS") {
        res <- if (no.optim) 
            list(convergence = 0L, par = numeric(), value = armaCSS(numeric()))
        else optim(init[mask], armaCSS, method = optim.method, 
            hessian = TRUE, control = optim.control)
        if (res$convergence > 0) 
            warning("possible convergence problem: optim gave code=", 
                res$convergence)
        coef[mask] <- res$par
        trarma <- .Call(R_ARIMA_transPars, coef, arma, FALSE)
        mod <- makeARIMA(trarma[[1L]], trarma[[2L]], Delta, kappa)
        if (ncxreg > 0) 
            x <- x - xreg %*% coef[narma + (1L:ncxreg)]
        arimaSS(x, mod)
        val <- .Call(R_ARIMA_CSS, x, arma, trarma[[1L]], trarma[[2L]], 
            as.integer(ncond), TRUE)
        sigma2 <- val[[1L]]
        var <- if (no.optim) 
            numeric()
        else solve(res$hessian * n.used)
    }
    else {
        if (method == "CSS-ML") {
            res <- if (no.optim) 
                list(convergence = 0L, par = numeric(), value = armaCSS(numeric()))
            else optim(init[mask], armaCSS, method = optim.method, 
                hessian = FALSE, control = optim.control)
            if (res$convergence == 0) 
                init[mask] <- res$par
            if (arma[1L] > 0) 
                if (!arCheck(init[1L:arma[1L]])) 
                  stop("non-stationary AR part from CSS")
            if (arma[3L] > 0) 
                if (!arCheck(init[sum(arma[1L:2L]) + 1L:arma[3L]])) 
                  stop("non-stationary seasonal AR part from CSS")
            ncond <- 0L
        }
        if (transform.pars) {
            init <- .Call(R_ARIMA_Invtrans, init, arma)
            if (arma[2L] > 0) {
                ind <- arma[1L] + 1L:arma[2L]
                init[ind] <- maInvert(init[ind])
            }
            if (arma[4L] > 0) {
                ind <- sum(arma[1L:3L]) + 1L:arma[4L]
                init[ind] <- maInvert(init[ind])
            }
        }
        trarma <- .Call(R_ARIMA_transPars, init, arma, transform.pars)
        mod <- makeARIMA(trarma[[1L]], trarma[[2L]], Delta, kappa)
        res <- if (no.optim) 
            list(convergence = 0, par = numeric(), value = armafn(numeric(), 
                as.logical(transform.pars)))
        else optim(init[mask], armafn, method = optim.method, 
            hessian = TRUE, control = optim.control, trans = as.logical(transform.pars))
        if (res$convergence > 0) 
            warning("possible convergence problem: optim gave code=", 
                res$convergence)
        coef[mask] <- res$par
        if (transform.pars) {
            if (arma[2L] > 0L) {
                ind <- arma[1L] + 1L:arma[2L]
                if (all(mask[ind])) 
                  coef[ind] <- maInvert(coef[ind])
            }
            if (arma[4L] > 0L) {
                ind <- sum(arma[1L:3L]) + 1L:arma[4L]
                if (all(mask[ind])) 
                  coef[ind] <- maInvert(coef[ind])
            }
            if (any(coef[mask] != res$par)) {
                oldcode <- res$convergence
                res <- optim(coef[mask], armafn, method = optim.method, 
                  hessian = TRUE, control = list(maxit = 0, parscale = optim.control$parscale), 
                  trans = TRUE)
                res$convergence <- oldcode
                coef[mask] <- res$par
            }
            A <- .Call(R_ARIMA_Gradtrans, as.double(coef), arma)
            A <- A[mask, mask]
            var <- t(A) %*% solve(res$hessian * n.used) %*% A
            coef <- .Call(R_ARIMA_undoPars, coef, arma)
        }
        else var <- if (no.optim) 
            numeric()
        else solve(res$hessian * n.used)
        trarma <- .Call(R_ARIMA_transPars, coef, arma, FALSE)
        mod <- makeARIMA(trarma[[1L]], trarma[[2L]], Delta, kappa)
        val <- if (ncxreg > 0L) 
            arimaSS(x - xreg %*% coef[narma + (1L:ncxreg)], mod)
        else arimaSS(x, mod)
        sigma2 <- val[[1L]][1L]/n.used
    }
    value <- 2 * n.used * res$value + n.used + n.used * log(2 * 
        pi)
    aic <- if (method != "CSS") 
        value + 2 * sum(mask) + 2
    else NA
    nm <- NULL
    if (arma[1L] > 0L) 
        nm <- c(nm, paste("ar", 1L:arma[1L], sep = ""))
    if (arma[2L] > 0L) 
        nm <- c(nm, paste("ma", 1L:arma[2L], sep = ""))
    if (arma[3L] > 0L) 
        nm <- c(nm, paste("sar", 1L:arma[3L], sep = ""))
    if (arma[4L] > 0L) 
        nm <- c(nm, paste("sma", 1L:arma[4L], sep = ""))
    if (ncxreg > 0L) {
        nm <- c(nm, cn)
        if (!orig.xreg) {
            ind <- narma + 1L:ncxreg
            coef[ind] <- S$v %*% coef[ind]
            A <- diag(narma + ncxreg)
            A[ind, ind] <- S$v
            A <- A[mask, mask]
            var <- A %*% var %*% t(A)
        }
    }
    names(coef) <- nm
    if (!no.optim) 
        dimnames(var) <- list(nm[mask], nm[mask])
    resid <- val[[2L]]
    tsp(resid) <- xtsp
    class(resid) <- "ts"
    res <- list(coef = coef, sigma2 = sigma2, var.coef = var, 
        mask = mask, loglik = -0.5 * value, aic = aic, arma = arma, 
        residuals = resid, call = match.call(), series = series, 
        code = res$convergence, n.cond = ncond, model = mod)
    class(res) <- "Arima"
    res
}
<environment: namespace:stats>
> print("arima.sim"); if(is.function(try(arima.sim))) {arima.sim;} else{ NULL};
[1] "arima.sim"
function (model, n, rand.gen = rnorm, innov = rand.gen(n, ...), 
    n.start = NA, start.innov = rand.gen(n.start, ...), ...) 
{
    if (!is.list(model)) 
        stop("'model' must be list")
    p <- length(model$ar)
    if (p) {
        minroots <- min(Mod(polyroot(c(1, -model$ar))))
        if (minroots <= 1) 
            stop("'ar' part of model is not stationary")
    }
    q <- length(model$ma)
    if (is.na(n.start)) 
        n.start <- p + q + ifelse(p > 0, ceiling(6/log(minroots)), 
            0)
    if (n.start < p + q) 
        stop("burn-in 'n.start' must be as long as 'ar + ma'")
    d <- 0
    if (!is.null(ord <- model$order)) {
        if (length(ord) != 3L) 
            stop("'model$order' must be of length 3")
        if (p != ord[1L]) 
            stop("inconsistent specification of 'ar' order")
        if (q != ord[3L]) 
            stop("inconsistent specification of 'ma' order")
        d <- ord[2L]
        if (d != round(d) || d < 0) 
            stop("number of differences must be a positive integer")
    }
    if (!missing(start.innov) && length(start.innov) < n.start) 
        stop(gettextf("'start.innov' is too short: need %d points", 
            n.start), domain = NA)
    x <- ts(c(start.innov[1L:n.start], innov[1L:n]), start = 1 - 
        n.start)
    if (length(model$ma)) 
        x <- filter(x, c(1, model$ma), sides = 1)
    if (length(model$ar)) 
        x <- filter(x, model$ar, method = "recursive")
    if (n.start > 0) 
        x <- x[-(1L:n.start)]
    if (d > 0) 
        x <- diffinv(x, differences = d)
    as.ts(x)
}
<environment: namespace:stats>
> print("arima0"); if(is.function(try(arima0))) {arima0;} else{ NULL};
[1] "arima0"
function (x, order = c(0, 0, 0), seasonal = list(order = c(0, 
    0, 0), period = NA), xreg = NULL, include.mean = TRUE, delta = 0.01, 
    transform.pars = TRUE, fixed = NULL, init = NULL, method = c("ML", 
        "CSS"), n.cond, optim.control = list()) 
{
    arma0f <- function(p) {
        par <- as.double(fixed)
        par[mask] <- p
        .Call(R_arma0fa, G, par)
    }
    arCheck <- function(ar) {
        p <- max(which(c(1, -ar) != 0)) - 1
        if (!p) 
            return(TRUE)
        all(Mod(polyroot(c(1, -ar[1L:p]))) > 1)
    }
    maInvert <- function(ma) {
        q <- length(ma)
        q0 <- max(which(c(1, ma) != 0)) - 1
        if (!q0) 
            return(ma)
        roots <- polyroot(c(1, ma[1L:q0]))
        ind <- Mod(roots) < 1
        if (all(!ind)) 
            return(ma)
        warning("converting non-invertible initial MA values")
        if (q0 == 1) 
            return(c(1/ma[1L], rep(0, q - q0)))
        roots[ind] <- 1/roots[ind]
        x <- 1
        for (r in roots) x <- c(x, 0) - c(0, x)/r
        c(Re(x[-1L]), rep(0, q - q0))
    }
    series <- deparse(substitute(x))
    if (NCOL(x) > 1) 
        stop("only implemented for univariate time series")
    method <- match.arg(method)
    x <- as.ts(x)
    if (!is.numeric(x)) 
        stop("'x' must be numeric")
    dim(x) <- NULL
    n <- length(x)
    if (!missing(order)) 
        if (!is.numeric(order) || length(order) != 3L || any(order < 
            0)) 
            stop("'order' must be a non-negative numeric vector of length 3")
    if (!missing(seasonal)) 
        if (is.list(seasonal)) {
            if (is.null(seasonal$order)) 
                stop("'seasonal' must be a list with component 'order'")
            if (!is.numeric(seasonal$order) || length(seasonal$order) != 
                3L || any(seasonal$order < 0)) 
                stop("'seasonal$order' must be a non-negative numeric vector of length 3")
        }
        else if (is.numeric(order)) {
            if (length(order) == 3) 
                seasonal <- list(order = seasonal)
            else ("'seasonal' is of the wrong length")
        }
        else stop("'seasonal' must be a list with component 'order'")
    if (is.null(seasonal$period) || is.na(seasonal$period) || 
        seasonal$period == 0) 
        seasonal$period <- frequency(x)
    arma <- c(order[-2L], seasonal$order[-2L], seasonal$period, 
        order[2L], seasonal$order[2L])
    narma <- sum(arma[1L:4L])
    if (d <- order[2L]) 
        x <- diff(x, 1, d)
    if (d <- seasonal$order[2L]) 
        x <- diff(x, seasonal$period, d)
    xtsp <- tsp(x)
    tsp(x) <- NULL
    nd <- order[2L] + seasonal$order[2L]
    n.used <- length(x)
    ncond <- n - n.used
    if (method == "CSS") {
        ncond1 <- order[1L] + seasonal$period * seasonal$order[1L]
        ncond <- if (!missing(n.cond)) 
            ncond + max(n.cond, ncond1)
        else ncond + ncond1
    }
    if (is.null(xreg)) {
        ncxreg <- 0
    }
    else {
        if (NROW(xreg) != n) 
            stop("lengths of 'x' and 'xreg' do not match")
        ncxreg <- NCOL(xreg)
    }
    class(xreg) <- NULL
    if (include.mean && (nd == 0)) {
        if (is.matrix(xreg) && is.null(colnames(xreg))) 
            colnames(xreg) <- paste("xreg", 1L:ncxreg, sep = "")
        xreg <- cbind(intercept = rep(1, n), xreg = xreg)
        ncxreg <- ncxreg + 1
    }
    if (is.null(fixed)) 
        fixed <- rep(NA_real_, narma + ncxreg)
    else if (length(fixed) != narma + ncxreg) 
        stop("wrong length for 'fixed'")
    mask <- is.na(fixed)
    if (!any(mask)) 
        stop("all parameters were fixed")
    if (transform.pars && any(!mask[1L:narma])) {
        warning("some ARMA parameters were fixed: setting transform.pars = FALSE")
        transform.pars <- FALSE
    }
    if (ncxreg) {
        if (d <- order[2L]) 
            xreg <- diff(xreg, 1, d)
        if (d <- seasonal$order[2L]) 
            xreg <- diff(xreg, seasonal$period, d)
        xreg <- as.matrix(xreg)
        if (qr(na.omit(xreg))$rank < ncol(xreg)) 
            stop("'xreg' is collinear")
        if (is.null(cn <- colnames(xreg))) 
            cn <- paste("xreg", 1L:ncxreg, sep = "")
    }
    if (any(is.na(x)) || (ncxreg && any(is.na(xreg)))) 
        if (method == "ML" && delta >= 0) {
            warning("NAs present: setting 'delta' to -1")
            delta <- -1
        }
    init0 <- rep(0, narma)
    parscale <- rep(1, narma)
    if (ncxreg) {
        orig.xreg <- (ncxreg == 1) || any(!mask[narma + 1L:ncxreg])
        if (!orig.xreg) {
            S <- svd(na.omit(xreg))
            xreg <- xreg %*% S$v
        }
        fit <- lm(x ~ xreg - 1, na.action = na.omit)
        init0 <- c(init0, coef(fit))
        ses <- summary(fit)$coefficients[, 2]
        parscale <- c(parscale, ses)
    }
    storage.mode(x) <- storage.mode(xreg) <- "double"
    if (method == "CSS") 
        transform.pars <- 0
    G <- .Call(R_setup_starma, as.integer(arma), x, n.used, xreg, 
        ncxreg, delta, transform.pars > 0, ncond - (n - n.used))
    on.exit(.Call(R_free_starma, G))
    if (!is.null(init)) {
        if (length(init) != length(init0)) 
            stop("'init' is of the wrong length")
        if (any(ind <- is.na(init))) 
            init[ind] <- init0[ind]
        if (transform.pars) {
            if (any(!mask[1L:narma])) 
                warning("transformed ARMA parameters were fixed")
            if (arma[1L] > 0) 
                if (!arCheck(init[1L:arma[1L]])) 
                  stop("non-stationary AR part")
            if (arma[3L] > 0) 
                if (!arCheck(init[sum(arma[1L:2]) + 1L:arma[3L]])) 
                  stop("non-stationary seasonal AR part")
            if (arma[2L] > 0) {
                ind <- arma[1L] + 1L:arma[2L]
                init[ind] <- maInvert(init[ind])
            }
            if (arma[4L] > 0) {
                ind <- sum(arma[1L:3]) + 1L:arma[4L]
                init[ind] <- maInvert(init[ind])
            }
            init <- .Call(R_Invtrans, G, as.double(init))
        }
    }
    else init <- init0
    .Call(R_Starma_method, G, method == "CSS")
    if (!("parscale" %in% names(optim.control))) 
        optim.control$parscale <- parscale[mask]
    res <- optim(init[mask], arma0f, method = "BFGS", hessian = TRUE, 
        control = optim.control)
    if ((code <- res$convergence) > 0) 
        warning("possible convergence problem: optim gave code=", 
            code)
    coef <- res$par
    if (transform.pars) {
        cf <- fixed
        cf[mask] <- coef
        A <- .Call(R_Gradtrans, G, as.double(cf))[mask, mask]
        var <- t(A) %*% solve(res$hessian * length(x)) %*% A
        coef <- .Call(R_Dotrans, G, as.double(cf))[mask]
        .Call(R_set_trans, G, 0)
    }
    else var <- solve(res$hessian * length(x))
    arma0f(coef)
    sigma2 <- .Call(R_get_s2, G)
    resid <- .Call(R_get_resid, G)
    tsp(resid) <- xtsp
    class(resid) <- "ts"
    n.used <- sum(!is.na(resid))
    nm <- NULL
    if (arma[1L] > 0) 
        nm <- c(nm, paste("ar", 1L:arma[1L], sep = ""))
    if (arma[2L] > 0) 
        nm <- c(nm, paste("ma", 1L:arma[2L], sep = ""))
    if (arma[3L] > 0) 
        nm <- c(nm, paste("sar", 1L:arma[3L], sep = ""))
    if (arma[4L] > 0) 
        nm <- c(nm, paste("sma", 1L:arma[4L], sep = ""))
    fixed[mask] <- coef
    if (ncxreg > 0) {
        nm <- c(nm, cn)
        if (!orig.xreg) {
            ind <- narma + 1L:ncxreg
            fixed[ind] <- S$v %*% fixed[ind]
            A <- diag(narma + ncxreg)
            A[ind, ind] <- S$v
            A <- A[mask, mask]
            var <- A %*% var %*% t(A)
        }
    }
    names(fixed) <- nm
    names(arma) <- c("ar", "ma", "sar", "sma", "period", "diff", 
        "sdiff")
    dimnames(var) <- list(nm[mask], nm[mask])
    value <- 2 * n.used * res$value + n.used + n.used * log(2 * 
        pi)
    aic <- if (method != "CSS") 
        value + 2 * length(coef) + 2
    else NA
    res <- list(coef = fixed, sigma2 = sigma2, var.coef = var, 
        mask = mask, loglik = -0.5 * value, aic = aic, arma = arma, 
        residuals = resid, call = match.call(), series = series, 
        code = code, n.cond = ncond)
    class(res) <- "arima0"
    res
}
<environment: namespace:stats>
> print("as.hclust"); if(is.function(try(as.hclust))) {as.hclust;} else{ NULL};
[1] "as.hclust"
function (x, ...) 
UseMethod("as.hclust")
<environment: namespace:stats>
> print("asOneSidedFormula"); if(is.function(try(asOneSidedFormula))) {asOneSidedFormula;} else{ NULL};
[1] "asOneSidedFormula"
function (object) 
{
    if ((mode(object) == "call") && (object[[1L]] == "~")) {
        object <- eval(object)
    }
    if (inherits(object, "formula")) {
        if (length(object) != 2L) {
            stop(gettextf("formula '%s' must be of the form '~expr'", 
                deparse(as.vector(object))), domain = NA)
        }
        return(object)
    }
    do.call("~", list(switch(mode(object), name = , numeric = , 
        call = object, character = as.name(object), expression = object[[1L]], 
        stop(gettextf("'%s' cannot be of mode '%s'", substitute(object), 
            mode(object)), domain = NA))))
}
<environment: namespace:stats>
> print("ave"); if(is.function(try(ave))) {ave;} else{ NULL};
[1] "ave"
function (x, ..., FUN = mean) 
{
    n <- length(list(...))
    if (n) {
        g <- interaction(...)
        split(x, g) <- lapply(split(x, g), FUN)
    }
    else x[] <- FUN(x)
    x
}
<environment: namespace:stats>
> print("bartlett.test"); if(is.function(try(bartlett.test))) {bartlett.test;} else{ NULL};
[1] "bartlett.test"
function (x, ...) 
UseMethod("bartlett.test")
<environment: namespace:stats>
> print("binom.test"); if(is.function(try(binom.test))) {binom.test;} else{ NULL};
[1] "binom.test"
function (x, n, p = 0.5, alternative = c("two.sided", "less", 
    "greater"), conf.level = 0.95) 
{
    DNAME <- deparse(substitute(x))
    xr <- round(x)
    if (any(is.na(x) | (x < 0)) || max(abs(x - xr)) > 1e-07) 
        stop("'x' must be nonnegative and integer")
    x <- xr
    if (length(x) == 2L) {
        n <- sum(x)
        x <- x[1L]
    }
    else if (length(x) == 1L) {
        nr <- round(n)
        if ((length(n) > 1L) || is.na(n) || (n < 1) || abs(n - 
            nr) > 1e-07 || (x > nr)) 
            stop("'n' must be a positive integer >= 'x'")
        DNAME <- paste(DNAME, "and", deparse(substitute(n)))
        n <- nr
    }
    else stop("incorrect length of 'x'")
    if (!missing(p) && (length(p) > 1L || is.na(p) || p < 0 || 
        p > 1)) 
        stop("'p' must be a single number between 0 and 1")
    alternative <- match.arg(alternative)
    if (!((length(conf.level) == 1L) && is.finite(conf.level) && 
        (conf.level > 0) && (conf.level < 1))) 
        stop("'conf.level' must be a single number between 0 and 1")
    PVAL <- switch(alternative, less = pbinom(x, n, p), greater = pbinom(x - 
        1, n, p, lower.tail = FALSE), two.sided = {
        if (p == 0) (x == 0) else if (p == 1) (x == n) else {
            relErr <- 1 + 1e-07
            d <- dbinom(x, n, p)
            m <- n * p
            if (x == m) 1 else if (x < m) {
                i <- seq.int(from = ceiling(m), to = n)
                y <- sum(dbinom(i, n, p) <= d * relErr)
                pbinom(x, n, p) + pbinom(n - y, n, p, lower.tail = FALSE)
            } else {
                i <- seq.int(from = 0, to = floor(m))
                y <- sum(dbinom(i, n, p) <= d * relErr)
                pbinom(y - 1, n, p) + pbinom(x - 1, n, p, lower.tail = FALSE)
            }
        }
    })
    p.L <- function(x, alpha) {
        if (x == 0) 
            0
        else qbeta(alpha, x, n - x + 1)
    }
    p.U <- function(x, alpha) {
        if (x == n) 
            1
        else qbeta(1 - alpha, x + 1, n - x)
    }
    CINT <- switch(alternative, less = c(0, p.U(x, 1 - conf.level)), 
        greater = c(p.L(x, 1 - conf.level), 1), two.sided = {
            alpha <- (1 - conf.level)/2
            c(p.L(x, alpha), p.U(x, alpha))
        })
    attr(CINT, "conf.level") <- conf.level
    ESTIMATE <- x/n
    names(x) <- "number of successes"
    names(n) <- "number of trials"
    names(ESTIMATE) <- names(p) <- "probability of success"
    structure(list(statistic = x, parameter = n, p.value = PVAL, 
        conf.int = CINT, estimate = ESTIMATE, null.value = p, 
        alternative = alternative, method = "Exact binomial test", 
        data.name = DNAME), class = "htest")
}
<environment: namespace:stats>
> print("biplot"); if(is.function(try(biplot))) {biplot;} else{ NULL};
[1] "biplot"
function (x, ...) 
UseMethod("biplot")
<environment: namespace:stats>
> print("biplot.princomp"); if(is.function(try(biplot.princomp))) {biplot.princomp;} else{ NULL};
[1] "biplot.princomp"
NULL
> print("bw.nrd0"); if(is.function(try(bw.nrd0))) {bw.nrd0;} else{ NULL};
[1] "bw.nrd0"
function (x) 
{
    if (length(x) < 2L) 
        stop("need at least 2 data points")
    hi <- sd(x)
    if (!(lo <- min(hi, IQR(x)/1.34))) 
        (lo <- hi) || (lo <- abs(x[1L])) || (lo <- 1)
    0.9 * lo * length(x)^(-0.2)
}
<environment: namespace:stats>
> print("cancor"); if(is.function(try(cancor))) {cancor;} else{ NULL};
[1] "cancor"
function (x, y, xcenter = TRUE, ycenter = TRUE) 
{
    x <- as.matrix(x)
    y <- as.matrix(y)
    if ((nr <- nrow(x)) != nrow(y)) 
        stop("unequal number of rows in 'cancor'")
    ncx <- ncol(x)
    ncy <- ncol(y)
    if (!nr || !ncx || !ncy) 
        stop("dimension 0 in 'x' or 'y'")
    if (is.logical(xcenter)) {
        if (xcenter) {
            xcenter <- colMeans(x, )
            x <- x - rep(xcenter, rep.int(nr, ncx))
        }
        else xcenter <- rep.int(0, ncx)
    }
    else {
        xcenter <- rep(xcenter, length.out = ncx)
        x <- x - rep(xcenter, rep.int(nr, ncx))
    }
    if (is.logical(ycenter)) {
        if (ycenter) {
            ycenter <- colMeans(y)
            y <- y - rep(ycenter, rep.int(nr, ncy))
        }
        else ycenter <- rep.int(0, ncy)
    }
    else {
        ycenter <- rep(ycenter, length.out = ncy)
        y <- y - rep(ycenter, rep.int(nr, ncy))
    }
    qx <- qr(x)
    qy <- qr(y)
    dx <- qx$rank
    if (!dx) 
        stop("'x' has rank 0")
    dy <- qy$rank
    if (!dy) 
        stop("'y' has rank 0")
    z <- svd(qr.qty(qx, qr.qy(qy, diag(1, nr, dy)))[1L:dx, , 
        drop = FALSE], dx, dy)
    xcoef <- backsolve((qx$qr)[1L:dx, 1L:dx, drop = FALSE], z$u)
    rownames(xcoef) <- colnames(x)[qx$pivot][1L:dx]
    ycoef <- backsolve((qy$qr)[1L:dy, 1L:dy, drop = FALSE], z$v)
    rownames(ycoef) <- colnames(y)[qy$pivot][1L:dy]
    list(cor = z$d, xcoef = xcoef, ycoef = ycoef, xcenter = xcenter, 
        ycenter = ycenter)
}
<environment: namespace:stats>
> print("case.names"); if(is.function(try(case.names))) {case.names;} else{ NULL};
[1] "case.names"
function (object, ...) 
UseMethod("case.names")
<environment: namespace:stats>
> print("chisq.test"); if(is.function(try(chisq.test))) {chisq.test;} else{ NULL};
[1] "chisq.test"
function (x, y = NULL, correct = TRUE, p = rep(1/length(x), length(x)), 
    rescale.p = FALSE, simulate.p.value = FALSE, B = 2000) 
{
    DNAME <- deparse(substitute(x))
    if (is.data.frame(x)) 
        x <- as.matrix(x)
    if (is.matrix(x)) {
        if (min(dim(x)) == 1L) 
            x <- as.vector(x)
    }
    if (!is.matrix(x) && !is.null(y)) {
        if (length(x) != length(y)) 
            stop("'x' and 'y' must have the same length")
        DNAME2 <- deparse(substitute(y))
        xname <- if (length(DNAME) > 1L || nchar(DNAME, "w") > 
            30) 
            ""
        else DNAME
        yname <- if (length(DNAME2) > 1L || nchar(DNAME2, "w") > 
            30) 
            ""
        else DNAME2
        OK <- complete.cases(x, y)
        x <- factor(x[OK])
        y <- factor(y[OK])
        if ((nlevels(x) < 2L) || (nlevels(y) < 2L)) 
            stop("'x' and 'y' must have at least 2 levels")
        x <- table(x, y)
        names(dimnames(x)) <- c(xname, yname)
        DNAME <- paste(paste(DNAME, collapse = "\n"), "and", 
            paste(DNAME2, collapse = "\n"))
    }
    if (any(x < 0) || any(is.na(x))) 
        stop("all entries of 'x' must be nonnegative and finite")
    if ((n <- sum(x)) == 0) 
        stop("at least one entry of 'x' must be positive")
    if (simulate.p.value) {
        setMETH <- function() METHOD <<- paste(METHOD, "with simulated p-value\n\t (based on", 
            B, "replicates)")
        almost.1 <- 1 - 64 * .Machine$double.eps
    }
    if (is.matrix(x)) {
        METHOD <- "Pearson's Chi-squared test"
        nr <- nrow(x)
        nc <- ncol(x)
        sr <- rowSums(x)
        sc <- colSums(x)
        E <- outer(sr, sc, "*")/n
        v <- function(r, c, n) c * r * (n - r) * (n - c)/n^3
        V <- outer(sr, sc, v, n)
        dimnames(E) <- dimnames(x)
        if (simulate.p.value && all(sr > 0) && all(sc > 0)) {
            setMETH()
            tmp <- .C(R_chisqsim, as.integer(nr), as.integer(nc), 
                as.integer(sr), as.integer(sc), as.integer(n), 
                as.integer(B), as.double(E), integer(nr * nc), 
                double(n + 1), integer(nc), results = double(B))
            STATISTIC <- sum(sort((x - E)^2/E, decreasing = TRUE))
            PARAMETER <- NA
            PVAL <- (1 + sum(tmp$results >= almost.1 * STATISTIC))/(B + 
                1)
        }
        else {
            if (simulate.p.value) 
                warning("cannot compute simulated p-value with zero marginals")
            if (correct && nrow(x) == 2 && ncol(x) == 2) {
                YATES <- 0.5
                METHOD <- paste(METHOD, "with Yates' continuity correction")
            }
            else YATES <- 0
            STATISTIC <- sum((abs(x - E) - YATES)^2/E)
            PARAMETER <- (nr - 1) * (nc - 1)
            PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
        }
    }
    else {
        if (length(x) == 1L) 
            stop("'x' must at least have 2 elements")
        if (length(x) != length(p)) 
            stop("'x' and 'p' must have the same number of elements")
        if (any(p < 0)) 
            stop("probabilities must be non-negative.")
        if (abs(sum(p) - 1) > sqrt(.Machine$double.eps)) {
            if (rescale.p) 
                p <- p/sum(p)
            else stop("probabilities must sum to 1.")
        }
        METHOD <- "Chi-squared test for given probabilities"
        E <- n * p
        V <- n * p * (1 - p)
        names(E) <- names(x)
        STATISTIC <- sum((x - E)^2/E)
        if (simulate.p.value) {
            setMETH()
            nx <- length(x)
            sm <- matrix(sample.int(nx, B * n, TRUE, prob = p), 
                nrow = n)
            ss <- apply(sm, 2L, function(x, E, k) {
                sum((table(factor(x, levels = 1L:k)) - E)^2/E)
            }, E = E, k = nx)
            PARAMETER <- NA
            PVAL <- (1 + sum(ss >= almost.1 * STATISTIC))/(B + 
                1)
        }
        else {
            PARAMETER <- length(x) - 1
            PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
        }
    }
    names(STATISTIC) <- "X-squared"
    names(PARAMETER) <- "df"
    if (any(E < 5) && is.finite(PARAMETER)) 
        warning("Chi-squared approximation may be incorrect")
    structure(list(statistic = STATISTIC, parameter = PARAMETER, 
        p.value = PVAL, method = METHOD, data.name = DNAME, observed = x, 
        expected = E, residuals = (x - E)/sqrt(E), stdres = (x - 
            E)/sqrt(V)), class = "htest")
}
<environment: namespace:stats>
> print("cmdscale"); if(is.function(try(cmdscale))) {cmdscale;} else{ NULL};
[1] "cmdscale"
function (d, k = 2, eig = FALSE, add = FALSE, x.ret = FALSE) 
{
    if (any(is.na(d))) 
        stop("NA values not allowed in 'd'")
    if (is.null(n <- attr(d, "Size"))) {
        if (add) 
            d <- as.matrix(d)
        x <- as.matrix(d^2)
        if ((n <- nrow(x)) != ncol(x)) 
            stop("distances must be result of 'dist' or a square matrix")
        rn <- rownames(x)
    }
    else {
        rn <- attr(d, "Labels")
        x <- matrix(0, n, n)
        if (add) 
            d0 <- x
        x[row(x) > col(x)] <- d^2
        x <- x + t(x)
        if (add) {
            d0[row(x) > col(x)] <- d
            d <- d0 + t(d0)
        }
    }
    if ((k <- as.integer(k)) > n - 1 || k < 1) 
        stop("'k' must be in {1, 2, ..  n - 1}")
    storage.mode(x) <- "double"
    .C(R_dblcen, x, as.integer(n), DUP = FALSE)
    if (add) {
        i2 <- n + (i <- 1L:n)
        Z <- matrix(0, 2L * n, 2L * n)
        Z[cbind(i2, i)] <- -1
        Z[i, i2] <- -x
        Z[i2, i2] <- .C(R_dblcen, x = 2 * d, as.integer(n))$x
        e <- eigen(Z, symmetric = FALSE, only.values = TRUE)$values
        add.c <- max(Re(e))
        x <- matrix(double(n * n), n, n)
        non.diag <- row(d) != col(d)
        x[non.diag] <- (d[non.diag] + add.c)^2
        .C(R_dblcen, x, as.integer(n), DUP = FALSE)
    }
    e <- eigen(-x/2, symmetric = TRUE)
    ev <- e$values[seq_len(k)]
    evec <- e$vectors[, seq_len(k), drop = FALSE]
    k1 <- sum(ev > 0)
    if (k1 < k) {
        warning(gettextf("only %d of the first %d eigenvalues are > 0", 
            k1, k), domain = NA)
        evec <- evec[, ev > 0, drop = FALSE]
        ev <- ev[ev > 0]
    }
    points <- evec * rep(sqrt(ev), each = n)
    dimnames(points) <- list(rn, NULL)
    if (eig || x.ret || add) {
        evalus <- e$values
        list(points = points, eig = if (eig) evalus, x = if (x.ret) x, 
            ac = if (add) add.c else 0, GOF = sum(ev)/c(sum(abs(evalus)), 
                sum(pmax(evalus, 0))))
    }
    else points
}
<environment: namespace:stats>
> print("coef"); if(is.function(try(coef))) {coef;} else{ NULL};
[1] "coef"
function (object, ...) 
UseMethod("coef")
<environment: namespace:stats>
> print("complete.cases"); if(is.function(try(complete.cases))) {complete.cases;} else{ NULL};
[1] "complete.cases"
function (...) 
.Internal(complete.cases(...))
<environment: namespace:stats>
> print("confint"); if(is.function(try(confint))) {confint;} else{ NULL};
[1] "confint"
function (object, parm, level = 0.95, ...) 
UseMethod("confint")
<environment: namespace:stats>
> print("constrOptim"); if(is.function(try(constrOptim))) {constrOptim;} else{ NULL};
[1] "constrOptim"
function (theta, f, grad, ui, ci, mu = 1e-04, control = list(), 
    method = if (is.null(grad)) "Nelder-Mead" else "BFGS", outer.iterations = 100, 
    outer.eps = 1e-05, ..., hessian = FALSE) 
{
    if (!is.null(control$fnscale) && control$fnscale < 0) 
        mu <- -mu
    R <- function(theta, theta.old, ...) {
        ui.theta <- ui %*% theta
        gi <- ui.theta - ci
        if (any(gi < 0)) 
            return(NaN)
        gi.old <- ui %*% theta.old - ci
        bar <- sum(gi.old * log(gi) - ui.theta)
        if (!is.finite(bar)) 
            bar <- -Inf
        f(theta, ...) - mu * bar
    }
    dR <- function(theta, theta.old, ...) {
        ui.theta <- ui %*% theta
        gi <- drop(ui.theta - ci)
        gi.old <- drop(ui %*% theta.old - ci)
        dbar <- colSums(ui * gi.old/gi - ui)
        grad(theta, ...) - mu * dbar
    }
    if (any(ui %*% theta - ci <= 0)) 
        stop("initial value is not in the interior of the feasible region")
    obj <- f(theta, ...)
    r <- R(theta, theta, ...)
    fun <- function(theta, ...) R(theta, theta.old, ...)
    gradient <- if (method == "SANN") {
        if (missing(grad)) 
            NULL
        else grad
    }
    else function(theta, ...) dR(theta, theta.old, ...)
    totCounts <- 0
    s.mu <- sign(mu)
    for (i in seq_len(outer.iterations)) {
        obj.old <- obj
        r.old <- r
        theta.old <- theta
        a <- optim(theta.old, fun, gradient, control = control, 
            method = method, hessian = hessian, ...)
        r <- a$value
        if (is.finite(r) && is.finite(r.old) && abs(r - r.old) < 
            (0.001 + abs(r)) * outer.eps) 
            break
        theta <- a$par
        totCounts <- totCounts + a$counts
        obj <- f(theta, ...)
        if (s.mu * obj > s.mu * obj.old) 
            break
    }
    if (i == outer.iterations) {
        a$convergence <- 7
        a$message <- gettext("Barrier algorithm ran out of iterations and did not converge")
    }
    if (mu > 0 && obj > obj.old) {
        a$convergence <- 11
        a$message <- gettextf("Objective function increased at outer iteration %d", 
            i)
    }
    if (mu < 0 && obj < obj.old) {
        a$convergence <- 11
        a$message <- gettextf("Objective function decreased at outer iteration %d", 
            i)
    }
    a$outer.iterations <- i
    a$counts <- totCounts
    a$barrier.value <- a$value
    a$value <- f(a$par, ...)
    a$barrier.value <- a$barrier.value - a$value
    a
}
<environment: namespace:stats>
> print("contr.helmert"); if(is.function(try(contr.helmert))) {contr.helmert;} else{ NULL};
[1] "contr.helmert"
function (n, contrasts = TRUE, sparse = FALSE) 
{
    if (length(n) <= 1L) {
        if (is.numeric(n) && length(n) == 1L && n > 1L) 
            levels <- seq_len(n)
        else stop("not enough degrees of freedom to define contrasts")
    }
    else levels <- n
    levels <- as.character(levels)
    if (contrasts) {
        n <- length(levels)
        cont <- array(-1, c(n, n - 1L), list(levels, NULL))
        cont[col(cont) <= row(cont) - 2L] <- 0
        cont[col(cont) == row(cont) - 1L] <- seq_len(n - 1L)
        colnames(cont) <- NULL
        if (sparse) 
            .asSparse(cont)
        else cont
    }
    else .Diag(levels, sparse = sparse)
}
<environment: namespace:stats>
> print("contrasts"); if(is.function(try(contrasts))) {contrasts;} else{ NULL};
[1] "contrasts"
function (x, contrasts = TRUE, sparse = FALSE) 
{
    if (is.logical(x)) 
        x <- factor(x, levels = c(FALSE, TRUE))
    if (!is.factor(x)) 
        stop("contrasts apply only to factors")
    if (!contrasts) 
        return(.Diag(levels(x), sparse = sparse))
    ctr <- attr(x, "contrasts")
    if ((NL <- is.null(ctr)) || is.character(ctr)) {
        if (NL) 
            ctr <- getOption("contrasts")[[if (is.ordered(x)) 
                2L
            else 1L]]
        ctrfn <- get(ctr, mode = "function", envir = parent.frame())
        if (useSparse <- isTRUE(sparse)) {
            if (!(useSparse <- any("sparse" == names(formals(ctrfn))))) 
                warning(sprintf("contrast function '%s' does not support 'sparse = TRUE'", 
                  ctr), domain = NA)
        }
        ctr <- if (useSparse) 
            ctrfn(levels(x), contrasts = contrasts, sparse = sparse)
        else ctrfn(levels(x), contrasts = contrasts)
    }
    ctr
}
<environment: namespace:stats>
> print("convolve"); if(is.function(try(convolve))) {convolve;} else{ NULL};
[1] "convolve"
function (x, y, conj = TRUE, type = c("circular", "open", "filter")) 
{
    type <- match.arg(type)
    n <- length(x)
    ny <- length(y)
    Real <- is.numeric(x) && is.numeric(y)
    if (type == "circular") {
        if (ny != n) 
            stop("length mismatch in convolution")
    }
    else {
        n1 <- ny - 1
        x <- c(rep.int(0, n1), x)
        n <- length(y <- c(y, rep.int(0, n - 1)))
    }
    x <- fft(fft(x) * (if (conj) 
        Conj(fft(y))
    else fft(y)), inverse = TRUE)
    if (type == "filter") 
        (if (Real) 
            Re(x)
        else x)[-c(1L:n1, (n - n1 + 1L):n)]/n
    else (if (Real) 
        Re(x)
    else x)/n
}
<environment: namespace:stats>
> print("cophenetic"); if(is.function(try(cophenetic))) {cophenetic;} else{ NULL};
[1] "cophenetic"
function (x) 
UseMethod("cophenetic")
<environment: namespace:stats>
> print("cor"); if(is.function(try(cor))) {cor;} else{ NULL};
[1] "cor"
function (x, y = NULL, use = "everything", method = c("pearson", 
    "kendall", "spearman")) 
{
    na.method <- pmatch(use, c("all.obs", "complete.obs", "pairwise.complete.obs", 
        "everything", "na.or.complete"))
    if (is.na(na.method)) 
        stop("invalid 'use' argument")
    method <- match.arg(method)
    if (is.data.frame(y)) 
        y <- as.matrix(y)
    if (is.data.frame(x)) 
        x <- as.matrix(x)
    if (!is.matrix(x) && is.null(y)) 
        stop("supply both 'x' and 'y' or a matrix-like 'x'")
    if (!(is.numeric(x) || is.logical(x))) 
        stop("'x' must be numeric")
    stopifnot(is.atomic(x))
    if (!is.null(y)) {
        if (!(is.numeric(y) || is.logical(y))) 
            stop("'y' must be numeric")
        stopifnot(is.atomic(y))
    }
    Rank <- function(u) {
        if (length(u) == 0L) 
            u
        else if (is.matrix(u)) {
            if (nrow(u) > 1L) 
                apply(u, 2L, rank, na.last = "keep")
            else row(u)
        }
        else rank(u, na.last = "keep")
    }
    if (method == "pearson") 
        .Internal(cor(x, y, na.method, FALSE))
    else if (na.method %in% c(2L, 5L)) {
        if (is.null(y)) {
            .Internal(cor(Rank(na.omit(x)), NULL, na.method, 
                method == "kendall"))
        }
        else {
            nas <- attr(na.omit(cbind(x, y)), "na.action")
            dropNA <- function(x, nas) {
                if (length(nas)) {
                  if (is.matrix(x)) 
                    x[-nas, , drop = FALSE]
                  else x[-nas]
                }
                else x
            }
            .Internal(cor(Rank(dropNA(x, nas)), Rank(dropNA(y, 
                nas)), na.method, method == "kendall"))
        }
    }
    else if (na.method != 3L) {
        x <- Rank(x)
        if (!is.null(y)) 
            y <- Rank(y)
        .Internal(cor(x, y, na.method, method == "kendall"))
    }
    else {
        if (is.null(y)) {
            ncy <- ncx <- ncol(x)
            if (ncx == 0) 
                stop("'x' is empty")
            r <- matrix(0, nrow = ncx, ncol = ncy)
            for (i in seq_len(ncx)) {
                for (j in seq_len(i)) {
                  x2 <- x[, i]
                  y2 <- x[, j]
                  ok <- complete.cases(x2, y2)
                  x2 <- rank(x2[ok])
                  y2 <- rank(y2[ok])
                  r[i, j] <- if (any(ok)) 
                    .Internal(cor(x2, y2, 1L, method == "kendall"))
                  else NA
                }
            }
            r <- r + t(r) - diag(diag(r))
            rownames(r) <- colnames(x)
            colnames(r) <- colnames(x)
            r
        }
        else {
            if (length(x) == 0L || length(y) == 0L) 
                stop("both 'x' and 'y' must be non-empty")
            matrix_result <- is.matrix(x) || is.matrix(y)
            if (!is.matrix(x)) 
                x <- matrix(x, ncol = 1L)
            if (!is.matrix(y)) 
                y <- matrix(y, ncol = 1L)
            ncx <- ncol(x)
            ncy <- ncol(y)
            r <- matrix(0, nrow = ncx, ncol = ncy)
            for (i in seq_len(ncx)) {
                for (j in seq_len(ncy)) {
                  x2 <- x[, i]
                  y2 <- y[, j]
                  ok <- complete.cases(x2, y2)
                  x2 <- rank(x2[ok])
                  y2 <- rank(y2[ok])
                  r[i, j] <- if (any(ok)) 
                    .Internal(cor(x2, y2, 1L, method == "kendall"))
                  else NA
                }
            }
            rownames(r) <- colnames(x)
            colnames(r) <- colnames(y)
            if (matrix_result) 
                r
            else drop(r)
        }
    }
}
<environment: namespace:stats>
> print("cor.test"); if(is.function(try(cor.test))) {cor.test;} else{ NULL};
[1] "cor.test"
function (x, ...) 
UseMethod("cor.test")
<environment: namespace:stats>
> print("cov.wt"); if(is.function(try(cov.wt))) {cov.wt;} else{ NULL};
[1] "cov.wt"
function (x, wt = rep(1/nrow(x), nrow(x)), cor = FALSE, center = TRUE, 
    method = c("unbiased", "ML")) 
{
    if (is.data.frame(x)) 
        x <- as.matrix(x)
    else if (!is.matrix(x)) 
        stop("'x' must be a matrix or a data frame")
    if (!all(is.finite(x))) 
        stop("'x' must contain finite values only")
    n <- nrow(x)
    if (with.wt <- !missing(wt)) {
        if (length(wt) != n) 
            stop("length of 'wt' must equal the number of rows in 'x'")
        if (any(wt < 0) || (s <- sum(wt)) == 0) 
            stop("weights must be non-negative and not all zero")
        wt <- wt/s
    }
    if (is.logical(center)) {
        center <- if (center) 
            colSums(wt * x)
        else 0
    }
    else {
        if (length(center) != ncol(x)) 
            stop("length of 'center' must equal the number of columns in 'x'")
    }
    x <- sqrt(wt) * sweep(x, 2, center, check.margin = FALSE)
    cov <- switch(match.arg(method), unbiased = crossprod(x)/(1 - 
        sum(wt^2)), ML = crossprod(x))
    y <- list(cov = cov, center = center, n.obs = n)
    if (with.wt) 
        y$wt <- wt
    if (cor) {
        Is <- 1/sqrt(diag(cov))
        R <- cov
        R[] <- Is * cov * rep(Is, each = nrow(cov))
        y$cor <- R
    }
    y
}
<environment: namespace:stats>
> print("cpgram"); if(is.function(try(cpgram))) {cpgram;} else{ NULL};
[1] "cpgram"
function (ts, taper = 0.1, main = paste("Series: ", deparse(substitute(ts))), 
    ci.col = "blue") 
{
    main
    if (NCOL(ts) > 1) 
        stop("only implemented for univariate time series")
    x <- as.vector(ts)
    x <- x[!is.na(x)]
    x <- spec.taper(scale(x, TRUE, FALSE), p = taper)
    y <- Mod(fft(x))^2/length(x)
    y[1L] <- 0
    n <- length(x)
    x <- (0:(n/2)) * frequency(ts)/n
    if (length(x)%%2 == 0) {
        n <- length(x) - 1
        y <- y[1L:n]
        x <- x[1L:n]
    }
    else y <- y[seq_along(x)]
    xm <- frequency(ts)/2
    mp <- length(x) - 1
    crit <- 1.358/(sqrt(mp) + 0.12 + 0.11/sqrt(mp))
    oldpty <- par(pty = "s")
    on.exit(par(oldpty))
    plot(x, cumsum(y)/sum(y), type = "s", xlim = c(0, xm), ylim = c(0, 
        1), xaxs = "i", yaxs = "i", xlab = "frequency", ylab = "")
    lines(c(0, xm * (1 - crit)), c(crit, 1), col = ci.col, lty = 2)
    lines(c(xm * crit, xm), c(0, 1 - crit), col = ci.col, lty = 2)
    title(main = main)
    invisible()
}
<environment: namespace:stats>
> print("cutree"); if(is.function(try(cutree))) {cutree;} else{ NULL};
[1] "cutree"
function (tree, k = NULL, h = NULL) 
{
    if (is.null(n1 <- nrow(tree$merge)) || n1 < 1) 
        stop("invalid 'tree' (merge component)")
    n <- n1 + 1
    if (is.null(k) && is.null(h)) 
        stop("either 'k' or 'h' must be specified")
    if (is.null(k)) {
        if (is.unsorted(tree$height)) 
            stop("the 'height' component of 'tree' is not sorted\n(increasingly); consider applying as.hclust() first")
        k <- n + 1L - apply(outer(c(tree$height, Inf), h, ">"), 
            2, which.max)
        if (getOption("verbose")) 
            message("cutree(): k(h) = ", k, domain = NA)
    }
    else {
        k <- as.integer(k)
        if (min(k) < 1 || max(k) > n) 
            stop(gettextf("elements of 'k' must be between 1 and %d", 
                n), domain = NA)
    }
    ans <- .Call("R_cutree", tree$merge, k, PACKAGE = "stats")
    if (length(k) == 1L) {
        ans <- as.vector(ans)
        names(ans) <- tree$labels
    }
    else {
        colnames(ans) <- if (!is.null(h)) 
            h
        else k
        rownames(ans) <- tree$labels
    }
    return(ans)
}
<environment: namespace:stats>
> print("decompose"); if(is.function(try(decompose))) {decompose;} else{ NULL};
[1] "decompose"
function (x, type = c("additive", "multiplicative"), filter = NULL) 
{
    type <- match.arg(type)
    l <- length(x)
    f <- frequency(x)
    if (f <= 1 || length(na.omit(x)) < 2 * f) 
        stop("time series has no or less than 2 periods")
    if (is.null(filter)) 
        filter <- if (!f%%2) 
            c(0.5, rep(1, f - 1), 0.5)/f
        else rep(1, f)/f
    trend <- filter(x, filter)
    season <- if (type == "additive") 
        x - trend
    else x/trend
    season <- na.omit(c(as.numeric(window(season, start(x) + 
        c(1, 0), end(x))), as.numeric(window(season, start(x), 
        start(x) + c(0, f)))))
    periods <- l%/%f
    index <- c(0, cumsum(rep(f, periods - 2)))
    figure <- numeric(f)
    for (i in 1L:f) figure[i] <- mean(season[index + i])
    figure <- if (type == "additive") 
        figure - mean(figure)
    else figure/mean(figure)
    seasonal <- ts(rep(figure, periods + 1)[seq_len(l)], start = start(x), 
        frequency = f)
    structure(list(seasonal = seasonal, trend = trend, random = if (type == 
        "additive") x - seasonal - trend else x/seasonal/trend, 
        figure = figure, type = type), class = "decomposed.ts")
}
<environment: namespace:stats>
> print("delete.response"); if(is.function(try(delete.response))) {delete.response;} else{ NULL};
[1] "delete.response"
function (termobj) 
{
    a <- attributes(termobj)
    y <- a$response
    if (!is.null(y) && y) {
        termobj[[2L]] <- NULL
        a$response <- 0
        a$variables <- a$variables[-(1 + y)]
        a$predvars <- a$predvars[-(1 + y)]
        if (length(a$factors)) 
            a$factors <- a$factors[-y, , drop = FALSE]
        if (length(a$offset)) 
            a$offset <- ifelse(a$offset > y, a$offset - 1, a$offset)
        if (length(a$specials)) 
            for (i in seq_along(a$specials)) {
                b <- a$specials[[i]]
                a$specials[[i]] <- ifelse(b > y, b - 1, b)
            }
        attributes(termobj) <- a
    }
    termobj
}
<environment: namespace:stats>
> print("dendrapply"); if(is.function(try(dendrapply))) {dendrapply;} else{ NULL};
[1] "dendrapply"
function (X, FUN, ...) 
{
    FUN <- match.fun(FUN)
    if (!inherits(X, "dendrogram")) 
        stop("'X' is not a dendrogram")
    Napply <- function(d) {
        r <- FUN(d, ...)
        if (!is.leaf(d)) {
            if (!is.list(r)) 
                r <- as.list(r)
            if (length(r) < (n <- length(d))) 
                r[seq_len(n)] <- vector("list", n)
            r[] <- lapply(d, Napply)
        }
        r
    }
    Napply(X)
}
<environment: namespace:stats>
> print("dendrogram"); if(is.function(try(dendrogram))) {dendrogram;} else{ NULL};
[1] "dendrogram"
NULL
> print("density"); if(is.function(try(density))) {density;} else{ NULL};
[1] "density"
function (x, ...) 
UseMethod("density")
<environment: namespace:stats>
> print("deriv"); if(is.function(try(deriv))) {deriv;} else{ NULL};
[1] "deriv"
function (expr, ...) 
UseMethod("deriv")
<environment: namespace:stats>
> print("deviance"); if(is.function(try(deviance))) {deviance;} else{ NULL};
[1] "deviance"
function (object, ...) 
UseMethod("deviance")
<environment: namespace:stats>
> print("df.residual"); if(is.function(try(df.residual))) {df.residual;} else{ NULL};
[1] "df.residual"
function (object, ...) 
UseMethod("df.residual")
<environment: namespace:stats>
> print("diff.ts"); if(is.function(try(diff.ts))) {diff.ts;} else{ NULL};
[1] "diff.ts"
function (x, lag = 1, differences = 1, ...) 
{
    if (lag < 1 | differences < 1) 
        stop("bad value for 'lag' or 'differences'")
    if (lag * differences >= NROW(x)) 
        return(x[0L])
    tsLag <- function(x, k = 1) {
        p <- tsp(x)
        tsp(x) <- p - (k/p[3L]) * c(1, 1, 0)
        x
    }
    r <- x
    for (i in 1L:differences) {
        r <- r - tsLag(r, -lag)
    }
    xtsp <- attr(x, "tsp")
    if (is.matrix(x)) 
        colnames(r) <- colnames(x)
    ts(r, end = xtsp[2L], frequency = xtsp[3L])
}
<environment: namespace:stats>
> print("diffinv"); if(is.function(try(diffinv))) {diffinv;} else{ NULL};
[1] "diffinv"
function (x, ...) 
{
    UseMethod("diffinv")
}
<environment: namespace:stats>
> print("dist"); if(is.function(try(dist))) {dist;} else{ NULL};
[1] "dist"
function (x, method = "euclidean", diag = FALSE, upper = FALSE, 
    p = 2) 
{
    if (!is.na(pmatch(method, "euclidian"))) 
        method <- "euclidean"
    METHODS <- c("euclidean", "maximum", "manhattan", "canberra", 
        "binary", "minkowski")
    method <- pmatch(method, METHODS)
    if (is.na(method)) 
        stop("invalid distance method")
    if (method == -1) 
        stop("ambiguous distance method")
    N <- nrow(x <- as.matrix(x))
    d <- .C("R_distance", x = as.double(x), nr = N, nc = ncol(x), 
        d = double(N * (N - 1)/2), diag = as.integer(FALSE), 
        method = as.integer(method), p = as.double(p), DUP = FALSE, 
        NAOK = TRUE, PACKAGE = "stats")$d
    attr(d, "Size") <- N
    attr(d, "Labels") <- dimnames(x)[[1L]]
    attr(d, "Diag") <- diag
    attr(d, "Upper") <- upper
    attr(d, "method") <- METHODS[method]
    if (method == 6) 
        attr(d, "p") <- p
    attr(d, "call") <- match.call()
    class(d) <- "dist"
    return(d)
}
<environment: namespace:stats>
> print("dummy.coef"); if(is.function(try(dummy.coef))) {dummy.coef;} else{ NULL};
[1] "dummy.coef"
function (object, ...) 
UseMethod("dummy.coef")
<environment: namespace:stats>
> print("ecdf"); if(is.function(try(ecdf))) {ecdf;} else{ NULL};
[1] "ecdf"
function (x) 
{
    x <- sort(x)
    n <- length(x)
    if (n < 1) 
        stop("'x' must have 1 or more non-missing values")
    vals <- unique(x)
    rval <- approxfun(vals, cumsum(tabulate(match(x, vals)))/n, 
        method = "constant", yleft = 0, yright = 1, f = 0, ties = "ordered")
    class(rval) <- c("ecdf", "stepfun", class(rval))
    assign("nobs", n, envir = environment(rval))
    attr(rval, "call") <- sys.call()
    rval
}
<environment: namespace:stats>
> print("eff.aovlist"); if(is.function(try(eff.aovlist))) {eff.aovlist;} else{ NULL};
[1] "eff.aovlist"
function (aovlist) 
{
    Terms <- terms(aovlist)
    if (names(aovlist)[[1L]] == "(Intercept)") 
        aovlist <- aovlist[-1L]
    pure.error.strata <- sapply(aovlist, function(x) is.null(x$qr))
    aovlist <- aovlist[!pure.error.strata]
    s.labs <- names(aovlist)
    s.terms <- lapply(aovlist, function(x) {
        asgn <- x$assign[x$qr$pivot[1L:x$rank]]
        attr(terms(x), "term.labels")[asgn]
    })
    t.labs <- attr(Terms, "term.labels")
    t.labs <- t.labs[t.labs %in% unlist(s.terms)]
    eff <- matrix(0, ncol = length(t.labs), nrow = length(s.labs), 
        dimnames = list(s.labs, t.labs))
    for (i in names(s.terms)) eff[i, s.terms[[i]]] <- 1
    cs <- colSums(eff)
    if (all(cs <= 1)) 
        return(eff[, cs > 0, drop = FALSE])
    nm <- t.labs[cs > 1]
    pl <- lapply(aovlist, function(x) {
        asgn <- x$assign[x$qr$pivot[1L:x$rank]]
        sp <- split(seq_along(asgn), attr(terms(x), "term.labels")[asgn])
        sp <- sp[names(sp) %in% nm]
        sapply(sp, function(x, y) {
            y <- y[x, x, drop = FALSE]
            res <- sum(diag(y)^2)
            if (nrow(y) > 1 && sum(y^2) > 1.01 * res) 
                stop("eff.aovlist: non-orthogonal contrasts would give an incorrect answer")
            res
        }, y = x$qr$qr)
    })
    for (i in names(pl)) eff[i, names(pl[[i]])] <- pl[[i]]
    cs <- colSums(eff)
    eff <- eff/rep(cs, each = nrow(eff))
    eff[, cs != 0, drop = FALSE]
}
<environment: namespace:stats>
> print("effects"); if(is.function(try(effects))) {effects;} else{ NULL};
[1] "effects"
function (object, ...) 
UseMethod("effects")
<environment: namespace:stats>
> print("embed"); if(is.function(try(embed))) {embed;} else{ NULL};
[1] "embed"
function (x, dimension = 1) 
{
    if (is.matrix(x)) {
        n <- nrow(x)
        m <- ncol(x)
        if ((dimension < 1) | (dimension > n)) 
            stop("wrong embedding dimension")
        y <- matrix(0, n - dimension + 1L, dimension * m)
        for (i in seq_len(m)) y[, seq.int(i, by = m, length.out = dimension)] <- Recall(as.vector(x[, 
            i]), dimension)
        return(y)
    }
    else if (is.vector(x) || is.ts(x)) {
        n <- length(x)
        if ((dimension < 1) | (dimension > n)) 
            stop("wrong embedding dimension")
        m <- n - dimension + 1L
        data <- x[1L:m + rep.int(dimension:1L, rep.int(m, dimension)) - 
            1L]
        dim(data) <- c(m, dimension)
        return(data)
    }
    else stop("'x' is not a vector or matrix")
}
<environment: namespace:stats>
> print("expand.model.frame"); if(is.function(try(expand.model.frame))) {expand.model.frame;} else{ NULL};
[1] "expand.model.frame"
function (model, extras, envir = environment(formula(model)), 
    na.expand = FALSE) 
{
    f <- formula(model)
    data <- eval(model$call$data, envir)
    ff <- foo ~ bar + baz
    if (is.call(extras)) 
        gg <- extras
    else gg <- parse(text = paste("~", paste(extras, collapse = "+")))[[1L]]
    ff[[2L]] <- f[[2L]]
    ff[[3L]][[2L]] <- f[[3L]]
    ff[[3L]][[3L]] <- gg[[2L]]
    if (!na.expand) {
        naa <- model$call$na.action
        subset <- model$call$subset
        rval <- eval(call("model.frame", ff, data = data, subset = subset, 
            na.action = naa), envir)
    }
    else {
        subset <- model$call$subset
        rval <- eval(call("model.frame", ff, data = data, subset = subset, 
            na.action = I), envir)
        oldmf <- model.frame(model)
        keep <- match(rownames(oldmf), rownames(rval))
        rval <- rval[keep, ]
        class(rval) <- "data.frame"
    }
    return(rval)
}
<environment: namespace:stats>
> print("extractAIC"); if(is.function(try(extractAIC))) {extractAIC;} else{ NULL};
[1] "extractAIC"
function (fit, scale, k = 2, ...) 
UseMethod("extractAIC")
<environment: namespace:stats>
> print("factanal"); if(is.function(try(factanal))) {factanal;} else{ NULL};
[1] "factanal"
function (x, factors, data = NULL, covmat = NULL, n.obs = NA, 
    subset, na.action, start = NULL, scores = c("none", "regression", 
        "Bartlett"), rotation = "varimax", control = NULL, ...) 
{
    sortLoadings <- function(Lambda) {
        cn <- colnames(Lambda)
        Phi <- attr(Lambda, "covariance")
        ssq <- apply(Lambda, 2L, function(x) -sum(x^2))
        Lambda <- Lambda[, order(ssq), drop = FALSE]
        colnames(Lambda) <- cn
        neg <- colSums(Lambda) < 0
        Lambda[, neg] <- -Lambda[, neg]
        if (!is.null(Phi)) {
            unit <- ifelse(neg, -1, 1)
            attr(Lambda, "covariance") <- unit %*% Phi[order(ssq), 
                order(ssq)] %*% unit
        }
        Lambda
    }
    cl <- match.call()
    na.act <- NULL
    if (is.list(covmat)) {
        if (any(is.na(match(c("cov", "n.obs"), names(covmat))))) 
            stop("'covmat' is not a valid covariance list")
        cv <- covmat$cov
        n.obs <- covmat$n.obs
        have.x <- FALSE
    }
    else if (is.matrix(covmat)) {
        cv <- covmat
        have.x <- FALSE
    }
    else if (is.null(covmat)) {
        if (missing(x)) 
            stop("neither 'x' nor 'covmat' supplied")
        have.x <- TRUE
        if (inherits(x, "formula")) {
            mt <- terms(x, data = data)
            if (attr(mt, "response") > 0) 
                stop("response not allowed in formula")
            attr(mt, "intercept") <- 0
            mf <- match.call(expand.dots = FALSE)
            names(mf)[names(mf) == "x"] <- "formula"
            mf$factors <- mf$covmat <- mf$scores <- mf$start <- mf$rotation <- mf$control <- mf$... <- NULL
            mf[[1L]] <- as.name("model.frame")
            mf <- eval.parent(mf)
            na.act <- attr(mf, "na.action")
            if (.check_vars_numeric(mf)) 
                stop("factor analysis applies only to numerical variables")
            z <- model.matrix(mt, mf)
        }
        else {
            z <- as.matrix(x)
            if (!is.numeric(z)) 
                stop("factor analysis applies only to numerical variables")
            if (!missing(subset)) 
                z <- z[subset, , drop = FALSE]
        }
        covmat <- cov.wt(z)
        cv <- covmat$cov
        n.obs <- covmat$n.obs
    }
    else stop("'covmat' is of unknown type")
    scores <- match.arg(scores)
    if (scores != "none" && !have.x) 
        stop("requested scores without an 'x' matrix")
    p <- ncol(cv)
    if (p < 3) 
        stop("factor analysis requires at least three variables")
    dof <- 0.5 * ((p - factors)^2 - p - factors)
    if (dof < 0) 
        stop(gettextf("%d factors is too many for %d variables", 
            factors, p), domain = NA)
    sds <- sqrt(diag(cv))
    cv <- cv/(sds %o% sds)
    cn <- list(nstart = 1, trace = FALSE, lower = 0.005)
    cn[names(control)] <- control
    more <- list(...)[c("nstart", "trace", "lower", "opt", "rotate")]
    if (length(more)) 
        cn[names(more)] <- more
    if (is.null(start)) {
        start <- (1 - 0.5 * factors/p)/diag(solve(cv))
        if ((ns <- cn$nstart) > 1) 
            start <- cbind(start, matrix(runif(ns - 1), p, ns - 
                1, byrow = TRUE))
    }
    start <- as.matrix(start)
    if (nrow(start) != p) 
        stop(gettextf("'start' must have %d rows", p), domain = NA)
    nc <- ncol(start)
    if (nc < 1) 
        stop("no starting values supplied")
    best <- Inf
    for (i in 1L:nc) {
        nfit <- factanal.fit.mle(cv, factors, start[, i], max(cn$lower, 
            0), cn$opt)
        if (cn$trace) 
            cat("start", i, "value:", format(nfit$criteria[1L]), 
                "uniqs:", format(as.vector(round(nfit$uniquenesses, 
                  4))), "\n")
        if (nfit$converged && nfit$criteria[1L] < best) {
            fit <- nfit
            best <- fit$criteria[1L]
        }
    }
    if (best == Inf) 
        stop("unable to optimize from these starting value(s)")
    load <- fit$loadings
    if (rotation != "none") {
        rot <- do.call(rotation, c(list(load), cn$rotate))
        load <- if (is.list(rot)) {
            load <- rot$loadings
            fit$rotmat <- if (inherits(rot, "GPArotation")) 
                t(solve(rot$Th))
            else rot$rotmat
            rot$loadings
        }
        else rot
    }
    fit$loadings <- sortLoadings(load)
    class(fit$loadings) <- "loadings"
    fit$na.action <- na.act
    if (have.x && scores != "none") {
        Lambda <- fit$loadings
        zz <- scale(z, TRUE, TRUE)
        switch(scores, regression = {
            sc <- zz %*% solve(cv, Lambda)
            if (!is.null(Phi <- attr(Lambda, "covariance"))) sc <- sc %*% 
                Phi
        }, Bartlett = {
            d <- 1/fit$uniquenesses
            tmp <- t(Lambda * d)
            sc <- t(solve(tmp %*% Lambda, tmp %*% t(zz)))
        })
        rownames(sc) <- rownames(z)
        colnames(sc) <- colnames(Lambda)
        if (!is.null(na.act)) 
            sc <- napredict(na.act, sc)
        fit$scores <- sc
    }
    if (!is.na(n.obs) && dof > 0) {
        fit$STATISTIC <- (n.obs - 1 - (2 * p + 5)/6 - (2 * factors)/3) * 
            fit$criteria["objective"]
        fit$PVAL <- pchisq(fit$STATISTIC, dof, lower.tail = FALSE)
    }
    fit$n.obs <- n.obs
    fit$call <- cl
    fit
}
<environment: namespace:stats>
> print("factor.scope"); if(is.function(try(factor.scope))) {factor.scope;} else{ NULL};
[1] "factor.scope"
function (factor, scope) 
{
    drop <- scope$drop
    add <- scope$add
    if (length(factor) && !is.null(drop)) {
        nmdrop <- colnames(drop)
        facs <- factor
        if (length(drop)) {
            nmfac <- colnames(factor)
            nmfac0 <- sapply(strsplit(nmfac, ":", fixed = TRUE), 
                function(x) paste(sort(x), collapse = ":"))
            nmdrop0 <- sapply(strsplit(nmdrop, ":", fixed = TRUE), 
                function(x) paste(sort(x), collapse = ":"))
            where <- match(nmdrop0, nmfac0, 0L)
            if (any(!where)) 
                stop(gettextf("lower scope has term(s) %s not included in model", 
                  paste(sQuote(nmdrop[where == 0]), collapse = ", ")), 
                  domain = NA)
            facs <- factor[, -where, drop = FALSE]
            nmdrop <- nmfac[-where]
        }
        else nmdrop <- colnames(factor)
        if (ncol(facs) > 1) {
            keep <- rep.int(TRUE, ncol(facs))
            f <- crossprod(facs > 0)
            for (i in seq(keep)) keep[i] <- max(f[i, -i]) != 
                f[i, i]
            nmdrop <- nmdrop[keep]
        }
    }
    else nmdrop <- character()
    if (!length(add)) 
        nmadd <- character()
    else {
        nmfac <- colnames(factor)
        nmadd <- colnames(add)
        if (!is.null(nmfac)) {
            nmfac0 <- sapply(strsplit(nmfac, ":", fixed = TRUE), 
                function(x) paste(sort(x), collapse = ":"))
            nmadd0 <- sapply(strsplit(nmadd, ":", fixed = TRUE), 
                function(x) paste(sort(x), collapse = ":"))
            where <- match(nmfac0, nmadd0, 0L)
            if (any(!where)) 
                stop(gettextf("upper scope does not include model term(s) %s", 
                  paste(sQuote(nmfac[where == 0L]), collapse = ", ")), 
                  domain = NA)
            nmadd <- nmadd[-where]
            add <- add[, -where, drop = FALSE]
        }
        if (ncol(add) > 1) {
            keep <- rep.int(TRUE, ncol(add))
            f <- crossprod(add > 0)
            for (i in seq(keep)) keep[-i] <- keep[-i] & (f[i, 
                -i] < f[i, i])
            nmadd <- nmadd[keep]
        }
    }
    list(drop = nmdrop, add = nmadd)
}
<environment: namespace:stats>
> print("family"); if(is.function(try(family))) {family;} else{ NULL};
[1] "family"
function (object, ...) 
UseMethod("family")
<environment: namespace:stats>
> print("family.glm"); if(is.function(try(family.glm))) {family.glm;} else{ NULL};
[1] "family.glm"
NULL
> print("family.lm"); if(is.function(try(family.lm))) {family.lm;} else{ NULL};
[1] "family.lm"
NULL
> print("fft"); if(is.function(try(fft))) {fft;} else{ NULL};
[1] "fft"
function (z, inverse = FALSE) 
.Internal(fft(z, inverse))
<environment: namespace:stats>
> print("filter"); if(is.function(try(filter))) {filter;} else{ NULL};
[1] "filter"
function (x, filter, method = c("convolution", "recursive"), 
    sides = 2, circular = FALSE, init = NULL) 
{
    method <- match.arg(method)
    x <- as.ts(x)
    xtsp <- tsp(x)
    x <- as.matrix(x)
    n <- nrow(x)
    nser <- ncol(x)
    nfilt <- length(filter)
    if (any(is.na(filter))) 
        stop("missing values in 'filter'")
    y <- matrix(NA, n, nser)
    if (method == "convolution") {
        if (nfilt > n) 
            stop("'filter' is longer than time series")
        if (sides != 1 && sides != 2) 
            stop("argument 'sides' must be 1 or 2")
        for (i in 1L:nser) y[, i] <- .C("filter1", as.double(x[, 
            i]), as.integer(n), as.double(filter), as.integer(nfilt), 
            as.integer(sides), as.integer(circular), out = double(n), 
            NAOK = TRUE, PACKAGE = "stats")$out
    }
    else {
        if (missing(init)) {
            init <- matrix(0, nfilt, nser)
        }
        else {
            ni <- NROW(init)
            if (ni != nfilt) 
                stop("length of 'init' must equal length of 'filter'")
            if (NCOL(init) != 1 && NCOL(init) != nser) 
                stop(gettextf("'init'; must have 1 or %d cols", 
                  nser), domain = NA)
            if (!is.matrix(init)) 
                init <- matrix(init, nfilt, nser)
        }
        for (i in 1L:nser) y[, i] <- .C("filter2", as.double(x[, 
            i]), as.integer(n), as.double(filter), as.integer(nfilt), 
            out = as.double(c(rev(init[, i]), double(n))), NAOK = TRUE, 
            PACKAGE = "stats")$out[-(1L:nfilt)]
    }
    y <- drop(y)
    tsp(y) <- xtsp
    class(y) <- if (nser > 1) 
        c("mts", "ts")
    else "ts"
    y
}
<environment: namespace:stats>
> print("fisher.test"); if(is.function(try(fisher.test))) {fisher.test;} else{ NULL};
[1] "fisher.test"
function (x, y = NULL, workspace = 2e+05, hybrid = FALSE, control = list(), 
    or = 1, alternative = "two.sided", conf.int = TRUE, conf.level = 0.95, 
    simulate.p.value = FALSE, B = 2000) 
{
    DNAME <- deparse(substitute(x))
    METHOD <- "Fisher's Exact Test for Count Data"
    if (is.data.frame(x)) 
        x <- as.matrix(x)
    if (is.matrix(x)) {
        if (any(dim(x) < 2L)) 
            stop("'x' must have at least 2 rows and columns")
        if (!is.numeric(x) || any(x < 0) || any(is.na(x))) 
            stop("all entries of 'x' must be nonnegative and finite")
        if (!is.integer(x)) {
            xo <- x
            x <- round(x)
            if (any(x > .Machine$integer.max)) 
                stop("'x' has entries too large to be integer")
            if (!identical(TRUE, (ax <- all.equal(xo, x)))) 
                warning("'x' has been rounded to integer: ", 
                  ax)
            storage.mode(x) <- "integer"
        }
    }
    else {
        if (is.null(y)) 
            stop("if 'x' is not a matrix, 'y' must be given")
        if (length(x) != length(y)) 
            stop("'x' and 'y' must have the same length")
        DNAME <- paste(DNAME, "and", deparse(substitute(y)))
        OK <- complete.cases(x, y)
        x <- factor(x[OK])
        y <- factor(y[OK])
        if ((nlevels(x) < 2L) || (nlevels(y) < 2L)) 
            stop("'x' and 'y' must have at least 2 levels")
        x <- table(x, y)
    }
    con <- list(mult = 30)
    con[names(control)] <- control
    if ((mult <- as.integer(con$mult)) < 2) 
        stop("'mult' must be integer >= 2, typically = 30")
    nr <- nrow(x)
    nc <- ncol(x)
    if ((nr == 2) && (nc == 2)) {
        alternative <- char.expand(alternative, c("two.sided", 
            "less", "greater"))
        if (length(alternative) > 1L || is.na(alternative)) 
            stop("alternative must be \"two.sided\", \"less\" or \"greater\"")
        if (!((length(conf.level) == 1L) && is.finite(conf.level) && 
            (conf.level > 0) && (conf.level < 1))) 
            stop("'conf.level' must be a single number between 0 and 1")
        if (!missing(or) && (length(or) > 1L || is.na(or) || 
            or < 0)) 
            stop("'or' must be a single number between 0 and Inf")
    }
    PVAL <- NULL
    if (nr != 2 || nc != 2) {
        if (simulate.p.value) {
            sr <- rowSums(x)
            sc <- colSums(x)
            x <- x[sr > 0, sc > 0, drop = FALSE]
            nr <- nrow(x)
            nc <- ncol(x)
            if (nr <= 1) 
                stop("need 2 or more non-zero row marginals")
            if (nc <= 1) 
                stop("need 2 or more non-zero column marginals")
            METHOD <- paste(METHOD, "with simulated p-value\n\t (based on", 
                B, "replicates)")
            sr <- rowSums(x)
            sc <- colSums(x)
            n <- sum(sc)
            STATISTIC <- -sum(lfactorial(x))
            tmp <- .C("fisher_sim", as.integer(nr), as.integer(nc), 
                as.integer(sr), as.integer(sc), as.integer(n), 
                as.integer(B), integer(nr * nc), double(n + 1), 
                integer(nc), results = double(B), PACKAGE = "stats")$results
            almost.1 <- 1 + 64 * .Machine$double.eps
            PVAL <- (1 + sum(tmp <= STATISTIC/almost.1))/(B + 
                1)
        }
        else if (hybrid) {
            PVAL <- .C("fexact", nr, nc, x, nr, as.double(5), 
                as.double(80), as.double(1), double(1), p = double(1), 
                as.integer(workspace), mult = as.integer(mult), 
                PACKAGE = "stats")$p
        }
        else PVAL <- .C("fexact", nr, nc, x, nr, as.double(-1), 
            as.double(100), as.double(0), double(1), p = double(1), 
            as.integer(workspace), mult = as.integer(mult), PACKAGE = "stats")$p
        RVAL <- list(p.value = max(0, min(1, PVAL)))
    }
    if ((nr == 2) && (nc == 2)) {
        if (hybrid) 
            warning("'hybrid' is ignored for a 2 x 2 table")
        m <- sum(x[, 1])
        n <- sum(x[, 2])
        k <- sum(x[1, ])
        x <- x[1, 1]
        lo <- max(0, k - n)
        hi <- min(k, m)
        NVAL <- or
        names(NVAL) <- "odds ratio"
        support <- lo:hi
        logdc <- dhyper(support, m, n, k, log = TRUE)
        dnhyper <- function(ncp) {
            d <- logdc + log(ncp) * support
            d <- exp(d - max(d))
            d/sum(d)
        }
        mnhyper <- function(ncp) {
            if (ncp == 0) 
                return(lo)
            if (ncp == Inf) 
                return(hi)
            sum(support * dnhyper(ncp))
        }
        pnhyper <- function(q, ncp = 1, upper.tail = FALSE) {
            if (ncp == 1) {
                return(if (upper.tail) phyper(x - 1, m, n, k, 
                  lower.tail = FALSE) else phyper(x, m, n, k))
            }
            if (ncp == 0) {
                return(as.numeric(if (upper.tail) q <= lo else q >= 
                  lo))
            }
            if (ncp == Inf) {
                return(as.numeric(if (upper.tail) q <= hi else q >= 
                  hi))
            }
            sum(dnhyper(ncp)[if (upper.tail) support >= q else support <= 
                q])
        }
        if (is.null(PVAL)) {
            PVAL <- switch(alternative, less = pnhyper(x, or), 
                greater = pnhyper(x, or, upper.tail = TRUE), 
                two.sided = {
                  if (or == 0) as.numeric(x == lo) else if (or == 
                    Inf) as.numeric(x == hi) else {
                    relErr <- 1 + 10^(-7)
                    d <- dnhyper(or)
                    sum(d[d <= d[x - lo + 1] * relErr])
                  }
                })
            RVAL <- list(p.value = PVAL)
        }
        mle <- function(x) {
            if (x == lo) 
                return(0)
            if (x == hi) 
                return(Inf)
            mu <- mnhyper(1)
            if (mu > x) 
                uniroot(function(t) mnhyper(t) - x, c(0, 1))$root
            else if (mu < x) 
                1/uniroot(function(t) mnhyper(1/t) - x, c(.Machine$double.eps, 
                  1))$root
            else 1
        }
        ESTIMATE <- mle(x)
        names(ESTIMATE) <- "odds ratio"
        if (conf.int) {
            ncp.U <- function(x, alpha) {
                if (x == hi) 
                  return(Inf)
                p <- pnhyper(x, 1)
                if (p < alpha) 
                  uniroot(function(t) pnhyper(x, t) - alpha, 
                    c(0, 1))$root
                else if (p > alpha) 
                  1/uniroot(function(t) pnhyper(x, 1/t) - alpha, 
                    c(.Machine$double.eps, 1))$root
                else 1
            }
            ncp.L <- function(x, alpha) {
                if (x == lo) 
                  return(0)
                p <- pnhyper(x, 1, upper.tail = TRUE)
                if (p > alpha) 
                  uniroot(function(t) pnhyper(x, t, upper.tail = TRUE) - 
                    alpha, c(0, 1))$root
                else if (p < alpha) 
                  1/uniroot(function(t) pnhyper(x, 1/t, upper.tail = TRUE) - 
                    alpha, c(.Machine$double.eps, 1))$root
                else 1
            }
            CINT <- switch(alternative, less = c(0, ncp.U(x, 
                1 - conf.level)), greater = c(ncp.L(x, 1 - conf.level), 
                Inf), two.sided = {
                alpha <- (1 - conf.level)/2
                c(ncp.L(x, alpha), ncp.U(x, alpha))
            })
            attr(CINT, "conf.level") <- conf.level
        }
        RVAL <- c(RVAL, list(conf.int = if (conf.int) CINT, estimate = ESTIMATE, 
            null.value = NVAL))
    }
    RVAL <- c(RVAL, alternative = alternative, method = METHOD, 
        data.name = DNAME)
    attr(RVAL, "class") <- "htest"
    return(RVAL)
}
<environment: namespace:stats>
> print("fitted"); if(is.function(try(fitted))) {fitted;} else{ NULL};
[1] "fitted"
function (object, ...) 
UseMethod("fitted")
<environment: namespace:stats>
> print("fivenum"); if(is.function(try(fivenum))) {fivenum;} else{ NULL};
[1] "fivenum"
function (x, na.rm = TRUE) 
{
    xna <- is.na(x)
    if (na.rm) 
        x <- x[!xna]
    else if (any(xna)) 
        return(rep.int(NA, 5))
    x <- sort(x)
    n <- length(x)
    if (n == 0) 
        rep.int(NA, 5)
    else {
        n4 <- floor((n + 3)/2)/2
        d <- c(1, n4, (n + 1)/2, n + 1 - n4, n)
        0.5 * (x[floor(d)] + x[ceiling(d)])
    }
}
<environment: namespace:stats>
> print("fligner.test"); if(is.function(try(fligner.test))) {fligner.test;} else{ NULL};
[1] "fligner.test"
function (x, ...) 
UseMethod("fligner.test")
<environment: namespace:stats>
> print("formula"); if(is.function(try(formula))) {formula;} else{ NULL};
[1] "formula"
function (x, ...) 
UseMethod("formula")
<environment: namespace:stats>
> print("formula.nls"); if(is.function(try(formula.nls))) {formula.nls;} else{ NULL};
[1] "formula.nls"
NULL
> print("friedman.test"); if(is.function(try(friedman.test))) {friedman.test;} else{ NULL};
[1] "friedman.test"
function (y, ...) 
UseMethod("friedman.test")
<environment: namespace:stats>
> print("ftable"); if(is.function(try(ftable))) {ftable;} else{ NULL};
[1] "ftable"
function (x, ...) 
UseMethod("ftable")
<environment: namespace:stats>
> print("ftable.formula"); if(is.function(try(ftable.formula))) {ftable.formula;} else{ NULL};
[1] "ftable.formula"
NULL
> print("getInitial"); if(is.function(try(getInitial))) {getInitial;} else{ NULL};
[1] "getInitial"
function (object, data, ...) 
UseMethod("getInitial")
<environment: namespace:stats>
> print("glm"); if(is.function(try(glm))) {glm;} else{ NULL};
[1] "glm"
function (formula, family = gaussian, data, weights, subset, 
    na.action, start = NULL, etastart, mustart, offset, control = list(...), 
    model = TRUE, method = "glm.fit", x = FALSE, y = TRUE, contrasts = NULL, 
    ...) 
{
    call <- match.call()
    if (is.character(family)) 
        family <- get(family, mode = "function", envir = parent.frame())
    if (is.function(family)) 
        family <- family()
    if (is.null(family$family)) {
        print(family)
        stop("'family' not recognized")
    }
    if (missing(data)) 
        data <- environment(formula)
    mf <- match.call(expand.dots = FALSE)
    m <- match(c("formula", "data", "subset", "weights", "na.action", 
        "etastart", "mustart", "offset"), names(mf), 0L)
    mf <- mf[c(1L, m)]
    mf$drop.unused.levels <- TRUE
    mf[[1L]] <- as.name("model.frame")
    mf <- eval(mf, parent.frame())
    if (identical(method, "model.frame")) 
        return(mf)
    if (!is.character(method) && !is.function(method)) 
        stop("invalid 'method' argument")
    if (identical(method, "glm.fit")) 
        control <- do.call("glm.control", control)
    mt <- attr(mf, "terms")
    Y <- model.response(mf, "any")
    if (length(dim(Y)) == 1L) {
        nm <- rownames(Y)
        dim(Y) <- NULL
        if (!is.null(nm)) 
            names(Y) <- nm
    }
    X <- if (!is.empty.model(mt)) 
        model.matrix(mt, mf, contrasts)
    else matrix(, NROW(Y), 0L)
    weights <- as.vector(model.weights(mf))
    if (!is.null(weights) && !is.numeric(weights)) 
        stop("'weights' must be a numeric vector")
    if (!is.null(weights) && any(weights < 0)) 
        stop("negative weights not allowed")
    offset <- as.vector(model.offset(mf))
    if (!is.null(offset)) {
        if (length(offset) != NROW(Y)) 
            stop(gettextf("number of offsets is %d should equal %d (number of observations)", 
                length(offset), NROW(Y)), domain = NA)
    }
    mustart <- model.extract(mf, "mustart")
    etastart <- model.extract(mf, "etastart")
    fit <- eval(call(if (is.function(method)) "method" else method, 
        x = X, y = Y, weights = weights, start = start, etastart = etastart, 
        mustart = mustart, offset = offset, family = family, 
        control = control, intercept = attr(mt, "intercept") > 
            0L))
    if (length(offset) && attr(mt, "intercept") > 0L) {
        fit$null.deviance <- eval(call(if (is.function(method)) "method" else method, 
            x = X[, "(Intercept)", drop = FALSE], y = Y, weights = weights, 
            offset = offset, family = family, control = control, 
            intercept = TRUE))$deviance
    }
    if (model) 
        fit$model <- mf
    fit$na.action <- attr(mf, "na.action")
    if (x) 
        fit$x <- X
    if (!y) 
        fit$y <- NULL
    fit <- c(fit, list(call = call, formula = formula, terms = mt, 
        data = data, offset = offset, control = control, method = method, 
        contrasts = attr(X, "contrasts"), xlevels = .getXlevels(mt, 
            mf)))
    class(fit) <- c(fit$class, c("glm", "lm"))
    fit
}
<environment: namespace:stats>
> print("glm.control"); if(is.function(try(glm.control))) {glm.control;} else{ NULL};
[1] "glm.control"
function (epsilon = 1e-08, maxit = 25, trace = FALSE) 
{
    if (!is.numeric(epsilon) || epsilon <= 0) 
        stop("value of 'epsilon' must be > 0")
    if (!is.numeric(maxit) || maxit <= 0) 
        stop("maximum number of iterations must be > 0")
    list(epsilon = epsilon, maxit = maxit, trace = trace)
}
<environment: namespace:stats>
> print("hclust"); if(is.function(try(hclust))) {hclust;} else{ NULL};
[1] "hclust"
function (d, method = "complete", members = NULL) 
{
    METHODS <- c("ward", "single", "complete", "average", "mcquitty", 
        "median", "centroid")
    method <- pmatch(method, METHODS)
    if (is.na(method)) 
        stop("invalid clustering method")
    if (method == -1) 
        stop("ambiguous clustering method")
    n <- as.integer(attr(d, "Size"))
    if (is.null(n)) 
        stop("invalid dissimilarities")
    if (n < 2) 
        stop("must have n >= 2 objects to cluster")
    len <- as.integer(n * (n - 1)/2)
    if (length(d) != len) 
        (if (length(d) < len) 
            stop
        else warning)("dissimilarities of improper length")
    if (is.null(members)) 
        members <- rep(1, n)
    else if (length(members) != n) 
        stop("invalid length of members")
    hcl <- .Fortran("hclust", n = n, len = len, method = as.integer(method), 
        ia = integer(n), ib = integer(n), crit = double(n), members = as.double(members), 
        nn = integer(n), disnn = double(n), flag = logical(n), 
        diss = as.double(d), PACKAGE = "stats")
    hcass <- .Fortran("hcass2", n = as.integer(n), ia = as.integer(hcl$ia), 
        ib = as.integer(hcl$ib), order = integer(n), iia = integer(n), 
        iib = integer(n), PACKAGE = "stats")
    tree <- list(merge = cbind(hcass$iia[1L:(n - 1)], hcass$iib[1L:(n - 
        1)]), height = hcl$crit[1L:(n - 1)], order = hcass$order, 
        labels = attr(d, "Labels"), method = METHODS[method], 
        call = match.call(), dist.method = attr(d, "method"))
    class(tree) <- "hclust"
    tree
}
<environment: namespace:stats>
> print("heatmap"); if(is.function(try(heatmap))) {heatmap;} else{ NULL};
[1] "heatmap"
function (x, Rowv = NULL, Colv = if (symm) "Rowv" else NULL, 
    distfun = dist, hclustfun = hclust, reorderfun = function(d, 
        w) reorder(d, w), add.expr, symm = FALSE, revC = identical(Colv, 
        "Rowv"), scale = c("row", "column", "none"), na.rm = TRUE, 
    margins = c(5, 5), ColSideColors, RowSideColors, cexRow = 0.2 + 
        1/log10(nr), cexCol = 0.2 + 1/log10(nc), labRow = NULL, 
    labCol = NULL, main = NULL, xlab = NULL, ylab = NULL, keep.dendro = FALSE, 
    verbose = getOption("verbose"), ...) 
{
    scale <- if (symm && missing(scale)) 
        "none"
    else match.arg(scale)
    if (length(di <- dim(x)) != 2 || !is.numeric(x)) 
        stop("'x' must be a numeric matrix")
    nr <- di[1L]
    nc <- di[2L]
    if (nr <= 1 || nc <= 1) 
        stop("'x' must have at least 2 rows and 2 columns")
    if (!is.numeric(margins) || length(margins) != 2L) 
        stop("'margins' must be a numeric vector of length 2")
    doRdend <- !identical(Rowv, NA)
    doCdend <- !identical(Colv, NA)
    if (!doRdend && identical(Colv, "Rowv")) 
        doCdend <- FALSE
    if (is.null(Rowv)) 
        Rowv <- rowMeans(x, na.rm = na.rm)
    if (is.null(Colv)) 
        Colv <- colMeans(x, na.rm = na.rm)
    if (doRdend) {
        if (inherits(Rowv, "dendrogram")) 
            ddr <- Rowv
        else {
            hcr <- hclustfun(distfun(x))
            ddr <- as.dendrogram(hcr)
            if (!is.logical(Rowv) || Rowv) 
                ddr <- reorderfun(ddr, Rowv)
        }
        if (nr != length(rowInd <- order.dendrogram(ddr))) 
            stop("row dendrogram ordering gave index of wrong length")
    }
    else rowInd <- 1L:nr
    if (doCdend) {
        if (inherits(Colv, "dendrogram")) 
            ddc <- Colv
        else if (identical(Colv, "Rowv")) {
            if (nr != nc) 
                stop("Colv = \"Rowv\" but nrow(x) != ncol(x)")
            ddc <- ddr
        }
        else {
            hcc <- hclustfun(distfun(if (symm) 
                x
            else t(x)))
            ddc <- as.dendrogram(hcc)
            if (!is.logical(Colv) || Colv) 
                ddc <- reorderfun(ddc, Colv)
        }
        if (nc != length(colInd <- order.dendrogram(ddc))) 
            stop("column dendrogram ordering gave index of wrong length")
    }
    else colInd <- 1L:nc
    x <- x[rowInd, colInd]
    labRow <- if (is.null(labRow)) 
        if (is.null(rownames(x))) 
            (1L:nr)[rowInd]
        else rownames(x)
    else labRow[rowInd]
    labCol <- if (is.null(labCol)) 
        if (is.null(colnames(x))) 
            (1L:nc)[colInd]
        else colnames(x)
    else labCol[colInd]
    if (scale == "row") {
        x <- sweep(x, 1L, rowMeans(x, na.rm = na.rm), check.margin = FALSE)
        sx <- apply(x, 1L, sd, na.rm = na.rm)
        x <- sweep(x, 1L, sx, "/", check.margin = FALSE)
    }
    else if (scale == "column") {
        x <- sweep(x, 2L, colMeans(x, na.rm = na.rm), check.margin = FALSE)
        sx <- apply(x, 2L, sd, na.rm = na.rm)
        x <- sweep(x, 2L, sx, "/", check.margin = FALSE)
    }
    lmat <- rbind(c(NA, 3), 2:1)
    lwid <- c(if (doRdend) 1 else 0.05, 4)
    lhei <- c((if (doCdend) 1 else 0.05) + if (!is.null(main)) 0.2 else 0, 
        4)
    if (!missing(ColSideColors)) {
        if (!is.character(ColSideColors) || length(ColSideColors) != 
            nc) 
            stop("'ColSideColors' must be a character vector of length ncol(x)")
        lmat <- rbind(lmat[1, ] + 1, c(NA, 1), lmat[2, ] + 1)
        lhei <- c(lhei[1L], 0.2, lhei[2L])
    }
    if (!missing(RowSideColors)) {
        if (!is.character(RowSideColors) || length(RowSideColors) != 
            nr) 
            stop("'RowSideColors' must be a character vector of length nrow(x)")
        lmat <- cbind(lmat[, 1] + 1, c(rep(NA, nrow(lmat) - 1), 
            1), lmat[, 2] + 1)
        lwid <- c(lwid[1L], 0.2, lwid[2L])
    }
    lmat[is.na(lmat)] <- 0
    if (verbose) {
        cat("layout: widths = ", lwid, ", heights = ", lhei, 
            "; lmat=\n")
        print(lmat)
    }
    op <- par(no.readonly = TRUE)
    on.exit(par(op))
    layout(lmat, widths = lwid, heights = lhei, respect = TRUE)
    if (!missing(RowSideColors)) {
        par(mar = c(margins[1L], 0, 0, 0.5))
        image(rbind(1L:nr), col = RowSideColors[rowInd], axes = FALSE)
    }
    if (!missing(ColSideColors)) {
        par(mar = c(0.5, 0, 0, margins[2L]))
        image(cbind(1L:nc), col = ColSideColors[colInd], axes = FALSE)
    }
    par(mar = c(margins[1L], 0, 0, margins[2L]))
    if (!symm || scale != "none") 
        x <- t(x)
    if (revC) {
        iy <- nr:1
        if (doRdend) 
            ddr <- rev(ddr)
        x <- x[, iy]
    }
    else iy <- 1L:nr
    image(1L:nc, 1L:nr, x, xlim = 0.5 + c(0, nc), ylim = 0.5 + 
        c(0, nr), axes = FALSE, xlab = "", ylab = "", ...)
    axis(1, 1L:nc, labels = labCol, las = 2, line = -0.5, tick = 0, 
        cex.axis = cexCol)
    if (!is.null(xlab)) 
        mtext(xlab, side = 1, line = margins[1L] - 1.25)
    axis(4, iy, labels = labRow, las = 2, line = -0.5, tick = 0, 
        cex.axis = cexRow)
    if (!is.null(ylab)) 
        mtext(ylab, side = 4, line = margins[2L] - 1.25)
    if (!missing(add.expr)) 
        eval(substitute(add.expr))
    par(mar = c(margins[1L], 0, 0, 0))
    if (doRdend) 
        plot(ddr, horiz = TRUE, axes = FALSE, yaxs = "i", leaflab = "none")
    else frame()
    par(mar = c(0, 0, if (!is.null(main)) 1 else 0, margins[2L]))
    if (doCdend) 
        plot(ddc, axes = FALSE, xaxs = "i", leaflab = "none")
    else if (!is.null(main)) 
        frame()
    if (!is.null(main)) {
        par(xpd = NA)
        title(main, cex.main = 1.5 * op[["cex.main"]])
    }
    invisible(list(rowInd = rowInd, colInd = colInd, Rowv = if (keep.dendro && 
        doRdend) ddr, Colv = if (keep.dendro && doCdend) ddc))
}
<environment: namespace:stats>
> print("identify.hclust"); if(is.function(try(identify.hclust))) {identify.hclust;} else{ NULL};
[1] "identify.hclust"
NULL
> print("influence.measures"); if(is.function(try(influence.measures))) {influence.measures;} else{ NULL};
[1] "influence.measures"
function (model) 
{
    is.influential <- function(infmat, n) {
        k <- ncol(infmat) - 4
        if (n <= k) 
            stop("too few cases, n < k")
        absmat <- abs(infmat)
        result <- cbind(absmat[, 1L:k] > 1, absmat[, k + 1] > 
            3 * sqrt(k/(n - k)), abs(1 - infmat[, k + 2]) > (3 * 
            k)/(n - k), pf(infmat[, k + 3], k, n - k) > 0.5, 
            infmat[, k + 4] > (3 * k)/n)
        dimnames(result) <- dimnames(infmat)
        result
    }
    infl <- influence(model)
    p <- model$rank
    e <- weighted.residuals(model)
    s <- sqrt(sum(e^2, na.rm = TRUE)/df.residual(model))
    mqr <- qr.lm(model)
    xxi <- chol2inv(mqr$qr, mqr$rank)
    si <- infl$sigma
    h <- infl$hat
    dfbetas <- infl$coefficients/outer(infl$sigma, sqrt(diag(xxi)))
    vn <- variable.names(model)
    vn[vn == "(Intercept)"] <- "1_"
    colnames(dfbetas) <- paste("dfb", abbreviate(vn), sep = ".")
    dffits <- e * sqrt(h)/(si * (1 - h))
    if (any(ii <- is.infinite(dffits))) 
        dffits[ii] <- NaN
    cov.ratio <- (si/s)^(2 * p)/(1 - h)
    cooks.d <- if (inherits(model, "glm")) 
        (infl$pear.res/(1 - h))^2 * h/(summary(model)$dispersion * 
            p)
    else ((e/(s * (1 - h)))^2 * h)/p
    infmat <- cbind(dfbetas, dffit = dffits, cov.r = cov.ratio, 
        cook.d = cooks.d, hat = h)
    infmat[is.infinite(infmat)] <- NaN
    is.inf <- is.influential(infmat, sum(h > 0))
    ans <- list(infmat = infmat, is.inf = is.inf, call = model$call)
    class(ans) <- "infl"
    ans
}
<environment: namespace:stats>
> print("integrate"); if(is.function(try(integrate))) {integrate;} else{ NULL};
[1] "integrate"
function (f, lower, upper, ..., subdivisions = 100, rel.tol = .Machine$double.eps^0.25, 
    abs.tol = rel.tol, stop.on.error = TRUE, keep.xy = FALSE, 
    aux = NULL) 
{
    f <- match.fun(f)
    ff <- function(x) f(x, ...)
    limit <- as.integer(subdivisions)
    if (limit < 1 || (abs.tol <= 0 && rel.tol < max(50 * .Machine$double.eps, 
        5e-29))) 
        stop("invalid parameter values")
    if (is.finite(lower) && is.finite(upper)) {
        wk <- .External("call_dqags", ff, rho = environment(), 
            as.double(lower), as.double(upper), as.double(abs.tol), 
            as.double(rel.tol), limit = limit, PACKAGE = "base")
    }
    else {
        if (is.na(lower) || is.na(upper)) 
            stop("a limit is missing")
        if (is.finite(lower)) {
            inf <- 1
            bound <- lower
        }
        else if (is.finite(upper)) {
            inf <- -1
            bound <- upper
        }
        else {
            inf <- 2
            bound <- 0
        }
        wk <- .External("call_dqagi", ff, rho = environment(), 
            as.double(bound), as.integer(inf), as.double(abs.tol), 
            as.double(rel.tol), limit = limit, PACKAGE = "base")
    }
    res <- wk[c("value", "abs.error", "subdivisions")]
    res$message <- switch(wk$ierr + 1, "OK", "maximum number of subdivisions reached", 
        "roundoff error was detected", "extremely bad integrand behaviour", 
        "roundoff error is detected in the extrapolation table", 
        "the integral is probably divergent", "the input is invalid")
    if (wk$ierr == 6 || (wk$ierr > 0 && stop.on.error)) 
        stop(res$message)
    res$call <- match.call()
    class(res) <- "integrate"
    res
}
<environment: namespace:stats>
> print("interaction.plot"); if(is.function(try(interaction.plot))) {interaction.plot;} else{ NULL};
[1] "interaction.plot"
function (x.factor, trace.factor, response, fun = mean, type = c("l", 
    "p", "b"), legend = TRUE, trace.label = deparse(substitute(trace.factor)), 
    fixed = FALSE, xlab = deparse(substitute(x.factor)), ylab = ylabel, 
    ylim = range(cells, na.rm = TRUE), lty = nc:1, col = 1, pch = c(1L:9, 
        0, letters), xpd = NULL, leg.bg = par("bg"), leg.bty = "n", 
    xtick = FALSE, xaxt = par("xaxt"), axes = TRUE, ...) 
{
    ylabel <- paste(deparse(substitute(fun)), "of ", deparse(substitute(response)))
    type <- match.arg(type)
    cells <- tapply(response, list(x.factor, trace.factor), fun)
    nr <- nrow(cells)
    nc <- ncol(cells)
    xvals <- 1L:nr
    if (is.ordered(x.factor)) {
        wn <- getOption("warn")
        options(warn = -1)
        xnm <- as.numeric(levels(x.factor))
        options(warn = wn)
        if (!any(is.na(xnm))) 
            xvals <- xnm
    }
    xlabs <- rownames(cells)
    ylabs <- colnames(cells)
    nch <- max(sapply(ylabs, nchar, type = "width"))
    if (is.null(xlabs)) 
        xlabs <- as.character(xvals)
    if (is.null(ylabs)) 
        ylabs <- as.character(1L:nc)
    xlim <- range(xvals)
    xleg <- xlim[2L] + 0.05 * diff(xlim)
    xlim <- xlim + c(-0.2/nr, if (legend) 0.2 + 0.02 * nch else 0.2/nr) * 
        diff(xlim)
    matplot(xvals, cells, ..., type = type, xlim = xlim, ylim = ylim, 
        xlab = xlab, ylab = ylab, axes = axes, xaxt = "n", col = col, 
        lty = lty, pch = pch)
    if (axes && xaxt != "n") {
        axisInt <- function(x, main, sub, lwd, bg, log, asp, 
            ...) axis(1, x, ...)
        mgp. <- par("mgp")
        if (!xtick) 
            mgp.[2L] <- 0
        axisInt(1, at = xvals, labels = xlabs, tick = xtick, 
            mgp = mgp., xaxt = xaxt, ...)
    }
    if (legend) {
        yrng <- diff(ylim)
        yleg <- ylim[2L] - 0.1 * yrng
        if (!is.null(xpd) || {
            xpd. <- par("xpd")
            !is.na(xpd.) && !xpd. && (xpd <- TRUE)
        }) {
            op <- par(xpd = xpd)
            on.exit(par(op))
        }
        text(xleg, ylim[2L] - 0.05 * yrng, paste("  ", trace.label), 
            adj = 0)
        if (!fixed) {
            ord <- sort.list(cells[nr, ], decreasing = TRUE)
            ylabs <- ylabs[ord]
            lty <- lty[1 + (ord - 1)%%length(lty)]
            col <- col[1 + (ord - 1)%%length(col)]
            pch <- pch[ord]
        }
        legend(xleg, yleg, legend = ylabs, col = col, pch = if (type %in% 
            c("p", "b")) 
            pch, lty = if (type %in% c("l", "b")) 
            lty, bty = leg.bty, bg = leg.bg)
    }
    invisible()
}
<environment: namespace:stats>
> print("is.empty.model"); if(is.function(try(is.empty.model))) {is.empty.model;} else{ NULL};
[1] "is.empty.model"
function (x) 
{
    tt <- terms(x)
    (length(attr(tt, "factors")) == 0L) & (attr(tt, "intercept") == 
        0L)
}
<environment: namespace:stats>
> print("isoreg"); if(is.function(try(isoreg))) {isoreg;} else{ NULL};
[1] "isoreg"
function (x, y = NULL) 
{
    xy <- xy.coords(x, y)
    x <- xy$x
    if (any(is.na(x)) || any(is.na(xy$y))) 
        stop("missing values not allowed")
    isOrd <- ((!is.null(xy$xlab) && xy$xlab == "Index") || !is.unsorted(x, 
        strictly = TRUE))
    if (!isOrd) {
        y <- xy$y
        ord <- order(x, -y)
        y <- y[ord]
    }
    z <- .Call("R_isoreg", if (isOrd) xy$y else y, PACKAGE = "stats")
    structure(c(xy[c("x", "y")], z[c("yf", "yc", "iKnots")], 
        list(isOrd = isOrd, ord = if (!isOrd) ord, call = match.call())), 
        class = "isoreg")
}
<environment: namespace:stats>
> print("kernapply"); if(is.function(try(kernapply))) {kernapply;} else{ NULL};
[1] "kernapply"
function (x, ...) 
{
    UseMethod("kernapply")
}
<environment: namespace:stats>
> print("kernel"); if(is.function(try(kernel))) {kernel;} else{ NULL};
[1] "kernel"
function (coef, m = 2, r, name = "unknown") 
{
    mkName <- function(name, args) paste(name, "(", paste(args, 
        collapse = ","), ")", sep = "")
    modified.daniell.kernel <- function(m) {
        if (length(m) == 1L) 
            k <- kernel(c(rep(1, m), 0.5)/(2 * m), m)
        else {
            k <- Recall(m[1L])
            for (i in 2L:length(m)) k <- kernapply(k, Recall(m[i]))
        }
        attr(k, "name") <- mkName("mDaniell", m)
        k
    }
    daniell.kernel <- function(m) {
        if (length(m) == 1L) 
            k <- kernel(rep(1/(2 * m + 1), m + 1), m)
        else {
            k <- Recall(m[1L])
            for (i in 2L:length(m)) k <- kernapply(k, Recall(m[i]))
        }
        attr(k, "name") <- mkName("Daniell", m)
        k
    }
    fejer.kernel <- function(m, r) {
        if (r < 1L) 
            stop("'r' is less than 1")
        if (m < 1L) 
            stop("'m' is less than 1")
        n <- 2L * m + 1L
        wn <- double(m + 1L)
        wj <- 2 * pi * (1L:m)/n
        wn[2L:(m + 1L)] <- sin(r * wj/2)^2/sin(wj/2)^2/r
        wn[1L] <- r
        wn <- wn/(wn[1L] + 2 * sum(wn[2L:(m + 1L)]))
        kernel(wn, m, name = mkName("Fejer", c(m, r)))
    }
    dirichlet.kernel <- function(m, r) {
        if (r < 0) 
            stop("'r' is less than 0")
        if (m < 1) 
            stop("'m' is less than 1")
        n <- 2L * m + 1L
        wn <- double(m + 1L)
        wj <- 2 * pi * (1L:m)/n
        wn[2L:(m + 1)] <- sin((r + 0.5) * wj)/sin(wj/2)
        wn[1L] <- 2 * r + 1
        wn <- wn/(wn[1L] + 2 * sum(wn[2L:(m + 1L)]))
        kernel(wn, m, name = mkName("Dirichlet", c(m, r)))
    }
    if (!missing(m)) 
        if (!is.numeric(m) || length(m) < 1L || m != round(m) || 
            any(m < 0L)) 
            stop("'m' must be numeric with non-negative integers")
    if (is.character(coef)) {
        switch(coef, daniell = daniell.kernel(m), dirichlet = dirichlet.kernel(m, 
            r), fejer = fejer.kernel(m, r), modified.daniell = modified.daniell.kernel(m), 
            stop("unknown named kernel"))
    }
    else {
        if (!is.numeric(coef)) 
            stop("'coef' must be a vector")
        if (length(coef) < 1L) 
            stop("'coef' does not have the correct length")
        m <- length(coef) - 1L
        kernel <- list(coef = coef, m = m)
        attr(kernel, "name") <- name
        class(kernel) <- "tskernel"
        sk <- sum(kernel[-m:m])
        if (abs(sk - 1) > getOption("ts.eps")) 
            stop("coefficients do not add to 1")
        kernel
    }
}
<environment: namespace:stats>
> print("kmeans"); if(is.function(try(kmeans))) {kmeans;} else{ NULL};
[1] "kmeans"
function (x, centers, iter.max = 10, nstart = 1, algorithm = c("Hartigan-Wong", 
    "Lloyd", "Forgy", "MacQueen")) 
{
    do_one <- function(nmeth) {
        Z <- switch(nmeth, {
            Z <- .Fortran(R_kmns, as.double(x), as.integer(m), 
                as.integer(ncol(x)), centers = as.double(centers), 
                as.integer(k), c1 = integer(m), integer(m), nc = integer(k), 
                double(k), double(k), integer(k), double(m), 
                integer(k), integer(k), as.integer(iter.max), 
                wss = double(k), ifault = 0L)
            switch(Z$ifault, stop("empty cluster: try a better set of initial centers", 
                call. = FALSE), warning(gettextf("did not converge in %d iterations", 
                iter.max), call. = FALSE, domain = NA), stop("number of cluster centres must lie between 1 and nrow(x)", 
                call. = FALSE))
            Z
        }, {
            Z <- .C(R_kmeans_Lloyd, as.double(x), as.integer(m), 
                as.integer(ncol(x)), centers = as.double(centers), 
                as.integer(k), c1 = integer(m), iter = as.integer(iter.max), 
                nc = integer(k), wss = double(k))
            if (Z$iter > iter.max) warning("did not converge in ", 
                iter.max, " iterations", call. = FALSE)
            if (any(Z$nc == 0)) warning("empty cluster: try a better set of initial centers", 
                call. = FALSE)
            Z
        }, {
            Z <- .C(R_kmeans_MacQueen, as.double(x), as.integer(m), 
                as.integer(ncol(x)), centers = as.double(centers), 
                as.integer(k), c1 = integer(m), iter = as.integer(iter.max), 
                nc = integer(k), wss = double(k))
            if (Z$iter > iter.max) warning("did not converge in ", 
                iter.max, " iterations", call. = FALSE)
            if (any(Z$nc == 0)) warning("empty cluster: try a better set of initial centers", 
                call. = FALSE)
            Z
        })
        Z
    }
    x <- as.matrix(x)
    m <- nrow(x)
    if (missing(centers)) 
        stop("'centers' must be a number or a matrix")
    nmeth <- switch(match.arg(algorithm), `Hartigan-Wong` = 1, 
        Lloyd = 2, Forgy = 2, MacQueen = 3)
    if (length(centers) == 1L) {
        if (centers == 1) 
            nmeth <- 3
        k <- centers
        if (nstart == 1) 
            centers <- x[sample.int(m, k), , drop = FALSE]
        if (nstart >= 2 || any(duplicated(centers))) {
            cn <- unique(x)
            mm <- nrow(cn)
            if (mm < k) 
                stop("more cluster centers than distinct data points.")
            centers <- cn[sample.int(mm, k), , drop = FALSE]
        }
    }
    else {
        centers <- as.matrix(centers)
        if (any(duplicated(centers))) 
            stop("initial centers are not distinct")
        cn <- NULL
        k <- nrow(centers)
        if (m < k) 
            stop("more cluster centers than data points")
    }
    if (iter.max < 1) 
        stop("'iter.max' must be positive")
    if (ncol(x) != ncol(centers)) 
        stop("must have same number of columns in 'x' and 'centers'")
    Z <- do_one(nmeth)
    best <- sum(Z$wss)
    if (nstart >= 2 && !is.null(cn)) 
        for (i in 2:nstart) {
            centers <- cn[sample.int(mm, k), , drop = FALSE]
            ZZ <- do_one(nmeth)
            if ((z <- sum(ZZ$wss)) < best) {
                Z <- ZZ
                best <- z
            }
        }
    centers <- matrix(Z$centers, k)
    dimnames(centers) <- list(1L:k, dimnames(x)[[2L]])
    cluster <- Z$c1
    if (!is.null(rn <- rownames(x))) 
        names(cluster) <- rn
    totss <- sum(scale(x, scale = FALSE)^2)
    structure(list(cluster = cluster, centers = centers, totss = totss, 
        withinss = Z$wss, tot.withinss = best, betweenss = totss - 
            best, size = Z$nc), class = "kmeans")
}
<environment: namespace:stats>
> print("kruskal.test"); if(is.function(try(kruskal.test))) {kruskal.test;} else{ NULL};
[1] "kruskal.test"
function (x, ...) 
UseMethod("kruskal.test")
<environment: namespace:stats>
> print("ks.test"); if(is.function(try(ks.test))) {ks.test;} else{ NULL};
[1] "ks.test"
function (x, y, ..., alternative = c("two.sided", "less", "greater"), 
    exact = NULL) 
{
    pkolmogorov1x <- function(x, n) {
        if (x <= 0) 
            return(0)
        if (x >= 1) 
            return(1)
        j <- seq.int(from = 0, to = floor(n * (1 - x)))
        1 - x * sum(exp(lchoose(n, j) + (n - j) * log(1 - x - 
            j/n) + (j - 1) * log(x + j/n)))
    }
    alternative <- match.arg(alternative)
    DNAME <- deparse(substitute(x))
    x <- x[!is.na(x)]
    n <- length(x)
    if (n < 1L) 
        stop("not enough 'x' data")
    PVAL <- NULL
    if (is.numeric(y)) {
        DNAME <- paste(DNAME, "and", deparse(substitute(y)))
        y <- y[!is.na(y)]
        n.x <- as.double(n)
        n.y <- length(y)
        if (n.y < 1L) 
            stop("not enough 'y' data")
        if (is.null(exact)) 
            exact <- (n.x * n.y < 10000)
        METHOD <- "Two-sample Kolmogorov-Smirnov test"
        TIES <- FALSE
        n <- n.x * n.y/(n.x + n.y)
        w <- c(x, y)
        z <- cumsum(ifelse(order(w) <= n.x, 1/n.x, -1/n.y))
        if (length(unique(w)) < (n.x + n.y)) {
            warning("cannot compute correct p-values with ties")
            z <- z[c(which(diff(sort(w)) != 0), n.x + n.y)]
            TIES <- TRUE
        }
        STATISTIC <- switch(alternative, two.sided = max(abs(z)), 
            greater = max(z), less = -min(z))
        nm_alternative <- switch(alternative, two.sided = "two-sided", 
            less = "the CDF of x lies below that of y", greater = "the CDF of x lies above that of y")
        if (exact && (alternative == "two.sided") && !TIES) 
            PVAL <- 1 - .C("psmirnov2x", p = as.double(STATISTIC), 
                as.integer(n.x), as.integer(n.y), PACKAGE = "stats")$p
    }
    else {
        if (is.character(y)) 
            y <- get(y, mode = "function")
        if (mode(y) != "function") 
            stop("'y' must be numeric or a string naming a valid function")
        if (is.null(exact)) 
            exact <- (n < 100)
        METHOD <- "One-sample Kolmogorov-Smirnov test"
        TIES <- FALSE
        if (length(unique(x)) < n) {
            warning("cannot compute correct p-values with ties")
            TIES <- TRUE
        }
        x <- y(sort(x), ...) - (0:(n - 1))/n
        STATISTIC <- switch(alternative, two.sided = max(c(x, 
            1/n - x)), greater = max(1/n - x), less = max(x))
        if (exact && !TIES) {
            PVAL <- if (alternative == "two.sided") 
                1 - .C("pkolmogorov2x", p = as.double(STATISTIC), 
                  as.integer(n), PACKAGE = "stats")$p
            else 1 - pkolmogorov1x(STATISTIC, n)
        }
        nm_alternative <- switch(alternative, two.sided = "two-sided", 
            less = "the CDF of x lies below the null hypothesis", 
            greater = "the CDF of x lies above the null hypothesis")
    }
    names(STATISTIC) <- switch(alternative, two.sided = "D", 
        greater = "D^+", less = "D^-")
    pkstwo <- function(x, tol = 1e-06) {
        if (is.numeric(x)) 
            x <- as.vector(x)
        else stop("argument 'x' must be numeric")
        p <- rep(0, length(x))
        p[is.na(x)] <- NA
        IND <- which(!is.na(x) & (x > 0))
        if (length(IND)) {
            p[IND] <- .C("pkstwo", as.integer(length(x[IND])), 
                p = as.double(x[IND]), as.double(tol), PACKAGE = "stats")$p
        }
        return(p)
    }
    if (is.null(PVAL)) {
        PVAL <- ifelse(alternative == "two.sided", 1 - pkstwo(sqrt(n) * 
            STATISTIC), exp(-2 * n * STATISTIC^2))
    }
    RVAL <- list(statistic = STATISTIC, p.value = PVAL, alternative = nm_alternative, 
        method = METHOD, data.name = DNAME)
    class(RVAL) <- "htest"
    return(RVAL)
}
<environment: namespace:stats>
> print("ksmooth"); if(is.function(try(ksmooth))) {ksmooth;} else{ NULL};
[1] "ksmooth"
function (x, y, kernel = c("box", "normal"), bandwidth = 0.5, 
    range.x = range(x), n.points = max(100, length(x)), x.points) 
{
    if (missing(y) || is.null(y)) 
        stop("numeric y must be supplied.\nFor density estimation use density()")
    kernel <- match.arg(kernel)
    krn <- switch(kernel, box = 1, normal = 2)
    x.points <- if (missing(x.points)) 
        seq.int(range.x[1L], range.x[2L], length.out = n.points)
    else {
        n.points <- length(x.points)
        sort(x.points)
    }
    ord <- order(x)
    z <- .C("BDRksmooth", as.double(x[ord]), as.double(y[ord]), 
        as.integer(length(x)), xp = as.double(x.points), yp = double(n.points), 
        as.integer(n.points), as.integer(krn), as.double(bandwidth), 
        PACKAGE = "stats")
    list(x = z$xp, y = z$yp)
}
<environment: namespace:stats>
> print("lag"); if(is.function(try(lag))) {lag;} else{ NULL};
[1] "lag"
function (x, ...) 
UseMethod("lag")
<environment: namespace:stats>
> print("lag.plot"); if(is.function(try(lag.plot))) {lag.plot;} else{ NULL};
[1] "lag.plot"
function (x, lags = 1, layout = NULL, set.lags = 1L:lags, main = NULL, 
    asp = 1, diag = TRUE, diag.col = "gray", type = "p", oma = NULL, 
    ask = NULL, do.lines = (n <= 150), labels = do.lines, ...) 
{
    lAxis <- function(side, ..., mgp, xpd, panel, Mgp) if (missing(Mgp)) 
        axis(side, ..., xpd = NA)
    else axis(side, ..., xpd = NA, mgp = Mgp)
    xnam <- deparse(substitute(x))
    is.mat <- !is.null(ncol(x))
    nser <- ncol(x <- as.ts(as.matrix(x)))
    n <- nrow(x)
    if (missing(lags) && !missing(set.lags)) 
        lags <- length(set.lags <- as.integer(set.lags))
    tot.lags <- nser * lags
    if (is.null(ask)) {
        if (.Device == "null device") 
            dev.new()
        ask <- if (is.null(layout)) 
            par("ask")
        else (dev.interactive() && prod(layout) < tot.lags)
    }
    if (is.null(layout)) 
        layout <- if (prod(pmf <- par("mfrow")) >= tot.lags) 
            pmf
        else grDevices::n2mfrow(tot.lags)
    mlayout <- any(layout > 1)
    if (mlayout) {
        dots <- list(...)
        cex.main <- dots$cex.main
        if (is.null(cex.main)) 
            cex.main <- par("cex.main")
        if (is.null(oma)) {
            oma <- rep(2, 4)
            if (!is.null(main)) 
                oma[3L] <- oma[3L] + 3 * cex.main
        }
        opar <- par(mfrow = layout, mar = c(1.1, 1.1, 0.5, 0.5) + 
            is.mat * c(0, 0.5, 0, 0.5), oma = oma, ask = ask)
        on.exit(par(opar))
    }
    nR <- layout[1L]
    nC <- layout[2L]
    ii <- jj <- 0
    for (i in 1L:nser) {
        X <- x[, i]
        xl <- range(X)
        nam <- if (is.mat) 
            dimnames(x)[[2L]][i]
        else xnam
        newX <- is.mat
        for (ll in set.lags) {
            jj <- 1 + jj%%nC
            if (jj == 1) 
                ii <- 1 + ii%%nR
            if (mlayout) {
                plot(lag(X, ll), X, xlim = xl, ylim = xl, asp = asp, 
                  xlab = paste("lag", ll), ylab = nam, mgp = if (mlayout) 
                    c(0, 0, 0), axes = FALSE, type = type, xy.lines = do.lines, 
                  xy.labels = labels, col.lab = if (newX) 
                    "red", font.lab = if (newX) 
                    2, ...)
                box(...)
                if (jj == 1 && ii%%2 == 1 && !newX) 
                  lAxis(2, ...)
                if (ii == 1 && jj%%2 == 1) 
                  lAxis(3, ...)
                do.4 <- (ii%%2 == 0 && (jj == nC || (i == nser && 
                  ll == set.lags[lags])))
                if (do.4) 
                  lAxis(4, ...)
                if (jj%%2 == 0 && ii == nR) 
                  lAxis(1, ...)
                if (newX) {
                  newX <- FALSE
                  if (!do.4) 
                    lAxis(4, Mgp = c(0, 0.6, 0), ...)
                }
            }
            else {
                plot(lag(X, ll), X, xlim = xl, ylim = xl, asp = asp, 
                  xlab = paste("lag", ll), ylab = nam, type = type, 
                  xy.lines = do.lines, xy.labels = labels, main = main, 
                  ...)
            }
            if (diag) 
                abline(c(0, 1), lty = 2, col = diag.col)
            if (mlayout && !is.null(main)) {
                font.main <- dots$font.main
                if (is.null(font.main)) 
                  font.main <- par("font.main")
                if ((jj == nC && ii == nR) || ll == set.lags[lags]) 
                  mtext(main, 3, 3, outer = TRUE, at = 0.5, cex = cex.main, 
                    font = font.main)
            }
        }
    }
    invisible(NULL)
}
<environment: namespace:stats>
> print("line"); if(is.function(try(line))) {line;} else{ NULL};
[1] "line"
function (x, y = NULL) 
{
    xy <- xy.coords(x, y)
    ok <- complete.cases(xy$x, xy$y)
    n <- length(ok)
    if (n <= 1) 
        stop("insufficient observations")
    z <- .C("tukeyline", as.double(xy$x[ok]), as.double(xy$y[ok]), 
        double(n), double(n), n, double(2), DUP = FALSE, PACKAGE = "stats")
    value <- list(call = sys.call(), coefficients = z[[6L]], 
        residuals = z[[3L]], fitted.values = z[[4L]])
    class(value) <- "tukeyline"
    value
}
<environment: namespace:stats>
> print("lm"); if(is.function(try(lm))) {lm;} else{ NULL};
[1] "lm"
function (formula, data, subset, weights, na.action, method = "qr", 
    model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, 
    contrasts = NULL, offset, ...) 
{
    ret.x <- x
    ret.y <- y
    cl <- match.call()
    mf <- match.call(expand.dots = FALSE)
    m <- match(c("formula", "data", "subset", "weights", "na.action", 
        "offset"), names(mf), 0L)
    mf <- mf[c(1L, m)]
    mf$drop.unused.levels <- TRUE
    mf[[1L]] <- as.name("model.frame")
    mf <- eval(mf, parent.frame())
    if (method == "model.frame") 
        return(mf)
    else if (method != "qr") 
        warning(gettextf("method = '%s' is not supported. Using 'qr'", 
            method), domain = NA)
    mt <- attr(mf, "terms")
    y <- model.response(mf, "numeric")
    w <- as.vector(model.weights(mf))
    if (!is.null(w) && !is.numeric(w)) 
        stop("'weights' must be a numeric vector")
    offset <- as.vector(model.offset(mf))
    if (!is.null(offset)) {
        if (length(offset) != NROW(y)) 
            stop(gettextf("number of offsets is %d, should equal %d (number of observations)", 
                length(offset), NROW(y)), domain = NA)
    }
    if (is.empty.model(mt)) {
        x <- NULL
        z <- list(coefficients = if (is.matrix(y)) matrix(, 0, 
            3) else numeric(), residuals = y, fitted.values = 0 * 
            y, weights = w, rank = 0L, df.residual = if (!is.null(w)) sum(w != 
            0) else if (is.matrix(y)) nrow(y) else length(y))
        if (!is.null(offset)) {
            z$fitted.values <- offset
            z$residuals <- y - offset
        }
    }
    else {
        x <- model.matrix(mt, mf, contrasts)
        z <- if (is.null(w)) 
            lm.fit(x, y, offset = offset, singular.ok = singular.ok, 
                ...)
        else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok, 
            ...)
    }
    class(z) <- c(if (is.matrix(y)) "mlm", "lm")
    z$na.action <- attr(mf, "na.action")
    z$offset <- offset
    z$contrasts <- attr(x, "contrasts")
    z$xlevels <- .getXlevels(mt, mf)
    z$call <- cl
    z$terms <- mt
    if (model) 
        z$model <- mf
    if (ret.x) 
        z$x <- x
    if (ret.y) 
        z$y <- y
    if (!qr) 
        z$qr <- NULL
    z
}
<environment: namespace:stats>
> print("lm.fit"); if(is.function(try(lm.fit))) {lm.fit;} else{ NULL};
[1] "lm.fit"
function (x, y, offset = NULL, method = "qr", tol = 1e-07, singular.ok = TRUE, 
    ...) 
{
    if (is.null(n <- nrow(x))) 
        stop("'x' must be a matrix")
    if (n == 0L) 
        stop("0 (non-NA) cases")
    p <- ncol(x)
    if (p == 0L) {
        return(list(coefficients = numeric(), residuals = y, 
            fitted.values = 0 * y, rank = 0, df.residual = length(y)))
    }
    ny <- NCOL(y)
    if (is.matrix(y) && ny == 1) 
        y <- drop(y)
    if (!is.null(offset)) 
        y <- y - offset
    if (NROW(y) != n) 
        stop("incompatible dimensions")
    if (method != "qr") 
        warning(gettextf("method = '%s' is not supported. Using 'qr'", 
            method), domain = NA)
    if (length(list(...))) 
        warning("extra arguments ", paste(names(list(...)), sep = ", "), 
            " are just disregarded.")
    storage.mode(x) <- "double"
    storage.mode(y) <- "double"
    z <- .Fortran("dqrls", qr = x, n = n, p = p, y = y, ny = ny, 
        tol = as.double(tol), coefficients = mat.or.vec(p, ny), 
        residuals = y, effects = y, rank = integer(1L), pivot = 1L:p, 
        qraux = double(p), work = double(2 * p), PACKAGE = "base")
    if (!singular.ok && z$rank < p) 
        stop("singular fit encountered")
    coef <- z$coefficients
    pivot <- z$pivot
    r1 <- seq_len(z$rank)
    dn <- colnames(x)
    if (is.null(dn)) 
        dn <- paste("x", 1L:p, sep = "")
    nmeffects <- c(dn[pivot[r1]], rep.int("", n - z$rank))
    r2 <- if (z$rank < p) 
        (z$rank + 1L):p
    else integer()
    if (is.matrix(y)) {
        coef[r2, ] <- NA
        coef[pivot, ] <- coef
        dimnames(coef) <- list(dn, colnames(y))
        dimnames(z$effects) <- list(nmeffects, colnames(y))
    }
    else {
        coef[r2] <- NA
        coef[pivot] <- coef
        names(coef) <- dn
        names(z$effects) <- nmeffects
    }
    z$coefficients <- coef
    r1 <- y - z$residuals
    if (!is.null(offset)) 
        r1 <- r1 + offset
    qr <- z[c("qr", "qraux", "pivot", "tol", "rank")]
    colnames(qr$qr) <- colnames(x)[qr$pivot]
    c(z[c("coefficients", "residuals", "effects", "rank")], list(fitted.values = r1, 
        assign = attr(x, "assign"), qr = structure(qr, class = "qr"), 
        df.residual = n - z$rank))
}
<environment: namespace:stats>
> print("lm.influence"); if(is.function(try(lm.influence))) {lm.influence;} else{ NULL};
[1] "lm.influence"
function (model, do.coef = TRUE) 
{
    wt.res <- weighted.residuals(model)
    e <- na.omit(wt.res)
    if (model$rank == 0) {
        n <- length(wt.res)
        sigma <- sqrt(deviance(model)/df.residual(model))
        res <- list(hat = rep(0, n), coefficients = matrix(0, 
            n, 0), sigma = rep(sigma, n), wt.res = e)
    }
    else {
        e[abs(e) < 100 * .Machine$double.eps * median(abs(e))] <- 0
        mqr <- qr.lm(model)
        n <- as.integer(nrow(mqr$qr))
        k <- as.integer(mqr$rank)
        if (NROW(e) != n) 
            stop("non-NA residual length does not match cases used in fitting")
        do.coef <- as.logical(do.coef)
        res <- .Fortran("lminfl", mqr$qr, n, n, k, as.integer(do.coef), 
            mqr$qraux, wt.res = e, hat = double(n), coefficients = if (do.coef) matrix(0, 
                n, k) else double(), sigma = double(n), tol = 10 * 
                .Machine$double.eps, DUP = FALSE, PACKAGE = "stats")[c("hat", 
            "coefficients", "sigma", "wt.res")]
        if (!is.null(model$na.action)) {
            hat <- naresid(model$na.action, res$hat)
            hat[is.na(hat)] <- 0
            res$hat <- hat
            if (do.coef) {
                coefficients <- naresid(model$na.action, res$coefficients)
                coefficients[is.na(coefficients)] <- 0
                res$coefficients <- coefficients
            }
            sigma <- naresid(model$na.action, res$sigma)
            sigma[is.na(sigma)] <- sqrt(deviance(model)/df.residual(model))
            res$sigma <- sigma
        }
    }
    res$wt.res <- naresid(model$na.action, res$wt.res)
    res$hat[res$hat > 1 - 10 * .Machine$double.eps] <- 1
    names(res$hat) <- names(res$sigma) <- names(res$wt.res)
    if (!do.coef) 
        res$coefficients <- NULL
    else {
        rownames(res$coefficients) <- names(res$wt.res)
        colnames(res$coefficients) <- names(coef(model))[!is.na(coef(model))]
    }
    res
}
<environment: namespace:stats>
> print("loadings"); if(is.function(try(loadings))) {loadings;} else{ NULL};
[1] "loadings"
function (x) 
x$loadings
<environment: namespace:stats>
> print("loess"); if(is.function(try(loess))) {loess;} else{ NULL};
[1] "loess"
function (formula, data, weights, subset, na.action, model = FALSE, 
    span = 0.75, enp.target, degree = 2, parametric = FALSE, 
    drop.square = FALSE, normalize = TRUE, family = c("gaussian", 
        "symmetric"), method = c("loess", "model.frame"), control = loess.control(...), 
    ...) 
{
    family <- match.arg(family)
    method <- match.arg(method)
    mf <- match.call(expand.dots = FALSE)
    mf$model <- mf$span <- mf$enp.target <- mf$degree <- mf$parametric <- mf$drop.square <- mf$normalize <- mf$family <- mf$method <- mf$control <- mf$... <- NULL
    mf[[1L]] <- as.name("model.frame")
    mf <- eval(mf, parent.frame())
    if (match.arg(method) == "model.frame") 
        return(mf)
    mt <- attr(mf, "terms")
    y <- model.response(mf, "numeric")
    w <- model.weights(mf)
    if (is.null(w)) 
        w <- rep(1, length(y))
    nmx <- as.character(attr(mt, "variables"))[-(1L:2)]
    x <- mf[, nmx, drop = FALSE]
    if (any(sapply(x, is.factor))) 
        stop("predictors must all be numeric")
    x <- as.matrix(x)
    D <- ncol(x)
    nmx <- colnames(x)
    names(nmx) <- nmx
    drop.square <- match(nmx, nmx[drop.square], 0L) > 0L
    parametric <- match(nmx, nmx[parametric], 0L) > 0L
    if (!match(degree, 0L:2L, 0L)) 
        stop("'degree' must be 0, 1 or 2")
    iterations <- if (family == "gaussian") 
        1
    else control$iterations
    if (!missing(enp.target)) 
        if (!missing(span)) 
            warning("both 'span' and 'enp.target' specified: 'span' will be used")
        else {
            tau <- switch(degree + 1, 1, D + 1, (D + 1) * (D + 
                2)/2) - sum(drop.square)
            span <- 1.2 * tau/enp.target
        }
    if (!is.list(control) || !is.character(control$surface) || 
        !is.character(control$statistics) || !is.character(control$trace.hat) || 
        !is.numeric(control$cell) || !is.numeric(iterations)) 
        stop("invalid 'control' argument")
    fit <- simpleLoess(y, x, w, span, degree, parametric, drop.square, 
        normalize, control$statistics, control$surface, control$cell, 
        iterations, control$trace.hat)
    fit$call <- match.call()
    fit$terms <- mt
    fit$xnames <- nmx
    fit$x <- x
    fit$y <- y
    fit$weights <- w
    if (model) 
        fit$model <- mf
    fit$na.action <- attr(mf, "na.action")
    fit
}
<environment: namespace:stats>
> print("loess.control"); if(is.function(try(loess.control))) {loess.control;} else{ NULL};
[1] "loess.control"
function (surface = c("interpolate", "direct"), statistics = c("approximate", 
    "exact"), trace.hat = c("exact", "approximate"), cell = 0.2, 
    iterations = 4, ...) 
{
    list(surface = match.arg(surface), statistics = match.arg(statistics), 
        trace.hat = match.arg(trace.hat), cell = cell, iterations = iterations)
}
<environment: namespace:stats>
> print("logLik"); if(is.function(try(logLik))) {logLik;} else{ NULL};
[1] "logLik"
function (object, ...) 
UseMethod("logLik")
<environment: namespace:stats>
> print("loglin"); if(is.function(try(loglin))) {loglin;} else{ NULL};
[1] "loglin"
function (table, margin, start = rep(1, length(table)), fit = FALSE, 
    eps = 0.1, iter = 20, param = FALSE, print = TRUE) 
{
    rfit <- fit
    dtab <- dim(table)
    nvar <- length(dtab)
    ncon <- length(margin)
    conf <- matrix(0, nrow = nvar, ncol = ncon)
    nmar <- 0
    varnames <- names(dimnames(table))
    for (k in seq_along(margin)) {
        tmp <- margin[[k]]
        if (is.character(tmp)) {
            tmp <- match(tmp, varnames)
            margin[[k]] <- tmp
        }
        conf[seq_along(tmp), k] <- tmp
        nmar <- nmar + prod(dtab[tmp])
    }
    ntab <- length(table)
    if (length(start) != ntab) 
        stop("'start' and 'table' must be same length")
    storage.mode(conf) <- "integer"
    z <- .C("loglin", as.integer(nvar), as.integer(dtab), as.integer(ncon), 
        conf, as.integer(ntab), as.double(table), fit = as.double(start), 
        locmar = integer(ncon), as.integer(nmar), marginals = double(nmar), 
        as.integer(ntab), u = double(ntab), as.double(eps), as.integer(iter), 
        dev = double(iter), nlast = integer(1L), ifault = integer(1L), 
        PACKAGE = "stats")
    switch(z$ifault, stop("this should not happen"), stop("this should not happen"), 
        warning("algorithm did not converge"), stop("incorrect specification of 'table' or 'start'"))
    if (print) 
        cat(z$nlast, "iterations: deviation", z$dev[z$nlast], 
            "\n")
    fit <- z$fit
    attributes(fit) <- attributes(table)
    observed <- as.vector(table[start > 0])
    expected <- as.vector(fit[start > 0])
    pearson <- sum((observed - expected)^2/expected)
    observed <- as.vector(table[table * fit > 0])
    expected <- as.vector(fit[table * fit > 0])
    lrt <- 2 * sum(observed * log(observed/expected))
    subsets <- function(x) {
        y <- list(vector(mode(x), length = 0))
        for (i in seq_along(x)) {
            y <- c(y, lapply(y, "c", x[i]))
        }
        y[-1L]
    }
    df <- rep.int(0, 2^nvar)
    for (k in seq_along(margin)) {
        terms <- subsets(margin[[k]])
        for (j in seq_along(terms)) df[sum(2^(terms[[j]] - 1))] <- prod(dtab[terms[[j]]] - 
            1)
    }
    if (!is.null(varnames) && all(nzchar(varnames))) {
        for (k in seq_along(margin)) margin[[k]] <- varnames[margin[[k]]]
    }
    else {
        varnames <- as.character(1:ntab)
    }
    y <- list(lrt = lrt, pearson = pearson, df = ntab - sum(df) - 
        1, margin = margin)
    if (rfit) 
        y$fit <- fit
    if (param) {
        fit <- log(fit)
        terms <- seq_along(df)[df > 0]
        parlen <- length(terms) + 1
        parval <- list(parlen)
        parnam <- character(parlen)
        parval[[1L]] <- mean(fit)
        parnam[1L] <- "(Intercept)"
        fit <- fit - parval[[1L]]
        dyadic <- NULL
        while (any(terms > 0)) {
            dyadic <- cbind(dyadic, terms%%2)
            terms <- terms%/%2
        }
        dyadic <- dyadic[order(rowSums(dyadic)), ]
        for (i in 2:parlen) {
            vars <- which(dyadic[i - 1, ] > 0)
            parval[[i]] <- apply(fit, vars, mean)
            parnam[i] <- paste(varnames[vars], collapse = ".")
            fit <- sweep(fit, vars, parval[[i]], check.margin = FALSE)
        }
        names(parval) <- parnam
        y$param <- parval
    }
    return(y)
}
<environment: namespace:stats>
> print("lowess"); if(is.function(try(lowess))) {lowess;} else{ NULL};
[1] "lowess"
function (x, y = NULL, f = 2/3, iter = 3, delta = 0.01 * diff(range(xy$x[o]))) 
{
    xy <- xy.coords(x, y)
    n <- as.integer(length(xy$x))
    if (n == 0) 
        stop("'x' is empty")
    o <- order(xy$x)
    .C("lowess", x = as.double(xy$x[o]), as.double(xy$y[o]), 
        n, as.double(f), as.integer(iter), as.double(delta), 
        y = double(n), double(n), double(n), PACKAGE = "stats")[c("x", 
        "y")]
}
<environment: namespace:stats>
> print("ls.diag"); if(is.function(try(ls.diag))) {ls.diag;} else{ NULL};
[1] "ls.diag"
function (ls.out) 
{
    resids <- as.matrix(ls.out$residuals)
    d0 <- dim(resids)
    xnames <- colnames(ls.out$qr$qr)
    yname <- colnames(resids)
    good <- complete.cases(resids, ls.out$wt)
    if (any(!good)) {
        warning("missing observations deleted")
        resids <- resids[good, , drop = FALSE]
    }
    if (!is.null(ls.out$wt)) {
        if (any(ls.out$wt[good] == 0)) 
            warning("observations with 0 weight not used in calculating standard deviation")
        resids <- resids * ls.out$wt[good]^0.5
    }
    p <- ls.out$qr$rank
    n <- nrow(resids)
    hatdiag <- rep.int(NA, n)
    stats <- array(NA, dim = d0)
    colnames(stats) <- yname
    stdres <- studres <- dfits <- Cooks <- stats
    q <- qr.qy(ls.out$qr, rbind(diag(p), matrix(0, nrow = n - 
        p, ncol = p)))
    hatdiag[good] <- rowSums(as.matrix(q^2))
    stddev <- (colSums(as.matrix(resids^2))/(n - p))^0.5
    stddevmat <- matrix(stddev, nrow = sum(good), ncol = ncol(resids), 
        byrow = TRUE)
    stdres[good, ] <- resids/((1 - hatdiag[good])^0.5 * stddevmat)
    studres[good, ] <- (stdres[good, ] * stddevmat)/(((n - p) * 
        stddevmat^2 - resids^2/(1 - hatdiag[good]))/(n - p - 
        1))^0.5
    dfits[good, ] <- (hatdiag[good]/(1 - hatdiag[good]))^0.5 * 
        studres[good, ]
    Cooks[good, ] <- ((stdres[good, ]^2 * hatdiag[good])/p)/(1 - 
        hatdiag[good])
    if (ncol(resids) == 1 && is.null(yname)) {
        stdres <- as.vector(stdres)
        Cooks <- as.vector(Cooks)
        studres <- as.vector(studres)
        dfits <- as.vector(dfits)
    }
    qr <- as.matrix(ls.out$qr$qr[1L:p, 1L:p])
    qr[row(qr) > col(qr)] <- 0
    qrinv <- solve(qr)
    covmat.unscaled <- qrinv %*% t(qrinv)
    dimnames(covmat.unscaled) <- list(xnames, xnames)
    covmat.scaled <- sum(stddev^2) * covmat.unscaled
    cormat <- covmat.scaled/(outer(diag(covmat.scaled), diag(covmat.scaled))^0.5)
    stderr <- outer(diag(covmat.unscaled)^0.5, stddev)
    dimnames(stderr) <- list(xnames, yname)
    return(list(std.dev = stddev, hat = hatdiag, std.res = stdres, 
        stud.res = studres, cooks = Cooks, dfits = dfits, correlation = cormat, 
        std.err = stderr, cov.scaled = covmat.scaled, cov.unscaled = covmat.unscaled))
}
<environment: namespace:stats>
> print("ls.print"); if(is.function(try(ls.print))) {ls.print;} else{ NULL};
[1] "ls.print"
function (ls.out, digits = 4, print.it = TRUE) 
{
    resids <- as.matrix(ls.out$residuals)
    if (!is.null(ls.out$wt)) {
        if (any(ls.out$wt == 0)) 
            warning("observations with 0 weights not used")
        resids <- resids * ls.out$wt^0.5
    }
    n <- apply(resids, 2L, length) - colSums(is.na(resids))
    lsqr <- ls.out$qr
    p <- lsqr$rank
    if (ls.out$intercept) {
        if (is.matrix(lsqr$qt)) 
            totss <- colSums(lsqr$qt[-1, ]^2)
        else totss <- sum(lsqr$qt[-1L]^2)
        degfree <- p - 1
    }
    else {
        totss <- colSums(as.matrix(lsqr$qt^2))
        degfree <- p
    }
    resss <- colSums(resids^2, na.rm = TRUE)
    resse <- (resss/(n - p))^0.5
    regss <- totss - resss
    rsquared <- regss/totss
    fstat <- (regss/degfree)/(resss/(n - p))
    pvalue <- pf(fstat, degfree, (n - p), lower.tail = FALSE)
    Ynames <- colnames(resids)
    summary <- cbind(format(round(resse, digits)), format(round(rsquared, 
        digits)), format(round(fstat, digits)), format(degfree), 
        format(n - p), format(round(pvalue, digits)))
    dimnames(summary) <- list(Ynames, c("Mean Sum Sq", "R Squared", 
        "F-value", "Df 1", "Df 2", "Pr(>F)"))
    mat <- as.matrix(lsqr$qr[1L:p, 1L:p])
    mat[row(mat) > col(mat)] <- 0
    qrinv <- solve(mat)
    m.y <- ncol(resids)
    coef.table <- as.list(1L:m.y)
    if (m.y == 1) 
        coef <- matrix(ls.out$coefficients, ncol = 1)
    else coef <- ls.out$coefficients
    for (i in 1L:m.y) {
        covmat <- (resss[i]/(n[i] - p)) * (qrinv %*% t(qrinv))
        se <- diag(covmat)^0.5
        coef.table[[i]] <- cbind(coef[, i], se, coef[, i]/se, 
            2 * pt(abs(coef[, i]/se), n[i] - p, lower.tail = FALSE))
        dimnames(coef.table[[i]]) <- list(colnames(lsqr$qr), 
            c("Estimate", "Std.Err", "t-value", "Pr(>|t|)"))
        if (print.it) {
            if (m.y > 1) 
                cat("Response:", Ynames[i], "\n\n")
            cat(paste("Residual Standard Error=", format(round(resse[i], 
                digits)), "\nR-Square=", format(round(rsquared[i], 
                digits)), "\nF-statistic (df=", format(degfree), 
                ", ", format(n[i] - p), ")=", format(round(fstat[i], 
                  digits)), "\np-value=", format(round(pvalue[i], 
                  digits)), "\n\n", sep = ""))
            print(round(coef.table[[i]], digits))
            cat("\n\n")
        }
    }
    names(coef.table) <- Ynames
    invisible(list(summary = summary, coef.table = coef.table))
}
<environment: namespace:stats>
> print("lsfit"); if(is.function(try(lsfit))) {lsfit;} else{ NULL};
[1] "lsfit"
function (x, y, wt = NULL, intercept = TRUE, tolerance = 1e-07, 
    yname = NULL) 
{
    x <- as.matrix(x)
    y <- as.matrix(y)
    xnames <- colnames(x)
    if (is.null(xnames)) {
        if (ncol(x) == 1) 
            xnames <- "X"
        else xnames <- paste("X", 1L:ncol(x), sep = "")
    }
    if (intercept) {
        x <- cbind(1, x)
        xnames <- c("Intercept", xnames)
    }
    if (is.null(yname) && ncol(y) > 1) 
        yname <- paste("Y", 1L:ncol(y), sep = "")
    good <- complete.cases(x, y, wt)
    dimy <- dim(as.matrix(y))
    if (any(!good)) {
        warning(gettextf("%d missing values deleted", sum(!good)), 
            domain = NA)
        x <- as.matrix(x)[good, ]
        y <- as.matrix(y)[good, ]
        wt <- wt[good]
    }
    nrx <- NROW(x)
    ncx <- NCOL(x)
    nry <- NROW(y)
    ncy <- NCOL(y)
    nwts <- length(wt)
    if (nry != nrx) 
        stop(gettextf("'X' matrix has %d responses, 'Y' has %d responses", 
            nrx, nry), domain = NA)
    if (nry < ncx) 
        stop(gettextf("%d responses, but only %d variables", 
            nry, ncx), domain = NA)
    if (!is.null(wt)) {
        if (any(wt < 0)) 
            stop("negative weights not allowed")
        if (nwts != nry) 
            stop(gettextf("number of weights = %d should equal %d (number of responses)", 
                nwts, nry), domain = NA)
        wtmult <- wt^0.5
        if (any(wt == 0)) {
            xzero <- as.matrix(x)[wt == 0, ]
            yzero <- as.matrix(y)[wt == 0, ]
        }
        x <- x * wtmult
        y <- y * wtmult
        invmult <- 1/ifelse(wt == 0, 1, wtmult)
    }
    storage.mode(x) <- "double"
    storage.mode(y) <- "double"
    z <- .Fortran("dqrls", qr = x, n = nrx, p = ncx, y = y, ny = ncy, 
        tol = tolerance, coefficients = mat.or.vec(ncx, ncy), 
        residuals = mat.or.vec(nrx, ncy), effects = mat.or.vec(nrx, 
            ncy), rank = integer(1L), pivot = as.integer(1L:ncx), 
        qraux = double(ncx), work = double(2 * ncx), PACKAGE = "base")
    resids <- array(NA, dim = dimy)
    dim(z$residuals) <- c(nry, ncy)
    if (!is.null(wt)) {
        if (any(wt == 0)) {
            if (ncx == 1) 
                fitted.zeros <- xzero * z$coefficients
            else fitted.zeros <- xzero %*% z$coefficients
            z$residuals[wt == 0, ] <- yzero - fitted.zeros
        }
        z$residuals <- z$residuals * invmult
    }
    resids[good, ] <- z$residuals
    if (dimy[2L] == 1 && is.null(yname)) {
        resids <- as.vector(resids)
        names(z$coefficients) <- xnames
    }
    else {
        colnames(resids) <- yname
        colnames(z$effects) <- yname
        dim(z$coefficients) <- c(ncx, ncy)
        dimnames(z$coefficients) <- list(xnames, yname)
    }
    z$qr <- as.matrix(z$qr)
    colnames(z$qr) <- xnames
    output <- list(coefficients = z$coefficients, residuals = resids)
    if (z$rank != ncx) {
        xnames <- xnames[z$pivot]
        dimnames(z$qr) <- list(NULL, xnames)
        warning("'X' matrix was collinear")
    }
    if (!is.null(wt)) {
        weights <- rep.int(NA, dimy[1L])
        weights[good] <- wt
        output <- c(output, list(wt = weights))
    }
    rqr <- list(qt = z$effects, qr = z$qr, qraux = z$qraux, rank = z$rank, 
        pivot = z$pivot, tol = z$tol)
    oldClass(rqr) <- "qr"
    output <- c(output, list(intercept = intercept, qr = rqr))
    return(output)
}
<environment: namespace:stats>
> print("mad"); if(is.function(try(mad))) {mad;} else{ NULL};
[1] "mad"
function (x, center = median(x), constant = 1.4826, na.rm = FALSE, 
    low = FALSE, high = FALSE) 
{
    if (na.rm) 
        x <- x[!is.na(x)]
    n <- length(x)
    constant * if ((low || high) && n%%2 == 0) {
        if (low && high) 
            stop("'low' and 'high' cannot be both TRUE")
        n2 <- n%/%2 + as.integer(high)
        sort(abs(x - center), partial = n2)[n2]
    }
    else median(abs(x - center))
}
<environment: namespace:stats>
> print("mahalanobis"); if(is.function(try(mahalanobis))) {mahalanobis;} else{ NULL};
[1] "mahalanobis"
function (x, center, cov, inverted = FALSE, ...) 
{
    x <- if (is.vector(x)) 
        matrix(x, ncol = length(x))
    else as.matrix(x)
    x <- sweep(x, 2, center)
    if (!inverted) 
        cov <- solve(cov, ...)
    retval <- rowSums((x %*% cov) * x)
    names(retval) <- rownames(x)
    retval
}
<environment: namespace:stats>
> print("make.link"); if(is.function(try(make.link))) {make.link;} else{ NULL};
[1] "make.link"
function (link) 
{
    switch(link, logit = {
        linkfun <- function(mu) .Call("logit_link", mu, PACKAGE = "stats")
        linkinv <- function(eta) .Call("logit_linkinv", eta, 
            PACKAGE = "stats")
        mu.eta <- function(eta) .Call("logit_mu_eta", eta, PACKAGE = "stats")
        valideta <- function(eta) TRUE
    }, probit = {
        linkfun <- function(mu) qnorm(mu)
        linkinv <- function(eta) {
            thresh <- -qnorm(.Machine$double.eps)
            eta <- pmin(pmax(eta, -thresh), thresh)
            pnorm(eta)
        }
        mu.eta <- function(eta) pmax(dnorm(eta), .Machine$double.eps)
        valideta <- function(eta) TRUE
    }, cauchit = {
        linkfun <- function(mu) qcauchy(mu)
        linkinv <- function(eta) {
            thresh <- -qcauchy(.Machine$double.eps)
            eta <- pmin(pmax(eta, -thresh), thresh)
            pcauchy(eta)
        }
        mu.eta <- function(eta) pmax(dcauchy(eta), .Machine$double.eps)
        valideta <- function(eta) TRUE
    }, cloglog = {
        linkfun <- function(mu) log(-log(1 - mu))
        linkinv <- function(eta) pmax(pmin(-expm1(-exp(eta)), 
            1 - .Machine$double.eps), .Machine$double.eps)
        mu.eta <- function(eta) {
            eta <- pmin(eta, 700)
            pmax(exp(eta) * exp(-exp(eta)), .Machine$double.eps)
        }
        valideta <- function(eta) TRUE
    }, identity = {
        linkfun <- function(mu) mu
        linkinv <- function(eta) eta
        mu.eta <- function(eta) rep.int(1, length(eta))
        valideta <- function(eta) TRUE
    }, log = {
        linkfun <- function(mu) log(mu)
        linkinv <- function(eta) pmax(exp(eta), .Machine$double.eps)
        mu.eta <- function(eta) pmax(exp(eta), .Machine$double.eps)
        valideta <- function(eta) TRUE
    }, sqrt = {
        linkfun <- function(mu) sqrt(mu)
        linkinv <- function(eta) eta^2
        mu.eta <- function(eta) 2 * eta
        valideta <- function(eta) all(eta > 0)
    }, `1/mu^2` = {
        linkfun <- function(mu) 1/mu^2
        linkinv <- function(eta) 1/sqrt(eta)
        mu.eta <- function(eta) -1/(2 * eta^1.5)
        valideta <- function(eta) all(eta > 0)
    }, inverse = {
        linkfun <- function(mu) 1/mu
        linkinv <- function(eta) 1/eta
        mu.eta <- function(eta) -1/(eta^2)
        valideta <- function(eta) all(eta != 0)
    }, stop(sQuote(link), " link not recognised"))
    structure(list(linkfun = linkfun, linkinv = linkinv, mu.eta = mu.eta, 
        valideta = valideta, name = link), class = "link-glm")
}
<environment: namespace:stats>
> print("makepredictcall"); if(is.function(try(makepredictcall))) {makepredictcall;} else{ NULL};
[1] "makepredictcall"
function (var, call) 
UseMethod("makepredictcall")
<environment: namespace:stats>
> print("manova"); if(is.function(try(manova))) {manova;} else{ NULL};
[1] "manova"
function (...) 
{
    Call <- fcall <- match.call()
    fcall[[1L]] <- as.name("aov")
    result <- eval(fcall, parent.frame())
    if (inherits(result, "aovlist")) {
        for (i in seq_along(result)) {
            if (!inherits(result[[i]], "maov")) 
                stop("need multiple response")
            class(result[[i]]) <- c("manova", oldClass(result[[i]]))
        }
        attr(result, "call") <- Call
    }
    else {
        if (!inherits(result, "maov")) 
            stop("need multiple response")
        class(result) <- c("manova", oldClass(result))
        result$call <- Call
    }
    result
}
<environment: namespace:stats>
> print("mantelhaen.test"); if(is.function(try(mantelhaen.test))) {mantelhaen.test;} else{ NULL};
[1] "mantelhaen.test"
function (x, y = NULL, z = NULL, alternative = c("two.sided", 
    "less", "greater"), correct = TRUE, exact = FALSE, conf.level = 0.95) 
{
    DNAME <- deparse(substitute(x))
    if (is.array(x)) {
        if (length(dim(x)) == 3L) {
            if (any(is.na(x))) 
                stop("NAs are not allowed")
            if (any(dim(x) < 2L)) 
                stop("each dimension in table must be >= 2")
        }
        else stop("'x' must be a 3-dimensional array")
    }
    else {
        if (is.null(y)) 
            stop("if 'x' is not an array, 'y' must be given")
        if (is.null(z)) 
            stop("if 'x' is not an array, 'z' must be given")
        if (any(diff(c(length(x), length(y), length(z))) != 0L)) 
            stop("'x', 'y', and 'z' must have the same length")
        DNAME <- paste(DNAME, "and", deparse(substitute(y)), 
            "and", deparse(substitute(z)))
        OK <- complete.cases(x, y, z)
        x <- factor(x[OK])
        y <- factor(y[OK])
        if ((nlevels(x) < 2L) || (nlevels(y) < 2L)) 
            stop("'x' and 'y' must have at least 2 levels")
        else x <- table(x, y, z[OK])
    }
    if (any(apply(x, 3L, sum) < 2)) 
        stop("sample size in each stratum must be > 1")
    I <- dim(x)[1L]
    J <- dim(x)[2L]
    K <- dim(x)[3L]
    if ((I == 2) && (J == 2)) {
        alternative <- match.arg(alternative)
        if (!missing(conf.level) && (length(conf.level) != 1 || 
            !is.finite(conf.level) || conf.level < 0 || conf.level > 
            1)) 
            stop("'conf.level' must be a single number between 0 and 1")
        NVAL <- 1
        names(NVAL) <- "common odds ratio"
        if (!exact) {
            s.x <- apply(x, c(1L, 3L), sum)
            s.y <- apply(x, c(2L, 3L), sum)
            n <- as.double(apply(x, 3L, sum))
            DELTA <- sum(x[1, 1, ] - s.x[1, ] * s.y[1, ]/n)
            YATES <- ifelse(correct && (abs(DELTA) >= 0.5), 0.5, 
                0)
            STATISTIC <- ((abs(DELTA) - YATES)^2/sum(apply(rbind(s.x, 
                s.y), 2L, prod)/(n^2 * (n - 1))))
            PARAMETER <- 1
            if (alternative == "two.sided") 
                PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
            else {
                z <- sign(DELTA) * sqrt(STATISTIC)
                PVAL <- pnorm(z, lower.tail = (alternative == 
                  "less"))
            }
            names(STATISTIC) <- "Mantel-Haenszel X-squared"
            names(PARAMETER) <- "df"
            METHOD <- paste("Mantel-Haenszel chi-squared test", 
                ifelse(YATES, "with", "without"), "continuity correction")
            s.diag <- sum(x[1, 1, ] * x[2, 2, ]/n)
            s.offd <- sum(x[1, 2, ] * x[2, 1, ]/n)
            ESTIMATE <- s.diag/s.offd
            sd <- sqrt(sum((x[1, 1, ] + x[2, 2, ]) * x[1, 1, 
                ] * x[2, 2, ]/n^2)/(2 * s.diag^2) + sum(((x[1, 
                1, ] + x[2, 2, ]) * x[1, 2, ] * x[2, 1, ] + (x[1, 
                2, ] + x[2, 1, ]) * x[1, 1, ] * x[2, 2, ])/n^2)/(2 * 
                s.diag * s.offd) + sum((x[1, 2, ] + x[2, 1, ]) * 
                x[1, 2, ] * x[2, 1, ]/n^2)/(2 * s.offd^2))
            CINT <- switch(alternative, less = c(0, ESTIMATE * 
                exp(qnorm(conf.level) * sd)), greater = c(ESTIMATE * 
                exp(qnorm(conf.level, lower.tail = FALSE) * sd), 
                Inf), two.sided = {
                ESTIMATE * exp(c(1, -1) * qnorm((1 - conf.level)/2) * 
                  sd)
            })
            RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, 
                p.value = PVAL)
        }
        else {
            METHOD <- paste("Exact conditional test of independence", 
                "in 2 x 2 x k tables")
            m <- apply(x, c(2L, 3L), sum)[1, ]
            n <- apply(x, c(2L, 3L), sum)[2, ]
            t <- apply(x, c(1L, 3L), sum)[1, ]
            s <- sum(x[1, 1, ])
            lo <- sum(pmax(0, t - n))
            hi <- sum(pmin(m, t))
            support <- lo:hi
            dc <- .C(R_d2x2xk, as.integer(K), as.double(m), as.double(n), 
                as.double(t), d = double(hi - lo + 1))$d
            logdc <- log(dc)
            dn2x2xk <- function(ncp) {
                if (ncp == 1) 
                  return(dc)
                d <- logdc + log(ncp) * support
                d <- exp(d - max(d))
                d/sum(d)
            }
            mn2x2xk <- function(ncp) {
                if (ncp == 0) 
                  return(lo)
                if (ncp == Inf) 
                  return(hi)
                sum(support * dn2x2xk(ncp))
            }
            pn2x2xk <- function(q, ncp = 1, upper.tail = FALSE) {
                if (ncp == 0) {
                  if (upper.tail) 
                    return(as.numeric(q <= lo))
                  else return(as.numeric(q >= lo))
                }
                if (ncp == Inf) {
                  if (upper.tail) 
                    return(as.numeric(q <= hi))
                  else return(as.numeric(q >= hi))
                }
                d <- dn2x2xk(ncp)
                if (upper.tail) 
                  sum(d[support >= q])
                else sum(d[support <= q])
            }
            PVAL <- switch(alternative, less = pn2x2xk(s, 1), 
                greater = pn2x2xk(s, 1, upper.tail = TRUE), two.sided = {
                  relErr <- 1 + 10^(-7)
                  d <- dc
                  sum(d[d <= d[s - lo + 1] * relErr])
                })
            mle <- function(x) {
                if (x == lo) 
                  return(0)
                if (x == hi) 
                  return(Inf)
                mu <- mn2x2xk(1)
                if (mu > x) 
                  uniroot(function(t) mn2x2xk(t) - x, c(0, 1))$root
                else if (mu < x) 
                  1/uniroot(function(t) mn2x2xk(1/t) - x, c(.Machine$double.eps, 
                    1))$root
                else 1
            }
            ESTIMATE <- mle(s)
            ncp.U <- function(x, alpha) {
                if (x == hi) 
                  return(Inf)
                p <- pn2x2xk(x, 1)
                if (p < alpha) 
                  uniroot(function(t) pn2x2xk(x, t) - alpha, 
                    c(0, 1))$root
                else if (p > alpha) 
                  1/uniroot(function(t) pn2x2xk(x, 1/t) - alpha, 
                    c(.Machine$double.eps, 1))$root
                else 1
            }
            ncp.L <- function(x, alpha) {
                if (x == lo) 
                  return(0)
                p <- pn2x2xk(x, 1, upper.tail = TRUE)
                if (p > alpha) 
                  uniroot(function(t) pn2x2xk(x, t, upper.tail = TRUE) - 
                    alpha, c(0, 1))$root
                else if (p < alpha) 
                  1/uniroot(function(t) pn2x2xk(x, 1/t, upper.tail = TRUE) - 
                    alpha, c(.Machine$double.eps, 1))$root
                else 1
            }
            CINT <- switch(alternative, less = c(0, ncp.U(s, 
                1 - conf.level)), greater = c(ncp.L(s, 1 - conf.level), 
                Inf), two.sided = {
                alpha <- (1 - conf.level)/2
                c(ncp.L(s, alpha), ncp.U(s, alpha))
            })
            STATISTIC <- s
            names(STATISTIC) <- "S"
            RVAL <- list(statistic = STATISTIC, p.value = PVAL)
        }
        names(ESTIMATE) <- names(NVAL)
        attr(CINT, "conf.level") <- conf.level
        RVAL <- c(RVAL, list(conf.int = CINT, estimate = ESTIMATE, 
            null.value = NVAL, alternative = alternative))
    }
    else {
        df <- (I - 1) * (J - 1)
        n <- m <- double(length = df)
        V <- matrix(0, nrow = df, ncol = df)
        for (k in 1:K) {
            f <- x[, , k]
            ntot <- sum(f)
            rowsums <- apply(f, 1L, sum)[-I]
            colsums <- apply(f, 2L, sum)[-J]
            n <- n + c(f[-I, -J])
            m <- m + c(outer(rowsums, colsums, "*"))/ntot
            V <- V + (kronecker(diag(ntot * colsums, nrow = J - 
                1) - outer(colsums, colsums), diag(ntot * rowsums, 
                nrow = I - 1) - outer(rowsums, rowsums))/(ntot^2 * 
                (ntot - 1)))
        }
        n <- n - m
        STATISTIC <- c(crossprod(n, qr.solve(V, n)))
        PARAMETER <- df
        PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
        names(STATISTIC) <- "Cochran-Mantel-Haenszel M^2"
        names(PARAMETER) <- "df"
        METHOD <- "Cochran-Mantel-Haenszel test"
        RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, 
            p.value = PVAL)
    }
    RVAL <- c(RVAL, list(method = METHOD, data.name = DNAME))
    class(RVAL) <- "htest"
    return(RVAL)
}
<environment: namespace:stats>
> print("mauchly.test"); if(is.function(try(mauchly.test))) {mauchly.test;} else{ NULL};
[1] "mauchly.test"
function (object, ...) 
UseMethod("mauchly.test", object)
<environment: namespace:stats>
> print("mcnemar.test"); if(is.function(try(mcnemar.test))) {mcnemar.test;} else{ NULL};
[1] "mcnemar.test"
function (x, y = NULL, correct = TRUE) 
{
    if (is.matrix(x)) {
        r <- nrow(x)
        if ((r < 2) || (ncol(x) != r)) 
            stop("'x' must be square with at least two rows and columns")
        if (any(x < 0) || any(is.na(x))) 
            stop("all entries of 'x' must be nonnegative and finite")
        DNAME <- deparse(substitute(x))
    }
    else {
        if (is.null(y)) 
            stop("if 'x' is not a matrix, 'y' must be given")
        if (length(x) != length(y)) 
            stop("'x' and 'y' must have the same length")
        DNAME <- paste(deparse(substitute(x)), "and", deparse(substitute(y)))
        OK <- complete.cases(x, y)
        x <- as.factor(x[OK])
        y <- as.factor(y[OK])
        r <- nlevels(x)
        if ((r < 2) || (nlevels(y) != r)) 
            stop("'x' and 'y' must have the same number of levels (minimum 2)")
        x <- table(x, y)
    }
    PARAMETER <- r * (r - 1)/2
    METHOD <- "McNemar's Chi-squared test"
    if (correct && (r == 2) && any(x - t(x) != 0)) {
        y <- (abs(x - t(x)) - 1)
        METHOD <- paste(METHOD, "with continuity correction")
    }
    else y <- x - t(x)
    x <- x + t(x)
    STATISTIC <- sum(y[upper.tri(x)]^2/x[upper.tri(x)])
    PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
    names(STATISTIC) <- "McNemar's chi-squared"
    names(PARAMETER) <- "df"
    RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, 
        p.value = PVAL, method = METHOD, data.name = DNAME)
    class(RVAL) <- "htest"
    return(RVAL)
}
<environment: namespace:stats>
> print("median"); if(is.function(try(median))) {median;} else{ NULL};
[1] "median"
function (x, na.rm = FALSE) 
UseMethod("median")
<environment: namespace:stats>
> print("medpolish"); if(is.function(try(medpolish))) {medpolish;} else{ NULL};
[1] "medpolish"
function (x, eps = 0.01, maxiter = 10, trace.iter = TRUE, na.rm = FALSE) 
{
    z <- as.matrix(x)
    nr <- nrow(z)
    nc <- ncol(z)
    t <- 0
    r <- numeric(nr)
    c <- numeric(nc)
    oldsum <- 0
    for (iter in 1L:maxiter) {
        rdelta <- apply(z, 1L, median, na.rm = na.rm)
        z <- z - matrix(rdelta, nrow = nr, ncol = nc)
        r <- r + rdelta
        delta <- median(c, na.rm = na.rm)
        c <- c - delta
        t <- t + delta
        cdelta <- apply(z, 2L, median, na.rm = na.rm)
        z <- z - matrix(cdelta, nrow = nr, ncol = nc, byrow = TRUE)
        c <- c + cdelta
        delta <- median(r, na.rm = na.rm)
        r <- r - delta
        t <- t + delta
        newsum <- sum(abs(z), na.rm = na.rm)
        converged <- newsum == 0 || abs(newsum - oldsum) < eps * 
            newsum
        if (converged) 
            break
        oldsum <- newsum
        if (trace.iter) 
            cat(iter, ":", newsum, "\n")
    }
    if (converged) {
        if (trace.iter) 
            cat("Final:", newsum, "\n")
    }
    else warning(gettextf("medpolish() did not converge in %d iterations", 
        maxiter), domain = NA)
    names(r) <- rownames(z)
    names(c) <- colnames(z)
    ans <- list(overall = t, row = r, col = c, residuals = z, 
        name = deparse(substitute(x)))
    class(ans) <- "medpolish"
    ans
}
<environment: namespace:stats>
> print("model.extract"); if(is.function(try(model.extract))) {model.extract;} else{ NULL};
[1] "model.extract"
function (frame, component) 
{
    component <- as.character(substitute(component))
    rval <- switch(component, response = model.response(frame), 
        offset = model.offset(frame), frame[[paste("(", component, 
            ")", sep = "")]])
    if (!is.null(rval)) {
        if (length(rval) == nrow(frame)) 
            names(rval) <- attr(frame, "row.names")
        else if (is.matrix(rval) && nrow(rval) == nrow(frame)) {
            t1 <- dimnames(rval)
            dimnames(rval) <- list(attr(frame, "row.names"), 
                t1[[2L]])
        }
    }
    return(rval)
}
<environment: namespace:stats>
> print("model.frame"); if(is.function(try(model.frame))) {model.frame;} else{ NULL};
[1] "model.frame"
function (formula, ...) 
UseMethod("model.frame")
<environment: namespace:stats>
> print("model.matrix"); if(is.function(try(model.matrix))) {model.matrix;} else{ NULL};
[1] "model.matrix"
function (object, ...) 
UseMethod("model.matrix")
<environment: namespace:stats>
> print("model.tables"); if(is.function(try(model.tables))) {model.tables;} else{ NULL};
[1] "model.tables"
function (x, ...) 
UseMethod("model.tables")
<environment: namespace:stats>
> print("monthplot"); if(is.function(try(monthplot))) {monthplot;} else{ NULL};
[1] "monthplot"
function (x, ...) 
UseMethod("monthplot")
<environment: namespace:stats>
> print("mood.test"); if(is.function(try(mood.test))) {mood.test;} else{ NULL};
[1] "mood.test"
function (x, ...) 
UseMethod("mood.test")
<environment: namespace:stats>
> print("na.action"); if(is.function(try(na.action))) {na.action;} else{ NULL};
[1] "na.action"
function (object, ...) 
UseMethod("na.action")
<environment: namespace:stats>
> print("na.contiguous"); if(is.function(try(na.contiguous))) {na.contiguous;} else{ NULL};
[1] "na.contiguous"
function (object, ...) 
UseMethod("na.contiguous")
<environment: namespace:stats>
> print("na.fail"); if(is.function(try(na.fail))) {na.fail;} else{ NULL};
[1] "na.fail"
function (object, ...) 
UseMethod("na.fail")
<environment: namespace:stats>
> print("naprint"); if(is.function(try(naprint))) {naprint;} else{ NULL};
[1] "naprint"
function (x, ...) 
UseMethod("naprint")
<environment: namespace:stats>
> print("naresid"); if(is.function(try(naresid))) {naresid;} else{ NULL};
[1] "naresid"
function (omit, x, ...) 
UseMethod("naresid")
<environment: namespace:stats>
> print("nextn"); if(is.function(try(nextn))) {nextn;} else{ NULL};
[1] "nextn"
function (n, factors = c(2, 3, 5)) 
.Internal(nextn(n, factors))
<environment: namespace:stats>
> print("nlm"); if(is.function(try(nlm))) {nlm;} else{ NULL};
[1] "nlm"
function (f, p, ..., hessian = FALSE, typsize = rep(1, length(p)), 
    fscale = 1, print.level = 0, ndigit = 12, gradtol = 1e-06, 
    stepmax = max(1000 * sqrt(sum((p/typsize)^2)), 1000), steptol = 1e-06, 
    iterlim = 100, check.analyticals = TRUE) 
{
    print.level <- as.integer(print.level)
    if (print.level < 0 || print.level > 2) 
        stop("'print.level' must be in {0,1,2}")
    msg <- (1 + c(8, 0, 16))[1 + print.level]
    if (!check.analyticals) 
        msg <- msg + (2 + 4)
    .Internal(nlm(function(x) f(x, ...), p, hessian, typsize, 
        fscale, msg, ndigit, gradtol, stepmax, steptol, iterlim))
}
<environment: namespace:stats>
> print("nlminb"); if(is.function(try(nlminb))) {nlminb;} else{ NULL};
[1] "nlminb"
function (start, objective, gradient = NULL, hessian = NULL, 
    ..., scale = 1, control = list(), lower = -Inf, upper = Inf) 
{
    par <- as.double(start)
    names(par) <- names(start)
    n <- length(par)
    iv <- integer(78 + 3 * n)
    v <- double(130 + (n * (n + 27))/2)
    .Call(R_port_ivset, 2, iv, v)
    if (length(control)) {
        nms <- names(control)
        if (!is.list(control) || is.null(nms)) 
            stop("control argument must be a named list")
        pos <- pmatch(nms, names(port_cpos))
        if (any(nap <- is.na(pos))) {
            warning(paste("unrecognized control element(s) named `", 
                paste(nms[nap], collapse = ", "), "' ignored", 
                sep = ""))
            pos <- pos[!nap]
            control <- control[!nap]
        }
        ivpars <- pos <= 4
        vpars <- !ivpars
        if (any(ivpars)) 
            iv[port_cpos[pos[ivpars]]] <- as.integer(unlist(control[ivpars]))
        if (any(vpars)) 
            v[port_cpos[pos[vpars]]] <- as.double(unlist(control[vpars]))
    }
    obj <- quote(objective(.par, ...))
    rho <- new.env(parent = environment())
    assign(".par", par, envir = rho)
    grad <- hess <- low <- upp <- NULL
    if (!is.null(gradient)) {
        grad <- quote(gradient(.par, ...))
        if (!is.null(hessian)) {
            if (is.logical(hessian)) 
                stop("Logical `hessian' argument not allowed.  See documentation.")
            hess <- quote(hessian(.par, ...))
        }
    }
    if (any(lower != -Inf) || any(upper != Inf)) {
        low <- rep(as.double(lower), length.out = length(par))
        upp <- rep(as.double(upper), length.out = length(par))
    }
    else low <- upp <- numeric()
    .Call(R_port_nlminb, obj, grad, hess, rho, low, upp, d = rep(as.double(scale), 
        length.out = length(par)), iv, v)
    iv1 <- iv[1L]
    list(par = get(".par", envir = rho), objective = v[10L], 
        convergence = (if (iv1 %in% 3L:6L) 0L else 1L), iterations = iv[31L], 
        evaluations = c(`function` = iv[6L], gradient = iv[30L]), 
        message = if (19 <= iv1 && iv1 <= 43) {
            if (any(B <- iv1 == port_cpos)) sprintf("'control' component '%s' = %g, is out of range", 
                names(port_cpos)[B], v[iv1]) else sprintf("V[IV[1]] = V[%d] = %g is out of range (see PORT docu.)", 
                iv1, v[iv1])
        } else port_msg(iv1))
}
<environment: namespace:stats>
> print("nls"); if(is.function(try(nls))) {nls;} else{ NULL};
[1] "nls"
function (formula, data = parent.frame(), start, control = nls.control(), 
    algorithm = c("default", "plinear", "port"), trace = FALSE, 
    subset, weights, na.action, model = FALSE, lower = -Inf, 
    upper = Inf, ...) 
{
    formula <- as.formula(formula)
    algorithm <- match.arg(algorithm)
    if (!is.list(data) && !is.environment(data)) 
        stop("'data' must be a list or an environment")
    mf <- match.call()
    varNames <- all.vars(formula)
    if (length(formula) == 2L) {
        formula[[3L]] <- formula[[2L]]
        formula[[2L]] <- 0
    }
    form2 <- formula
    form2[[2L]] <- 0
    varNamesRHS <- all.vars(form2)
    mWeights <- missing(weights)
    pnames <- if (missing(start)) {
        if (!is.null(attr(data, "parameters"))) {
            names(attr(data, "parameters"))
        }
        else {
            cll <- formula[[length(formula)]]
            func <- get(as.character(cll[[1L]]))
            if (!is.null(pn <- attr(func, "pnames"))) 
                as.character(as.list(match.call(func, call = cll))[-1L][pn])
        }
    }
    else names(start)
    env <- environment(formula)
    if (is.null(env)) 
        env <- parent.frame()
    if (length(pnames)) 
        varNames <- varNames[is.na(match(varNames, pnames))]
    lenVar <- function(var) tryCatch(length(eval(as.name(var), 
        data, env)), error = function(e) -1)
    if (length(varNames)) {
        n <- sapply(varNames, lenVar)
        if (any(not.there <- n == -1)) {
            nnn <- names(n[not.there])
            if (missing(start)) {
                if (algorithm == "plinear") 
                  stop("No starting values specified")
                warning("No starting values specified for some parameters.\n", 
                  "Intializing ", paste(sQuote(nnn), collapse = ", "), 
                  " to '1.'.\n", "Consider specifying 'start' or using a selfStart model")
                start <- as.list(rep(1, length(nnn)))
                names(start) <- nnn
                varNames <- varNames[i <- is.na(match(varNames, 
                  nnn))]
                n <- n[i]
            }
            else stop("parameters without starting value in 'data': ", 
                paste(nnn, collapse = ", "))
        }
    }
    else {
        if (length(pnames) && any((np <- sapply(pnames, lenVar)) == 
            -1)) {
            message("fitting parameters ", paste(sQuote(pnames[np == 
                -1]), collapse = ", "), " without any variables")
            n <- integer()
        }
        else stop("no parameters to fit")
    }
    respLength <- length(eval(formula[[2L]], data, env))
    if (length(n) > 0L) {
        varIndex <- n%%respLength == 0
        if (is.list(data) && diff(range(n[names(n) %in% names(data)])) > 
            0) {
            mf <- data
            if (!missing(subset)) 
                warning("argument 'subset' will be ignored")
            if (!missing(na.action)) 
                warning("argument 'na.action' will be ignored")
            if (missing(start)) 
                start <- getInitial(formula, mf)
            startEnv <- new.env(hash = FALSE, parent = environment(formula))
            for (i in names(start)) assign(i, start[[i]], envir = startEnv)
            rhs <- eval(formula[[3L]], data, startEnv)
            n <- NROW(rhs)
            wts <- if (mWeights) 
                rep(1, n)
            else eval(substitute(weights), data, environment(formula))
        }
        else {
            mf$formula <- as.formula(paste("~", paste(varNames[varIndex], 
                collapse = "+")), env = environment(formula))
            mf$start <- mf$control <- mf$algorithm <- mf$trace <- mf$model <- NULL
            mf$lower <- mf$upper <- NULL
            mf[[1L]] <- as.name("model.frame")
            mf <- eval.parent(mf)
            n <- nrow(mf)
            mf <- as.list(mf)
            wts <- if (!mWeights) 
                model.weights(mf)
            else rep(1, n)
        }
        if (any(wts < 0 | is.na(wts))) 
            stop("missing or negative weights not allowed")
    }
    else {
        varIndex <- logical()
        mf <- list(0)
        wts <- numeric()
    }
    if (missing(start)) 
        start <- getInitial(formula, mf)
    for (var in varNames[!varIndex]) mf[[var]] <- eval(as.name(var), 
        data, env)
    varNamesRHS <- varNamesRHS[varNamesRHS %in% varNames[varIndex]]
    m <- switch(algorithm, plinear = nlsModel.plinear(formula, 
        mf, start, wts), port = nlsModel(formula, mf, start, 
        wts, upper), nlsModel(formula, mf, start, wts))
    ctrl <- nls.control()
    if (!missing(control)) {
        control <- as.list(control)
        ctrl[names(control)] <- control
    }
    if (algorithm != "port") {
        if (!missing(lower) || !missing(upper)) 
            warning("Upper or lower bounds ignored unless algorithm = \"port\"")
        convInfo <- .Call(R_nls_iter, m, ctrl, trace)
        nls.out <- list(m = m, convInfo = convInfo, data = substitute(data), 
            call = match.call())
    }
    else {
        pfit <- nls_port_fit(m, start, lower, upper, control, 
            trace, give.v = TRUE)
        iv <- pfit[["iv"]]
        msg.nls <- port_msg(iv[1L])
        conv <- (iv[1L] %in% 3:6)
        if (!conv) {
            msg <- paste("Convergence failure:", msg.nls)
            if (ctrl$warnOnly) 
                warning(msg)
            else stop(msg)
        }
        v. <- port_get_named_v(pfit[["v"]])
        cInfo <- list(isConv = conv, finIter = iv[31L], finTol = v.[["NREDUC"]], 
            nEval = c(`function` = iv[6L], gradient = iv[30L]), 
            stopCode = iv[1L], stopMessage = msg.nls)
        cl <- match.call()
        cl$lower <- lower
        cl$upper <- upper
        nls.out <- list(m = m, data = substitute(data), call = cl, 
            convInfo = cInfo, convergence = as.integer(!conv), 
            message = msg.nls)
    }
    nls.out$call$algorithm <- algorithm
    nls.out$call$control <- ctrl
    nls.out$call$trace <- trace
    nls.out$na.action <- attr(mf, "na.action")
    nls.out$dataClasses <- attr(attr(mf, "terms"), "dataClasses")[varNamesRHS]
    if (model) 
        nls.out$model <- mf
    if (!mWeights) 
        nls.out$weights <- wts
    nls.out$control <- control
    class(nls.out) <- "nls"
    nls.out
}
<environment: namespace:stats>
> print("nls.control"); if(is.function(try(nls.control))) {nls.control;} else{ NULL};
[1] "nls.control"
function (maxiter = 50, tol = 1e-05, minFactor = 1/1024, printEval = FALSE, 
    warnOnly = FALSE) 
list(maxiter = maxiter, tol = tol, minFactor = minFactor, printEval = printEval, 
    warnOnly = warnOnly)
<environment: namespace:stats>
> print("nobs"); if(is.function(try(nobs))) {nobs;} else{ NULL};
[1] "nobs"
function (object, ...) 
UseMethod("nobs")
<environment: namespace:stats>
> print("numericDeriv"); if(is.function(try(numericDeriv))) {numericDeriv;} else{ NULL};
[1] "numericDeriv"
function (expr, theta, rho = parent.frame(), dir = 1) 
{
    dir <- rep(dir, length.out = length(theta))
    val <- .Call(R_numeric_deriv, expr, theta, rho, dir)
    valDim <- dim(val)
    if (!is.null(valDim)) {
        if (valDim[length(valDim)] == 1) 
            valDim <- valDim[-length(valDim)]
        if (length(valDim) > 1L) 
            dim(attr(val, "gradient")) <- c(valDim, dim(attr(val, 
                "gradient"))[-1L])
    }
    val
}
<environment: namespace:stats>
> print("offset"); if(is.function(try(offset))) {offset;} else{ NULL};
[1] "offset"
function (object) 
object
<environment: namespace:stats>
> print("oneway.test"); if(is.function(try(oneway.test))) {oneway.test;} else{ NULL};
[1] "oneway.test"
function (formula, data, subset, na.action, var.equal = FALSE) 
{
    if (missing(formula) || (length(formula) != 3L)) 
        stop("'formula' missing or incorrect")
    dp <- as.character(formula)
    if (length(dp) != 3L) 
        stop("a two-sided formula is required")
    DNAME <- paste(dp[[2L]], "and", dp[[3L]])
    m <- match.call(expand.dots = FALSE)
    if (is.matrix(eval(m$data, parent.frame()))) 
        m$data <- as.data.frame(data)
    m$var.equal <- NULL
    m[[1L]] <- as.name("model.frame")
    mf <- eval(m, parent.frame())
    response <- attr(attr(mf, "terms"), "response")
    y <- mf[[response]]
    if (length(mf[-response]) > 1L) 
        g <- factor(do.call("interaction", mf[-response]))
    else g <- factor(mf[[-response]])
    k <- nlevels(g)
    if (k < 2L) 
        stop("not enough groups")
    n.i <- tapply(y, g, length)
    if (any(n.i < 2)) 
        stop("not enough observations")
    m.i <- tapply(y, g, mean)
    v.i <- tapply(y, g, var)
    w.i <- n.i/v.i
    sum.w.i <- sum(w.i)
    tmp <- sum((1 - w.i/sum.w.i)^2/(n.i - 1))/(k^2 - 1)
    METHOD <- "One-way analysis of means"
    if (var.equal) {
        n <- sum(n.i)
        STATISTIC <- ((sum(n.i * (m.i - mean(y))^2)/(k - 1))/(sum((n.i - 
            1) * v.i)/(n - k)))
        PARAMETER <- c(k - 1, n - k)
        PVAL <- pf(STATISTIC, k - 1, n - k, lower.tail = FALSE)
    }
    else {
        m <- sum(w.i * m.i)/sum.w.i
        STATISTIC <- sum(w.i * (m.i - m)^2)/((k - 1) * (1 + 2 * 
            (k - 2) * tmp))
        PARAMETER <- c(k - 1, 1/(3 * tmp))
        PVAL <- pf(STATISTIC, k - 1, 1/(3 * tmp), lower.tail = FALSE)
        METHOD <- paste(METHOD, "(not assuming equal variances)")
    }
    names(STATISTIC) <- "F"
    names(PARAMETER) <- c("num df", "denom df")
    RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, 
        p.value = PVAL, method = METHOD, data.name = DNAME)
    class(RVAL) <- "htest"
    RVAL
}
<environment: namespace:stats>
> print("optim"); if(is.function(try(optim))) {optim;} else{ NULL};
[1] "optim"
function (par, fn, gr = NULL, ..., method = c("Nelder-Mead", 
    "BFGS", "CG", "L-BFGS-B", "SANN"), lower = -Inf, upper = Inf, 
    control = list(), hessian = FALSE) 
{
    fn1 <- function(par) fn(par, ...)
    gr1 <- if (!is.null(gr)) 
        function(par) gr(par, ...)
    method <- match.arg(method)
    if ((length(lower) > 1L || length(upper) > 1L || lower[1L] != 
        -Inf || upper[1L] != Inf) && method != "L-BFGS-B") {
        warning("bounds can only be used with method L-BFGS-B")
        method <- "L-BFGS-B"
    }
    con <- list(trace = 0, fnscale = 1, parscale = rep.int(1, 
        length(par)), ndeps = rep.int(0.001, length(par)), maxit = 100L, 
        abstol = -Inf, reltol = sqrt(.Machine$double.eps), alpha = 1, 
        beta = 0.5, gamma = 2, REPORT = 10, type = 1, lmm = 5, 
        factr = 1e+07, pgtol = 0, tmax = 10, temp = 10)
    nmsC <- names(con)
    if (method == "Nelder-Mead") 
        con$maxit <- 500
    if (method == "SANN") {
        con$maxit <- 10000
        con$REPORT <- 100
    }
    con[(namc <- names(control))] <- control
    if (length(noNms <- namc[!namc %in% nmsC])) 
        warning("unknown names in control: ", paste(noNms, collapse = ", "))
    if (con$trace < 0) 
        warning("read the documentation for 'trace' more carefully")
    else if (method == "SANN" && con$trace && as.integer(con$REPORT) == 
        0) 
        stop("'trace != 0' needs 'REPORT >= 1'")
    if (method == "L-BFGS-B" && any(!is.na(match(c("reltol", 
        "abstol"), namc)))) 
        warning("method L-BFGS-B uses 'factr' (and 'pgtol') instead of 'reltol' and 'abstol'")
    npar <- length(par)
    if (npar == 1 && method == "Nelder-Mead") 
        warning("one-diml optimization by Nelder-Mead is unreliable: use optimize")
    lower <- as.double(rep(lower, , npar))
    upper <- as.double(rep(upper, , npar))
    res <- .Internal(optim(par, fn1, gr1, method, con, lower, 
        upper))
    names(res) <- c("par", "value", "counts", "convergence", 
        "message")
    nm <- names(par)
    if (!is.null(nm)) 
        names(res$par) <- nm
    names(res$counts) <- c("function", "gradient")
    if (hessian) {
        hess <- .Internal(optimhess(res$par, fn1, gr1, con))
        hess <- 0.5 * (hess + t(hess))
        if (!is.null(nm)) 
            dimnames(hess) <- list(nm, nm)
        res$hessian <- hess
    }
    res
}
<environment: namespace:stats>
> print("optimize"); if(is.function(try(optimize))) {optimize;} else{ NULL};
[1] "optimize"
function (f, interval, ..., lower = min(interval), upper = max(interval), 
    maximum = FALSE, tol = .Machine$double.eps^0.25) 
{
    if (maximum) {
        val <- .Internal(fmin(function(arg) -f(arg, ...), lower, 
            upper, tol))
        list(maximum = val, objective = f(val, ...))
    }
    else {
        val <- .Internal(fmin(function(arg) f(arg, ...), lower, 
            upper, tol))
        list(minimum = val, objective = f(val, ...))
    }
}
<environment: namespace:stats>
> print("order.dendrogram"); if(is.function(try(order.dendrogram))) {order.dendrogram;} else{ NULL};
[1] "order.dendrogram"
function (x) 
{
    if (!inherits(x, "dendrogram")) 
        stop("'order.dendrogram' requires a dendrogram")
    unlist(x)
}
<environment: namespace:stats>
> print("p.adjust"); if(is.function(try(p.adjust))) {p.adjust;} else{ NULL};
[1] "p.adjust"
function (p, method = p.adjust.methods, n = length(p)) 
{
    method <- match.arg(method)
    if (method == "fdr") 
        method <- "BH"
    nm <- names(p)
    p <- as.numeric(p)
    names(p) <- nm
    p0 <- p
    if (all(nna <- !is.na(p))) 
        nna <- TRUE
    p <- p[nna]
    lp <- length(p)
    stopifnot(n >= lp)
    if (n <= 1) 
        return(p0)
    if (n == 2 && method == "hommel") 
        method <- "hochberg"
    p0[nna] <- switch(method, bonferroni = pmin(1, n * p), holm = {
        i <- seq_len(lp)
        o <- order(p)
        ro <- order(o)
        pmin(1, cummax((n - i + 1L) * p[o]))[ro]
    }, hommel = {
        if (n > lp) p <- c(p, rep.int(1, n - lp))
        i <- seq_len(n)
        o <- order(p)
        p <- p[o]
        ro <- order(o)
        q <- pa <- rep.int(min(n * p/i), n)
        for (j in (n - 1):2) {
            ij <- seq_len(n - j + 1)
            i2 <- (n - j + 2):n
            q1 <- min(j * p[i2]/(2:j))
            q[ij] <- pmin(j * p[ij], q1)
            q[i2] <- q[n - j + 1]
            pa <- pmax(pa, q)
        }
        pmax(pa, p)[if (lp < n) ro[1:lp] else ro]
    }, hochberg = {
        i <- lp:1L
        o <- order(p, decreasing = TRUE)
        ro <- order(o)
        pmin(1, cummin((n - i + 1L) * p[o]))[ro]
    }, BH = {
        i <- lp:1L
        o <- order(p, decreasing = TRUE)
        ro <- order(o)
        pmin(1, cummin(n/i * p[o]))[ro]
    }, BY = {
        i <- lp:1L
        o <- order(p, decreasing = TRUE)
        ro <- order(o)
        q <- sum(1L/(1L:n))
        pmin(1, cummin(q * n/i * p[o]))[ro]
    }, none = p)
    p0
}
<environment: namespace:stats>
> print("pairwise.prop.test"); if(is.function(try(pairwise.prop.test))) {pairwise.prop.test;} else{ NULL};
[1] "pairwise.prop.test"
function (x, n, p.adjust.method = p.adjust.methods, ...) 
{
    p.adjust.method <- match.arg(p.adjust.method)
    METHOD <- "Pairwise comparison of proportions"
    DNAME <- deparse(substitute(x))
    if (is.matrix(x)) {
        if (ncol(x) != 2) 
            stop("'x' must have 2 columns")
        n <- rowSums(x)
        x <- x[, 1]
    }
    else {
        DNAME <- paste(DNAME, "out of", deparse(substitute(n)))
        if (length(x) != length(n)) 
            stop("'x' and 'n' must have the same length")
    }
    OK <- complete.cases(x, n)
    x <- x[OK]
    n <- n[OK]
    if (length(x) < 2L) 
        stop("too few groups")
    compare.levels <- function(i, j) {
        prop.test(x[c(i, j)], n[c(i, j)], ...)$p.value
    }
    level.names <- names(x)
    if (is.null(level.names)) 
        level.names <- seq_along(x)
    PVAL <- pairwise.table(compare.levels, level.names, p.adjust.method)
    ans <- list(method = METHOD, data.name = DNAME, p.value = PVAL, 
        p.adjust.method = p.adjust.method)
    class(ans) <- "pairwise.htest"
    ans
}
<environment: namespace:stats>
> print("pairwise.t.test"); if(is.function(try(pairwise.t.test))) {pairwise.t.test;} else{ NULL};
[1] "pairwise.t.test"
function (x, g, p.adjust.method = p.adjust.methods, pool.sd = !paired, 
    paired = FALSE, alternative = c("two.sided", "less", "greater"), 
    ...) 
{
    if (paired & pool.sd) 
        stop("Pooling of SD is incompatible with paired tests")
    DNAME <- paste(deparse(substitute(x)), "and", deparse(substitute(g)))
    g <- factor(g)
    p.adjust.method <- match.arg(p.adjust.method)
    alternative <- match.arg(alternative)
    if (pool.sd) {
        METHOD <- "t tests with pooled SD"
        xbar <- tapply(x, g, mean, na.rm = TRUE)
        s <- tapply(x, g, sd, na.rm = TRUE)
        n <- tapply(!is.na(x), g, sum)
        degf <- n - 1
        total.degf <- sum(degf)
        pooled.sd <- sqrt(sum(s^2 * degf)/total.degf)
        compare.levels <- function(i, j) {
            dif <- xbar[i] - xbar[j]
            se.dif <- pooled.sd * sqrt(1/n[i] + 1/n[j])
            t.val <- dif/se.dif
            if (alternative == "two.sided") 
                2 * pt(-abs(t.val), total.degf)
            else pt(t.val, total.degf, lower.tail = (alternative == 
                "less"))
        }
    }
    else {
        METHOD <- if (paired) 
            "paired t tests"
        else "t tests with non-pooled SD"
        compare.levels <- function(i, j) {
            xi <- x[as.integer(g) == i]
            xj <- x[as.integer(g) == j]
            t.test(xi, xj, paired = paired, alternative = alternative, 
                ...)$p.value
        }
    }
    PVAL <- pairwise.table(compare.levels, levels(g), p.adjust.method)
    ans <- list(method = METHOD, data.name = DNAME, p.value = PVAL, 
        p.adjust.method = p.adjust.method)
    class(ans) <- "pairwise.htest"
    ans
}
<environment: namespace:stats>
> print("pairwise.table"); if(is.function(try(pairwise.table))) {pairwise.table;} else{ NULL};
[1] "pairwise.table"
function (compare.levels, level.names, p.adjust.method) 
{
    ix <- seq_along(level.names)
    names(ix) <- level.names
    pp <- outer(ix[-1L], ix[-length(ix)], function(ivec, jvec) sapply(seq_along(ivec), 
        function(k) {
            i <- ivec[k]
            j <- jvec[k]
            if (i > j) 
                compare.levels(i, j)
            else NA
        }))
    pp[lower.tri(pp, TRUE)] <- p.adjust(pp[lower.tri(pp, TRUE)], 
        p.adjust.method)
    pp
}
<environment: namespace:stats>
> print("pairwise.wilcox.test"); if(is.function(try(pairwise.wilcox.test))) {pairwise.wilcox.test;} else{ NULL};
[1] "pairwise.wilcox.test"
function (x, g, p.adjust.method = p.adjust.methods, paired = FALSE, 
    ...) 
{
    p.adjust.method <- match.arg(p.adjust.method)
    DNAME <- paste(deparse(substitute(x)), "and", deparse(substitute(g)))
    g <- factor(g)
    METHOD <- if (paired) 
        "Wilcoxon signed rank test"
    else "Wilcoxon rank sum test"
    compare.levels <- function(i, j) {
        xi <- x[as.integer(g) == i]
        xj <- x[as.integer(g) == j]
        wilcox.test(xi, xj, paired = paired, ...)$p.value
    }
    PVAL <- pairwise.table(compare.levels, levels(g), p.adjust.method)
    ans <- list(method = METHOD, data.name = DNAME, p.value = PVAL, 
        p.adjust.method = p.adjust.method)
    class(ans) <- "pairwise.htest"
    ans
}
<environment: namespace:stats>
> print("plot.HoltWinters"); if(is.function(try(plot.HoltWinters))) {plot.HoltWinters;} else{ NULL};
[1] "plot.HoltWinters"
NULL
> print("plot.acf"); if(is.function(try(plot.acf))) {plot.acf;} else{ NULL};
[1] "plot.acf"
NULL
> print("plot.density"); if(is.function(try(plot.density))) {plot.density;} else{ NULL};
[1] "plot.density"
function (x, main = NULL, xlab = NULL, ylab = "Density", type = "l", 
    zero.line = TRUE, ...) 
{
    if (is.null(xlab)) 
        xlab <- paste("N =", x$n, "  Bandwidth =", formatC(x$bw))
    if (is.null(main)) 
        main <- deparse(x$call)
    plot.default(x, main = main, xlab = xlab, ylab = ylab, type = type, 
        ...)
    if (zero.line) 
        abline(h = 0, lwd = 0.1, col = "gray")
    invisible(NULL)
}
<environment: namespace:stats>
> print("plot.isoreg"); if(is.function(try(plot.isoreg))) {plot.isoreg;} else{ NULL};
[1] "plot.isoreg"
NULL
> print("plot.lm"); if(is.function(try(plot.lm))) {plot.lm;} else{ NULL};
[1] "plot.lm"
function (x, which = c(1L:3L, 5L), caption = list("Residuals vs Fitted", 
    "Normal Q-Q", "Scale-Location", "Cook's distance", "Residuals vs Leverage", 
    expression("Cook's dist vs Leverage  " * h[ii]/(1 - h[ii]))), 
    panel = if (add.smooth) panel.smooth else points, sub.caption = NULL, 
    main = "", ask = prod(par("mfcol")) < length(which) && dev.interactive(), 
    ..., id.n = 3, labels.id = names(residuals(x)), cex.id = 0.75, 
    qqline = TRUE, cook.levels = c(0.5, 1), add.smooth = getOption("add.smooth"), 
    label.pos = c(4, 2), cex.caption = 1) 
{
    dropInf <- function(x, h) {
        if (any(isInf <- h >= 1)) {
            warning("Not plotting observations with leverage one:\n  ", 
                paste(which(isInf), collapse = ", "), call. = FALSE)
            x[isInf] <- NaN
        }
        x
    }
    if (!inherits(x, "lm")) 
        stop("use only with \"lm\" objects")
    if (!is.numeric(which) || any(which < 1) || any(which > 6)) 
        stop("'which' must be in 1:6")
    isGlm <- inherits(x, "glm")
    show <- rep(FALSE, 6)
    show[which] <- TRUE
    r <- residuals(x)
    yh <- predict(x)
    w <- weights(x)
    if (!is.null(w)) {
        wind <- w != 0
        r <- r[wind]
        yh <- yh[wind]
        w <- w[wind]
        labels.id <- labels.id[wind]
    }
    n <- length(r)
    if (any(show[2L:6L])) {
        s <- if (inherits(x, "rlm")) 
            x$s
        else if (isGlm) 
            sqrt(summary(x)$dispersion)
        else sqrt(deviance(x)/df.residual(x))
        hii <- lm.influence(x, do.coef = FALSE)$hat
        if (any(show[4L:6L])) {
            cook <- if (isGlm) 
                cooks.distance(x)
            else cooks.distance(x, sd = s, res = r)
        }
    }
    if (any(show[2L:3L])) {
        ylab23 <- if (isGlm) 
            "Std. deviance resid."
        else "Standardized residuals"
        r.w <- if (is.null(w)) 
            r
        else sqrt(w) * r
        rs <- dropInf(r.w/(s * sqrt(1 - hii)), hii)
    }
    if (any(show[5L:6L])) {
        r.hat <- range(hii, na.rm = TRUE)
        isConst.hat <- all(r.hat == 0) || diff(r.hat) < 1e-10 * 
            mean(hii, na.rm = TRUE)
    }
    if (any(show[c(1L, 3L)])) 
        l.fit <- if (isGlm) 
            "Predicted values"
        else "Fitted values"
    if (is.null(id.n)) 
        id.n <- 0
    else {
        id.n <- as.integer(id.n)
        if (id.n < 0L || id.n > n) 
            stop(gettextf("'id.n' must be in {1,..,%d}", n), 
                domain = NA)
    }
    if (id.n > 0L) {
        if (is.null(labels.id)) 
            labels.id <- paste(1L:n)
        iid <- 1L:id.n
        show.r <- sort.list(abs(r), decreasing = TRUE)[iid]
        if (any(show[2L:3L])) 
            show.rs <- sort.list(abs(rs), decreasing = TRUE)[iid]
        text.id <- function(x, y, ind, adj.x = TRUE) {
            labpos <- if (adj.x) 
                label.pos[1 + as.numeric(x > mean(range(x)))]
            else 3
            text(x, y, labels.id[ind], cex = cex.id, xpd = TRUE, 
                pos = labpos, offset = 0.25)
        }
    }
    getCaption <- function(k) if (length(caption) < k) 
        NA_character_
    else as.graphicsAnnot(caption[[k]])
    if (is.null(sub.caption)) {
        cal <- x$call
        if (!is.na(m.f <- match("formula", names(cal)))) {
            cal <- cal[c(1, m.f)]
            names(cal)[2L] <- ""
        }
        cc <- deparse(cal, 80)
        nc <- nchar(cc[1L], "c")
        abbr <- length(cc) > 1 || nc > 75
        sub.caption <- if (abbr) 
            paste(substr(cc[1L], 1L, min(75L, nc)), "...")
        else cc[1L]
    }
    one.fig <- prod(par("mfcol")) == 1
    if (ask) {
        oask <- devAskNewPage(TRUE)
        on.exit(devAskNewPage(oask))
    }
    if (show[1L]) {
        ylim <- range(r, na.rm = TRUE)
        if (id.n > 0) 
            ylim <- extendrange(r = ylim, f = 0.08)
        plot(yh, r, xlab = l.fit, ylab = "Residuals", main = main, 
            ylim = ylim, type = "n", ...)
        panel(yh, r, ...)
        if (one.fig) 
            title(sub = sub.caption, ...)
        mtext(getCaption(1), 3, 0.25, cex = cex.caption)
        if (id.n > 0) {
            y.id <- r[show.r]
            y.id[y.id < 0] <- y.id[y.id < 0] - strheight(" ")/3
            text.id(yh[show.r], y.id, show.r)
        }
        abline(h = 0, lty = 3, col = "gray")
    }
    if (show[2L]) {
        ylim <- range(rs, na.rm = TRUE)
        ylim[2L] <- ylim[2L] + diff(ylim) * 0.075
        qq <- qqnorm(rs, main = main, ylab = ylab23, ylim = ylim, 
            ...)
        if (qqline) 
            qqline(rs, lty = 3, col = "gray50")
        if (one.fig) 
            title(sub = sub.caption, ...)
        mtext(getCaption(2), 3, 0.25, cex = cex.caption)
        if (id.n > 0) 
            text.id(qq$x[show.rs], qq$y[show.rs], show.rs)
    }
    if (show[3L]) {
        sqrtabsr <- sqrt(abs(rs))
        ylim <- c(0, max(sqrtabsr, na.rm = TRUE))
        yl <- as.expression(substitute(sqrt(abs(YL)), list(YL = as.name(ylab23))))
        yhn0 <- if (is.null(w)) 
            yh
        else yh[w != 0]
        plot(yhn0, sqrtabsr, xlab = l.fit, ylab = yl, main = main, 
            ylim = ylim, type = "n", ...)
        panel(yhn0, sqrtabsr, ...)
        if (one.fig) 
            title(sub = sub.caption, ...)
        mtext(getCaption(3), 3, 0.25, cex = cex.caption)
        if (id.n > 0) 
            text.id(yhn0[show.rs], sqrtabsr[show.rs], show.rs)
    }
    if (show[4L]) {
        if (id.n > 0) {
            show.r <- order(-cook)[iid]
            ymx <- cook[show.r[1L]] * 1.075
        }
        else ymx <- max(cook, na.rm = TRUE)
        plot(cook, type = "h", ylim = c(0, ymx), main = main, 
            xlab = "Obs. number", ylab = "Cook's distance", ...)
        if (one.fig) 
            title(sub = sub.caption, ...)
        mtext(getCaption(4), 3, 0.25, cex = cex.caption)
        if (id.n > 0) 
            text.id(show.r, cook[show.r], show.r, adj.x = FALSE)
    }
    if (show[5L]) {
        ylab5 <- if (isGlm) 
            "Std. Pearson resid."
        else "Standardized residuals"
        r.w <- residuals(x, "pearson")
        if (!is.null(w)) 
            r.w <- r.w[wind]
        rsp <- dropInf(r.w/(s * sqrt(1 - hii)), hii)
        ylim <- range(rsp, na.rm = TRUE)
        if (id.n > 0) {
            ylim <- extendrange(r = ylim, f = 0.08)
            show.rsp <- order(-cook)[iid]
        }
        do.plot <- TRUE
        if (isConst.hat) {
            if (missing(caption)) 
                caption[[5L]] <- "Constant Leverage:\n Residuals vs Factor Levels"
            aterms <- attributes(terms(x))
            dcl <- aterms$dataClasses[-aterms$response]
            facvars <- names(dcl)[dcl %in% c("factor", "ordered")]
            mf <- model.frame(x)[facvars]
            if (ncol(mf) > 0) {
                effM <- mf
                for (j in seq_len(ncol(mf))) effM[, j] <- sapply(split(yh, 
                  mf[, j]), mean)[mf[, j]]
                ord <- do.call(order, effM)
                dm <- data.matrix(mf)[ord, , drop = FALSE]
                nf <- length(nlev <- unlist(unname(lapply(x$xlevels, 
                  length))))
                ff <- if (nf == 1) 
                  1
                else rev(cumprod(c(1, nlev[nf:2])))
                facval <- (dm - 1) %*% ff
                xx <- facval
                plot(facval, rsp, xlim = c(-1/2, sum((nlev - 
                  1) * ff) + 1/2), ylim = ylim, xaxt = "n", main = main, 
                  xlab = "Factor Level Combinations", ylab = ylab5, 
                  type = "n", ...)
                grp_means <- sapply(split(yh, mf[, 1L]), mean)
                axis(1, at = ff[1L] * (1L:nlev[1L] - 1/2) - 1/2, 
                  labels = x$xlevels[[1L]][order(grp_means)])
                mtext(paste(facvars[1L], ":"), side = 1, line = 0.25, 
                  adj = -0.05)
                abline(v = ff[1L] * (0:nlev[1L]) - 1/2, col = "gray", 
                  lty = "F4")
                panel(facval, rsp, ...)
                abline(h = 0, lty = 3, col = "gray")
            }
            else {
                message("hat values (leverages) are all = ", 
                  format(mean(r.hat)), "\n and there are no factor predictors; no plot no. 5")
                frame()
                do.plot <- FALSE
            }
        }
        else {
            xx <- hii
            xx[xx >= 1] <- NA
            plot(xx, rsp, xlim = c(0, max(xx, na.rm = TRUE)), 
                ylim = ylim, main = main, xlab = "Leverage", 
                ylab = ylab5, type = "n", ...)
            panel(xx, rsp, ...)
            abline(h = 0, v = 0, lty = 3, col = "gray")
            if (one.fig) 
                title(sub = sub.caption, ...)
            if (length(cook.levels)) {
                p <- length(coef(x))
                usr <- par("usr")
                hh <- seq.int(min(r.hat[1L], r.hat[2L]/100), 
                  usr[2L], length.out = 101)
                for (crit in cook.levels) {
                  cl.h <- sqrt(crit * p * (1 - hh)/hh)
                  lines(hh, cl.h, lty = 2, col = 2)
                  lines(hh, -cl.h, lty = 2, col = 2)
                }
                legend("bottomleft", legend = "Cook's distance", 
                  lty = 2, col = 2, bty = "n")
                xmax <- min(0.99, usr[2L])
                ymult <- sqrt(p * (1 - xmax)/xmax)
                aty <- c(-sqrt(rev(cook.levels)) * ymult, sqrt(cook.levels) * 
                  ymult)
                axis(4, at = aty, labels = paste(c(rev(cook.levels), 
                  cook.levels)), mgp = c(0.25, 0.25, 0), las = 2, 
                  tck = 0, cex.axis = cex.id, col.axis = 2)
            }
        }
        if (do.plot) {
            mtext(getCaption(5), 3, 0.25, cex = cex.caption)
            if (id.n > 0) {
                y.id <- rsp[show.rsp]
                y.id[y.id < 0] <- y.id[y.id < 0] - strheight(" ")/3
                text.id(xx[show.rsp], y.id, show.rsp)
            }
        }
    }
    if (show[6L]) {
        g <- dropInf(hii/(1 - hii), hii)
        ymx <- max(cook, na.rm = TRUE) * 1.025
        plot(g, cook, xlim = c(0, max(g, na.rm = TRUE)), ylim = c(0, 
            ymx), main = main, ylab = "Cook's distance", xlab = expression("Leverage  " * 
            h[ii]), xaxt = "n", type = "n", ...)
        panel(g, cook, ...)
        athat <- pretty(hii)
        axis(1, at = athat/(1 - athat), labels = paste(athat))
        if (one.fig) 
            title(sub = sub.caption, ...)
        p <- length(coef(x))
        bval <- pretty(sqrt(p * cook/g), 5)
        usr <- par("usr")
        xmax <- usr[2L]
        ymax <- usr[4L]
        for (i in seq_along(bval)) {
            bi2 <- bval[i]^2
            if (ymax > bi2 * xmax) {
                xi <- xmax + strwidth(" ")/3
                yi <- bi2 * xi
                abline(0, bi2, lty = 2)
                text(xi, yi, paste(bval[i]), adj = 0, xpd = TRUE)
            }
            else {
                yi <- ymax - 1.5 * strheight(" ")
                xi <- yi/bi2
                lines(c(0, xi), c(0, yi), lty = 2)
                text(xi, ymax - 0.8 * strheight(" "), paste(bval[i]), 
                  adj = 0.5, xpd = TRUE)
            }
        }
        mtext(getCaption(6), 3, 0.25, cex = cex.caption)
        if (id.n > 0) {
            show.r <- order(-cook)[iid]
            text.id(g[show.r], cook[show.r], show.r)
        }
    }
    if (!one.fig && par("oma")[3L] >= 1) 
        mtext(sub.caption, outer = TRUE, cex = 1.25)
    invisible()
}
<environment: namespace:stats>
> print("plot.ppr"); if(is.function(try(plot.ppr))) {plot.ppr;} else{ NULL};
[1] "plot.ppr"
NULL
> print("plot.profile.nls"); if(is.function(try(plot.profile.nls))) {plot.profile.nls;} else{ NULL};
[1] "plot.profile.nls"
NULL
> print("plot.spec"); if(is.function(try(plot.spec))) {plot.spec;} else{ NULL};
[1] "plot.spec"
function (x, add = FALSE, ci = 0.95, log = c("yes", "dB", "no"), 
    xlab = "frequency", ylab = NULL, type = "l", ci.col = "blue", 
    ci.lty = 3, main = NULL, sub = NULL, plot.type = c("marginal", 
        "coherency", "phase"), ...) 
{
    spec.ci <- function(spec.obj, coverage = 0.95) {
        if (coverage < 0 || coverage >= 1) 
            stop("coverage probability out of range [0,1)")
        tail <- (1 - coverage)
        df <- spec.obj$df
        upper.quantile <- 1 - tail * pchisq(df, df, lower.tail = FALSE)
        lower.quantile <- tail * pchisq(df, df)
        1/(qchisq(c(upper.quantile, lower.quantile), df)/df)
    }
    plot.type <- match.arg(plot.type)
    log <- match.arg(log)
    m <- match.call()
    if (plot.type == "coherency") {
        m[[1L]] <- as.name("plot.spec.coherency")
        m$plot.type <- m$log <- m$add <- NULL
        return(eval(m, parent.frame()))
    }
    if (plot.type == "phase") {
        m[[1L]] <- as.name("plot.spec.phase")
        m$plot.type <- m$log <- m$add <- NULL
        return(eval(m, parent.frame()))
    }
    if (is.null(ylab)) 
        ylab <- if (log == "dB") 
            "spectrum (dB)"
        else "spectrum"
    if (is.logical(log)) 
        log <- if (log) 
            "yes"
        else "no"
    if (missing(log) && getOption("ts.S.compat")) 
        log <- "dB"
    log <- match.arg(log)
    ylog <- ""
    if (log == "dB") 
        x$spec <- 10 * log10(x$spec)
    if (log == "yes") 
        ylog <- "y"
    if (add) {
        matplot(x$freq, x$spec, type = type, add = TRUE, ...)
    }
    else {
        matplot(x$freq, x$spec, xlab = xlab, ylab = ylab, type = type, 
            log = ylog, ...)
        if (ci <= 0 || !is.numeric(x$df) || log == "no") {
            ci.text <- ""
        }
        else {
            conf.lim <- spec.ci(x, coverage = ci)
            if (log == "dB") {
                conf.lim <- 10 * log10(conf.lim)
                conf.y <- max(x$spec) - conf.lim[2L]
                conf.x <- max(x$freq) - x$bandwidth
                lines(rep(conf.x, 2), conf.y + conf.lim, col = ci.col)
                lines(conf.x + c(-0.5, 0.5) * x$bandwidth, rep(conf.y, 
                  2), col = ci.col)
                ci.text <- paste(", ", round(100 * ci, 2), "% C.I. is (", 
                  paste(format(conf.lim, digits = 3), collapse = ","), 
                  ")dB", sep = "")
            }
            else {
                ci.text <- ""
                conf.y <- max(x$spec)/conf.lim[2L]
                conf.x <- max(x$freq) - x$bandwidth
                lines(rep(conf.x, 2), conf.y * conf.lim, col = ci.col)
                lines(conf.x + c(-0.5, 0.5) * x$bandwidth, rep(conf.y, 
                  2), col = ci.col)
            }
        }
        if (is.null(main)) 
            main <- paste(if (!is.null(x$series)) 
                paste("Series:", x$series)
            else "from specified model", x$method, sep = "\n")
        if (is.null(sub) && is.numeric(x$bandwidth)) 
            sub <- paste("bandwidth = ", format(x$bandwidth, 
                digits = 3), ci.text, sep = "")
        title(main = main, sub = sub)
    }
    invisible(x)
}
<environment: namespace:stats>
> print("plot.stepfun"); if(is.function(try(plot.stepfun))) {plot.stepfun;} else{ NULL};
[1] "plot.stepfun"
function (x, xval, xlim, ylim = range(c(y, Fn.kn)), xlab = "x", 
    ylab = "f(x)", main = NULL, add = FALSE, verticals = TRUE, 
    do.points = (n < 1000), pch = par("pch"), col = par("col"), 
    col.points = col, cex.points = par("cex"), col.hor = col, 
    col.vert = col, lty = par("lty"), lwd = par("lwd"), ...) 
{
    if (!is.stepfun(x)) {
        if (is.numeric(x)) {
            sarg <- substitute(x)
            x <- ecdf(x)
            attr(x, "call") <- call("ecdf", sarg)
        }
        else stop("'plot.stepfun' called with wrong type of argument 'x'")
    }
    if (missing(main)) 
        main <- {
            cl <- attr(x, "call")
            deparse(if (!is.null(cl)) 
                cl
            else sys.call())
        }
    knF <- knots(x)
    xval <- if (missing(xval)) 
        knF
    else sort(xval)
    if (missing(xlim)) {
        rx <- range(xval)
        dr <- if (length(xval) > 1L) 
            max(0.08 * diff(rx), median(diff(xval)))
        else abs(xval)/16
        xlim <- rx + dr * c(-1, 1)
    }
    else dr <- diff(xlim)
    knF <- knF[xlim[1L] - dr <= knF & knF <= xlim[2L] + dr]
    ti <- c(xlim[1L] - dr, knF, xlim[2L] + dr)
    ti.l <- ti[-length(ti)]
    ti.r <- ti[-1L]
    y <- x(0.5 * (ti.l + ti.r))
    n <- length(y)
    Fn.kn <- x(knF)
    if (add) 
        segments(ti.l, y, ti.r, y, col = col.hor, lty = lty, 
            lwd = lwd, ...)
    else {
        if (missing(ylim)) 
            ylim <- range(c(y, Fn.kn))
        plot(NA, NA, type = "n", xlim = xlim, ylim = ylim, xlab = xlab, 
            ylab = ylab, main = main, ...)
        segments(ti.l, y, ti.r, y, col = col.hor, lty = lty, 
            lwd = lwd)
    }
    if (do.points) 
        points(knF, Fn.kn, pch = pch, col = col.points, cex = cex.points)
    if (verticals) 
        segments(knF, y[-n], knF, y[-1L], col = col.vert, lty = lty, 
            lwd = lwd)
    invisible(list(t = ti, y = y))
}
<environment: namespace:stats>
> print("plot.stl"); if(is.function(try(plot.stl))) {plot.stl;} else{ NULL};
[1] "plot.stl"
NULL
> print("plot.ts"); if(is.function(try(plot.ts))) {plot.ts;} else{ NULL};
[1] "plot.ts"
function (x, y = NULL, plot.type = c("multiple", "single"), xy.labels, 
    xy.lines, panel = lines, nc, yax.flip = FALSE, mar.multi = c(0, 
        5.1, 0, if (yax.flip) 5.1 else 2.1), oma.multi = c(6, 
        0, 5, 0), axes = TRUE, ...) 
{
    plotts <- function(x, y = NULL, plot.type = c("multiple", 
        "single"), xy.labels, xy.lines, panel = lines, nc, xlabel, 
        ylabel, type = "l", xlim = NULL, ylim = NULL, xlab = "Time", 
        ylab, log = "", col = par("col"), bg = NA, pch = par("pch"), 
        cex = par("cex"), lty = par("lty"), lwd = par("lwd"), 
        axes = TRUE, frame.plot = axes, ann = par("ann"), cex.lab = par("cex.lab"), 
        col.lab = par("col.lab"), font.lab = par("font.lab"), 
        cex.axis = par("cex.axis"), col.axis = par("col.axis"), 
        font.axis = par("font.axis"), main = NULL, ...) {
        plot.type <- match.arg(plot.type)
        nser <- NCOL(x)
        if (plot.type == "multiple" && nser > 1) {
            addmain <- function(main, cex.main = par("cex.main"), 
                font.main = par("font.main"), col.main = par("col.main"), 
                ...) mtext(main, side = 3, line = 3, cex = cex.main, 
                font = font.main, col = col.main, ...)
            panel <- match.fun(panel)
            nser <- NCOL(x)
            if (nser > 10) 
                stop("cannot plot more than 10 series as \"multiple\"")
            if (is.null(main)) 
                main <- xlabel
            nm <- colnames(x)
            if (is.null(nm)) 
                nm <- paste("Series", 1L:nser)
            if (missing(nc)) 
                nc <- if (nser > 4) 
                  2
                else 1
            nr <- ceiling(nser/nc)
            oldpar <- par(mar = mar.multi, oma = oma.multi, mfcol = c(nr, 
                nc))
            on.exit(par(oldpar))
            for (i in 1L:nser) {
                plot.default(x[, i], axes = FALSE, xlab = "", 
                  ylab = "", log = log, col = col, bg = bg, pch = pch, 
                  ann = ann, type = "n", ...)
                panel(x[, i], col = col, bg = bg, pch = pch, 
                  type = type, ...)
                if (frame.plot) 
                  box(...)
                y.side <- if (i%%2 || !yax.flip) 
                  2
                else 4
                do.xax <- i%%nr == 0 || i == nser
                if (axes) {
                  axis(y.side, xpd = NA, cex.axis = cex.axis, 
                    col.axis = col.axis, font.axis = font.axis)
                  if (do.xax) 
                    axis(1, xpd = NA, cex.axis = cex.axis, col.axis = col.axis, 
                      font.axis = font.axis)
                }
                if (ann) {
                  mtext(nm[i], y.side, line = 3, cex = cex.lab, 
                    col = col.lab, font = font.lab, ...)
                  if (do.xax) 
                    mtext(xlab, side = 1, line = 3, cex = cex.lab, 
                      col = col.lab, font = font.lab, ...)
                }
            }
            if (ann && !is.null(main)) {
                par(mfcol = c(1, 1))
                addmain(main, ...)
            }
            return(invisible())
        }
        x <- as.ts(x)
        if (!is.null(y)) {
            y <- hasTsp(y)
            if (NCOL(x) > 1 || NCOL(y) > 1) 
                stop("scatter plots only for univariate time series")
            if (is.ts(x) && is.ts(y)) {
                xy <- ts.intersect(x, y)
                xy <- xy.coords(xy[, 1], xy[, 2], xlabel, ylabel, 
                  log)
            }
            else xy <- xy.coords(x, y, xlabel, ylabel, log)
            xlab <- if (missing(xlab)) 
                xy$xlab
            else xlab
            ylab <- if (missing(ylab)) 
                xy$ylab
            else ylab
            xlim <- if (is.null(xlim)) 
                range(xy$x[is.finite(xy$x)])
            else xlim
            ylim <- if (is.null(ylim)) 
                range(xy$y[is.finite(xy$y)])
            else ylim
            n <- length(xy$x)
            if (missing(xy.labels)) 
                xy.labels <- (n <= 150)
            if (!is.logical(xy.labels)) {
                if (!is.character(xy.labels)) 
                  stop("'xy.labels' must be logical or character")
                do.lab <- TRUE
            }
            else do.lab <- xy.labels
            ptype <- if (do.lab) 
                "n"
            else if (missing(type)) 
                "p"
            else type
            plot.default(xy, type = ptype, xlab = xlab, ylab = ylab, 
                xlim = xlim, ylim = ylim, log = log, col = col, 
                bg = bg, pch = pch, axes = axes, frame.plot = frame.plot, 
                ann = ann, main = main, ...)
            if (missing(xy.lines)) 
                xy.lines <- do.lab
            if (do.lab) 
                text(xy, labels = if (is.character(xy.labels)) 
                  xy.labels
                else if (all(tsp(x) == tsp(y))) 
                  formatC(time(x), width = 1)
                else seq_along(xy$x), col = col, cex = cex)
            if (xy.lines) 
                lines(xy, col = col, lty = lty, lwd = lwd, type = if (do.lab) 
                  "c"
                else "l")
            return(invisible())
        }
        if (missing(ylab)) {
            ylab <- colnames(x)
            if (length(ylab) != 1L) 
                ylab <- xlabel
        }
        if (is.matrix(x)) {
            k <- ncol(x)
            tx <- time(x)
            xy <- xy.coords(x = matrix(rep.int(tx, k), ncol = k), 
                y = x, log = log)
            xy$x <- tx
        }
        else xy <- xy.coords(x, NULL, log = log)
        if (is.null(xlim)) 
            xlim <- range(xy$x)
        if (is.null(ylim)) 
            ylim <- range(xy$y[is.finite(xy$y)])
        plot.new()
        plot.window(xlim, ylim, log, ...)
        if (is.matrix(x)) {
            for (i in seq_len(k)) lines.default(xy$x, x[, i], 
                col = col[(i - 1L)%%length(col) + 1L], lty = lty[(i - 
                  1L)%%length(lty) + 1L], lwd = lwd[(i - 1L)%%length(lwd) + 
                  1L], bg = bg[(i - 1L)%%length(bg) + 1L], pch = pch[(i - 
                  1L)%%length(pch) + 1L], type = type)
        }
        else {
            lines.default(xy$x, x, col = col[1L], bg = bg, lty = lty[1L], 
                lwd = lwd[1L], pch = pch[1L], type = type)
        }
        if (ann) 
            title(main = main, xlab = xlab, ylab = ylab, ...)
        if (axes) {
            axis(1, ...)
            axis(2, ...)
        }
        if (frame.plot) 
            box(...)
    }
    xlabel <- if (!missing(x)) 
        deparse(substitute(x))
    ylabel <- if (!missing(y)) 
        deparse(substitute(y))
    plotts(x = x, y = y, plot.type = plot.type, xy.labels = xy.labels, 
        xy.lines = xy.lines, panel = panel, nc = nc, xlabel = xlabel, 
        ylabel = ylabel, axes = axes, ...)
}
<environment: namespace:stats>
> print("poisson.test"); if(is.function(try(poisson.test))) {poisson.test;} else{ NULL};
[1] "poisson.test"
function (x, T = 1, r = 1, alternative = c("two.sided", "less", 
    "greater"), conf.level = 0.95) 
{
    DNAME <- deparse(substitute(x))
    DNAME <- paste(DNAME, "time base:", deparse(substitute(T)))
    if ((l <- length(x)) != length(T)) 
        if (length(T) == 1L) 
            T <- rep(T, l)
        else stop("'x' and 'T' have incompatible length")
    xr <- round(x)
    if (any(!is.finite(x) | (x < 0)) || max(abs(x - xr)) > 1e-07) 
        stop("'x' must be finite, nonnegative, and integer")
    x <- xr
    if (any(is.na(T) | (T < 0))) 
        stop("'T' must be nonnegative")
    if ((k <- length(x)) < 1L) 
        stop("not enough data")
    if (k > 2L) 
        stop("The case k > 2 is unimplemented")
    if (!missing(r) && (length(r) > 1 || is.na(r) || r < 0)) 
        stop("'r' must be a single positive number")
    alternative <- match.arg(alternative)
    if (k == 2) {
        RVAL <- binom.test(x, sum(x), r * T[1L]/(r * T[1L] + 
            T[2L]), alternative = alternative, conf.level = conf.level)
        RVAL$data.name <- DNAME
        RVAL$statistic <- x[1L]
        RVAL$parameter <- sum(x) * r * T[1L]/sum(T * c(1, r))
        names(RVAL$statistic) <- c("count1")
        names(RVAL$parameter) <- c("expected count1")
        RVAL$estimate <- (x[1L]/T[1L])/(x[2L]/T[2L])
        names(RVAL$estimate) <- "rate ratio"
        pp <- RVAL$conf.int
        RVAL$conf.int <- pp/(1 - pp) * T[2L]/T[1L]
        names(r) <- "rate ratio"
        RVAL$null.value <- r
        RVAL$method <- "Comparison of Poisson rates"
        return(RVAL)
    }
    else {
        m <- r * T
        PVAL <- switch(alternative, less = ppois(x, m), greater = ppois(x - 
            1, m, lower.tail = FALSE), two.sided = {
            if (m == 0) (x == 0) else {
                relErr <- 1 + 1e-07
                d <- dpois(x, r * T)
                if (x == m) 1 else if (x < m) {
                  N <- ceiling(2 * m - x)
                  while (dpois(N, m) > d) N <- 2 * N
                  i <- seq.int(from = ceiling(m), to = N)
                  y <- sum(dpois(i, m) <= d * relErr)
                  ppois(x, m) + ppois(N - y, m, lower.tail = FALSE)
                } else {
                  i <- seq.int(from = 0, to = floor(m))
                  y <- sum(dpois(i, m) <= d * relErr)
                  ppois(y - 1, m) + ppois(x - 1, m, lower.tail = FALSE)
                }
            }
        })
        p.L <- function(x, alpha) {
            if (x == 0) 
                0
            else qgamma(alpha, x)
        }
        p.U <- function(x, alpha) qgamma(1 - alpha, x + 1)
        CINT <- switch(alternative, less = c(0, p.U(x, 1 - conf.level)), 
            greater = c(p.L(x, 1 - conf.level), Inf), two.sided = {
                alpha <- (1 - conf.level)/2
                c(p.L(x, alpha), p.U(x, alpha))
            })/T
        attr(CINT, "conf.level") <- conf.level
        ESTIMATE <- x/T
        names(x) <- "number of events"
        names(T) <- "time base"
        names(ESTIMATE) <- names(r) <- "event rate"
        structure(list(statistic = x, parameter = T, p.value = PVAL, 
            conf.int = CINT, estimate = ESTIMATE, null.value = r, 
            alternative = alternative, method = "Exact Poisson test", 
            data.name = DNAME), class = "htest")
    }
}
<environment: namespace:stats>
> print("poly"); if(is.function(try(poly))) {poly;} else{ NULL};
[1] "poly"
function (x, ..., degree = 1, coefs = NULL, raw = FALSE) 
{
    dots <- list(...)
    if (nd <- length(dots)) {
        if (nd == 1 && length(dots[[1L]]) == 1L) 
            degree <- dots[[1L]]
        else return(polym(x, ..., degree = degree, raw = raw))
    }
    if (is.matrix(x)) {
        m <- unclass(as.data.frame(cbind(x, ...)))
        return(do.call("polym", c(m, degree = degree, raw = raw)))
    }
    if (degree < 1) 
        stop("'degree' must be at least 1")
    if (any(is.na(x))) 
        stop("missing values are not allowed in 'poly'")
    n <- degree + 1
    if (raw) {
        if (degree >= length(unique(x))) 
            stop("'degree' must be less than number of unique points")
        Z <- outer(x, 1L:degree, "^")
        colnames(Z) <- 1L:degree
        attr(Z, "degree") <- 1L:degree
        class(Z) <- c("poly", "matrix")
        return(Z)
    }
    if (is.null(coefs)) {
        if (degree >= length(unique(x))) 
            stop("'degree' must be less than number of unique points")
        xbar <- mean(x)
        x <- x - xbar
        X <- outer(x, seq_len(n) - 1, "^")
        QR <- qr(X)
        if (QR$rank < degree) 
            stop("'degree' must be less than number of unique points")
        z <- QR$qr
        z <- z * (row(z) == col(z))
        raw <- qr.qy(QR, z)
        norm2 <- colSums(raw^2)
        alpha <- (colSums(x * raw^2)/norm2 + xbar)[1L:degree]
        Z <- raw/rep(sqrt(norm2), each = length(x))
        colnames(Z) <- 1L:n - 1L
        Z <- Z[, -1, drop = FALSE]
        attr(Z, "degree") <- 1L:degree
        attr(Z, "coefs") <- list(alpha = alpha, norm2 = c(1, 
            norm2))
        class(Z) <- c("poly", "matrix")
    }
    else {
        alpha <- coefs$alpha
        norm2 <- coefs$norm2
        Z <- matrix(, length(x), n)
        Z[, 1] <- 1
        Z[, 2] <- x - alpha[1L]
        if (degree > 1) 
            for (i in 2:degree) Z[, i + 1] <- (x - alpha[i]) * 
                Z[, i] - (norm2[i + 1]/norm2[i]) * Z[, i - 1]
        Z <- Z/rep(sqrt(norm2[-1L]), each = length(x))
        colnames(Z) <- 0:degree
        Z <- Z[, -1, drop = FALSE]
        attr(Z, "degree") <- 1L:degree
        attr(Z, "coefs") <- list(alpha = alpha, norm2 = norm2)
        class(Z) <- c("poly", "matrix")
    }
    Z
}
<environment: namespace:stats>
> print("power"); if(is.function(try(power))) {power;} else{ NULL};
[1] "power"
function (lambda = 1) 
{
    if (!is.numeric(lambda) || is.na(lambda)) 
        stop("invalid argument 'lambda'")
    if (lambda <= 0) 
        return(make.link("log"))
    if (lambda == 1) 
        return(make.link("identity"))
    linkfun <- function(mu) mu^lambda
    linkinv <- function(eta) pmax(eta^(1/lambda), .Machine$double.eps)
    mu.eta <- function(eta) pmax((1/lambda) * eta^(1/lambda - 
        1), .Machine$double.eps)
    valideta <- function(eta) all(eta > 0)
    link <- paste("mu^", round(lambda, 3), sep = "")
    structure(list(linkfun = linkfun, linkinv = linkinv, mu.eta = mu.eta, 
        valideta = valideta, name = link), class = "link-glm")
}
<environment: namespace:stats>
> print("power.anova.test"); if(is.function(try(power.anova.test))) {power.anova.test;} else{ NULL};
[1] "power.anova.test"
function (groups = NULL, n = NULL, between.var = NULL, within.var = NULL, 
    sig.level = 0.05, power = NULL) 
{
    if (sum(sapply(list(groups, n, between.var, within.var, power, 
        sig.level), is.null)) != 1) 
        stop("exactly one of 'groups', 'n', 'between.var', 'within.var', 'power', and 'sig.level' must be NULL")
    if (!is.null(groups) && groups < 2) 
        stop("number of groups must be at least 2")
    if (!is.null(n) && n < 2) 
        stop("number of observations in each group must be at least 2")
    if (!is.null(sig.level) && !is.numeric(sig.level) || any(0 > 
        sig.level | sig.level > 1)) 
        stop("'sig.level' must be numeric in [0, 1]")
    p.body <- quote({
        lambda <- (groups - 1) * n * (between.var/within.var)
        pf(qf(sig.level, groups - 1, (n - 1) * groups, lower.tail = FALSE), 
            groups - 1, (n - 1) * groups, lambda, lower.tail = FALSE)
    })
    if (is.null(power)) 
        power <- eval(p.body)
    else if (is.null(groups)) 
        groups <- uniroot(function(groups) eval(p.body) - power, 
            c(2, 100))$root
    else if (is.null(n)) 
        n <- uniroot(function(n) eval(p.body) - power, c(2, 1e+05))$root
    else if (is.null(within.var)) 
        within.var <- uniroot(function(within.var) eval(p.body) - 
            power, between.var * c(1e-07, 1e+07))$root
    else if (is.null(between.var)) 
        between.var <- uniroot(function(between.var) eval(p.body) - 
            power, within.var * c(1e-07, 1e+07))$root
    else if (is.null(sig.level)) 
        sig.level <- uniroot(function(sig.level) eval(p.body) - 
            power, c(1e-10, 1 - 1e-10))$root
    else stop("internal error")
    NOTE <- "n is number in each group"
    METHOD <- "Balanced one-way analysis of variance power calculation"
    structure(list(groups = groups, n = n, between.var = between.var, 
        within.var = within.var, sig.level = sig.level, power = power, 
        note = NOTE, method = METHOD), class = "power.htest")
}
<environment: namespace:stats>
> print("power.prop.test"); if(is.function(try(power.prop.test))) {power.prop.test;} else{ NULL};
[1] "power.prop.test"
function (n = NULL, p1 = NULL, p2 = NULL, sig.level = 0.05, power = NULL, 
    alternative = c("two.sided", "one.sided"), strict = FALSE) 
{
    if (sum(sapply(list(n, p1, p2, power, sig.level), is.null)) != 
        1) 
        stop("exactly one of 'n', 'p1', 'p2', 'power', and 'sig.level' must be NULL")
    if (!is.null(sig.level) && !is.numeric(sig.level) || any(0 > 
        sig.level | sig.level > 1)) 
        stop("'sig.level' must be numeric in [0, 1]")
    alternative <- match.arg(alternative)
    tside <- switch(alternative, one.sided = 1, two.sided = 2)
    p.body <- quote(pnorm(((sqrt(n) * abs(p1 - p2) - (qnorm(sig.level/tside, 
        lower.tail = FALSE) * sqrt((p1 + p2) * (1 - (p1 + p2)/2))))/sqrt(p1 * 
        (1 - p1) + p2 * (1 - p2)))))
    if (strict & tside == 2) 
        p.body <- quote({
            qu <- qnorm(sig.level/tside, lower.tail = FALSE)
            d <- abs(p1 - p2)
            q1 <- 1 - p1
            q2 <- 1 - p2
            pbar <- (p1 + p2)/2
            qbar <- 1 - pbar
            v1 <- p1 * q1
            v2 <- p2 * q2
            vbar <- pbar * qbar
            pnorm((sqrt(n) * d - qu * sqrt(2 * vbar))/sqrt(v1 + 
                v2)) + pnorm((sqrt(n) * d + qu * sqrt(2 * vbar))/sqrt(v1 + 
                v2), lower.tail = FALSE)
        })
    if (is.null(power)) 
        power <- eval(p.body)
    else if (is.null(n)) 
        n <- uniroot(function(n) eval(p.body) - power, c(1, 1e+07))$root
    else if (is.null(p1)) 
        p1 <- uniroot(function(p1) eval(p.body) - power, c(0, 
            p2))$root
    else if (is.null(p2)) 
        p2 <- uniroot(function(p2) eval(p.body) - power, c(p1, 
            1))$root
    else if (is.null(sig.level)) 
        sig.level <- uniroot(function(sig.level) eval(p.body) - 
            power, c(1e-10, 1 - 1e-10))$root
    else stop("internal error")
    NOTE <- "n is number in *each* group"
    METHOD <- "Two-sample comparison of proportions power calculation"
    structure(list(n = n, p1 = p1, p2 = p2, sig.level = sig.level, 
        power = power, alternative = alternative, note = NOTE, 
        method = METHOD), class = "power.htest")
}
<environment: namespace:stats>
> print("power.t.test"); if(is.function(try(power.t.test))) {power.t.test;} else{ NULL};
[1] "power.t.test"
function (n = NULL, delta = NULL, sd = 1, sig.level = 0.05, power = NULL, 
    type = c("two.sample", "one.sample", "paired"), alternative = c("two.sided", 
        "one.sided"), strict = FALSE) 
{
    if (sum(sapply(list(n, delta, sd, power, sig.level), is.null)) != 
        1) 
        stop("exactly one of 'n', 'delta', 'sd', 'power', and 'sig.level' must be NULL")
    if (!is.null(sig.level) && !is.numeric(sig.level) || any(0 > 
        sig.level | sig.level > 1)) 
        stop("'sig.level' must be numeric in [0, 1]")
    type <- match.arg(type)
    alternative <- match.arg(alternative)
    tsample <- switch(type, one.sample = 1, two.sample = 2, paired = 1)
    tside <- switch(alternative, one.sided = 1, two.sided = 2)
    if (tside == 2 && !is.null(delta)) 
        delta <- abs(delta)
    p.body <- quote({
        nu <- (n - 1) * tsample
        pt(qt(sig.level/tside, nu, lower.tail = FALSE), nu, ncp = sqrt(n/tsample) * 
            delta/sd, lower.tail = FALSE)
    })
    if (strict & tside == 2) 
        p.body <- quote({
            nu <- (n - 1) * tsample
            qu <- qt(sig.level/tside, nu, lower.tail = FALSE)
            pt(qu, nu, ncp = sqrt(n/tsample) * delta/sd, lower.tail = FALSE) + 
                pt(-qu, nu, ncp = sqrt(n/tsample) * delta/sd, 
                  lower.tail = TRUE)
        })
    if (is.null(power)) 
        power <- eval(p.body)
    else if (is.null(n)) 
        n <- uniroot(function(n) eval(p.body) - power, c(2, 1e+07))$root
    else if (is.null(sd)) 
        sd <- uniroot(function(sd) eval(p.body) - power, delta * 
            c(1e-07, 1e+07))$root
    else if (is.null(delta)) 
        delta <- uniroot(function(delta) eval(p.body) - power, 
            sd * c(1e-07, 1e+07))$root
    else if (is.null(sig.level)) 
        sig.level <- uniroot(function(sig.level) eval(p.body) - 
            power, c(1e-10, 1 - 1e-10))$root
    else stop("internal error")
    NOTE <- switch(type, paired = "n is number of *pairs*, sd is std.dev. of *differences* within pairs", 
        two.sample = "n is number in *each* group", NULL)
    METHOD <- paste(switch(type, one.sample = "One-sample", two.sample = "Two-sample", 
        paired = "Paired"), "t test power calculation")
    structure(list(n = n, delta = delta, sd = sd, sig.level = sig.level, 
        power = power, alternative = alternative, note = NOTE, 
        method = METHOD), class = "power.htest")
}
<environment: namespace:stats>
> print("ppoints"); if(is.function(try(ppoints))) {ppoints;} else{ NULL};
[1] "ppoints"
function (n, a = ifelse(n <= 10, 3/8, 1/2)) 
{
    if (length(n) > 1L) 
        n <- length(n)
    if (n > 0) 
        (1L:n - a)/(n + 1 - 2 * a)
    else numeric()
}
<environment: namespace:stats>
> print("ppr"); if(is.function(try(ppr))) {ppr;} else{ NULL};
[1] "ppr"
function (x, ...) 
UseMethod("ppr")
<environment: namespace:stats>
> print("prcomp"); if(is.function(try(prcomp))) {prcomp;} else{ NULL};
[1] "prcomp"
function (x, ...) 
UseMethod("prcomp")
<environment: namespace:stats>
> print("predict"); if(is.function(try(predict))) {predict;} else{ NULL};
[1] "predict"
function (object, ...) 
UseMethod("predict")
<environment: namespace:stats>
> print("predict.Arima"); if(is.function(try(predict.Arima))) {predict.Arima;} else{ NULL};
[1] "predict.Arima"
NULL
> print("predict.HoltWinters"); if(is.function(try(predict.HoltWinters))) {predict.HoltWinters;} else{ NULL};
[1] "predict.HoltWinters"
NULL
> print("predict.glm"); if(is.function(try(predict.glm))) {predict.glm;} else{ NULL};
[1] "predict.glm"
function (object, newdata = NULL, type = c("link", "response", 
    "terms"), se.fit = FALSE, dispersion = NULL, terms = NULL, 
    na.action = na.pass, ...) 
{
    type <- match.arg(type)
    na.act <- object$na.action
    object$na.action <- NULL
    if (!se.fit) {
        if (missing(newdata)) {
            pred <- switch(type, link = object$linear.predictors, 
                response = object$fitted.values, terms = predict.lm(object, 
                  se.fit = se.fit, scale = 1, type = "terms", 
                  terms = terms))
            if (!is.null(na.act)) 
                pred <- napredict(na.act, pred)
        }
        else {
            pred <- predict.lm(object, newdata, se.fit, scale = 1, 
                type = ifelse(type == "link", "response", type), 
                terms = terms, na.action = na.action)
            switch(type, response = {
                pred <- family(object)$linkinv(pred)
            }, link = , terms = )
        }
    }
    else {
        if (inherits(object, "survreg")) 
            dispersion <- 1
        if (is.null(dispersion) || dispersion == 0) 
            dispersion <- summary(object, dispersion = dispersion)$dispersion
        residual.scale <- as.vector(sqrt(dispersion))
        pred <- predict.lm(object, newdata, se.fit, scale = residual.scale, 
            type = ifelse(type == "link", "response", type), 
            terms = terms, na.action = na.action)
        fit <- pred$fit
        se.fit <- pred$se.fit
        switch(type, response = {
            se.fit <- se.fit * abs(family(object)$mu.eta(fit))
            fit <- family(object)$linkinv(fit)
        }, link = , terms = )
        if (missing(newdata) && !is.null(na.act)) {
            fit <- napredict(na.act, fit)
            se.fit <- napredict(na.act, se.fit)
        }
        pred <- list(fit = fit, se.fit = se.fit, residual.scale = residual.scale)
    }
    pred
}
<environment: namespace:stats>
> print("predict.lm"); if(is.function(try(predict.lm))) {predict.lm;} else{ NULL};
[1] "predict.lm"
function (object, newdata, se.fit = FALSE, scale = NULL, df = Inf, 
    interval = c("none", "confidence", "prediction"), level = 0.95, 
    type = c("response", "terms"), terms = NULL, na.action = na.pass, 
    pred.var = res.var/weights, weights = 1, ...) 
{
    tt <- terms(object)
    if (!inherits(object, "lm")) 
        warning("calling predict.lm(<fake-lm-object>) ...")
    if (missing(newdata) || is.null(newdata)) {
        mm <- X <- model.matrix(object)
        mmDone <- TRUE
        offset <- object$offset
    }
    else {
        Terms <- delete.response(tt)
        m <- model.frame(Terms, newdata, na.action = na.action, 
            xlev = object$xlevels)
        if (!is.null(cl <- attr(Terms, "dataClasses"))) 
            .checkMFClasses(cl, m)
        X <- model.matrix(Terms, m, contrasts.arg = object$contrasts)
        offset <- rep(0, nrow(X))
        if (!is.null(off.num <- attr(tt, "offset"))) 
            for (i in off.num) offset <- offset + eval(attr(tt, 
                "variables")[[i + 1]], newdata)
        if (!is.null(object$call$offset)) 
            offset <- offset + eval(object$call$offset, newdata)
        mmDone <- FALSE
    }
    n <- length(object$residuals)
    p <- object$rank
    p1 <- seq_len(p)
    piv <- if (p) 
        qr.lm(object)$pivot[p1]
    if (p < ncol(X) && !(missing(newdata) || is.null(newdata))) 
        warning("prediction from a rank-deficient fit may be misleading")
    beta <- object$coefficients
    predictor <- drop(X[, piv, drop = FALSE] %*% beta[piv])
    if (!is.null(offset)) 
        predictor <- predictor + offset
    interval <- match.arg(interval)
    if (interval == "prediction") {
        if (missing(newdata)) 
            warning("Predictions on current data refer to _future_ responses\n")
        if (missing(newdata) && missing(weights)) {
            w <- weights.default(object)
            if (!is.null(w)) {
                weights <- w
                warning("Assuming prediction variance inversely proportional to weights used for fitting\n")
            }
        }
        if (!missing(newdata) && missing(weights) && !is.null(object$weights) && 
            missing(pred.var)) 
            warning("Assuming constant prediction variance even though model fit is weighted\n")
        if (inherits(weights, "formula")) {
            if (length(weights) != 2L) 
                stop("'weights' as formula should be one-sided")
            d <- if (missing(newdata) || is.null(newdata)) 
                model.frame(object)
            else newdata
            weights <- eval(weights[[2L]], d, environment(weights))
        }
    }
    type <- match.arg(type)
    if (se.fit || interval != "none") {
        res.var <- if (is.null(scale)) {
            r <- object$residuals
            w <- object$weights
            rss <- sum(if (is.null(w)) r^2 else r^2 * w)
            df <- object$df.residual
            rss/df
        }
        else scale^2
        if (type != "terms") {
            if (p > 0) {
                XRinv <- if (missing(newdata) && is.null(w)) 
                  qr.Q(qr.lm(object))[, p1, drop = FALSE]
                else X[, piv] %*% qr.solve(qr.R(qr.lm(object))[p1, 
                  p1])
                ip <- drop(XRinv^2 %*% rep(res.var, p))
            }
            else ip <- rep(0, n)
        }
    }
    if (type == "terms") {
        if (!mmDone) {
            mm <- model.matrix(object)
            mmDone <- TRUE
        }
        aa <- attr(mm, "assign")
        ll <- attr(tt, "term.labels")
        hasintercept <- attr(tt, "intercept") > 0L
        if (hasintercept) 
            ll <- c("(Intercept)", ll)
        aaa <- factor(aa, labels = ll)
        asgn <- split(order(aa), aaa)
        if (hasintercept) {
            asgn$"(Intercept)" <- NULL
            if (!mmDone) {
                mm <- model.matrix(object)
                mmDone <- TRUE
            }
            avx <- colMeans(mm)
            termsconst <- sum(avx[piv] * beta[piv])
        }
        nterms <- length(asgn)
        if (nterms > 0) {
            predictor <- matrix(ncol = nterms, nrow = NROW(X))
            dimnames(predictor) <- list(rownames(X), names(asgn))
            if (se.fit || interval != "none") {
                ip <- matrix(ncol = nterms, nrow = NROW(X))
                dimnames(ip) <- list(rownames(X), names(asgn))
                Rinv <- qr.solve(qr.R(qr.lm(object))[p1, p1])
            }
            if (hasintercept) 
                X <- sweep(X, 2L, avx, check.margin = FALSE)
            unpiv <- rep.int(0L, NCOL(X))
            unpiv[piv] <- p1
            for (i in seq.int(1L, nterms, length.out = nterms)) {
                iipiv <- asgn[[i]]
                ii <- unpiv[iipiv]
                iipiv[ii == 0L] <- 0L
                predictor[, i] <- if (any(iipiv > 0L)) 
                  X[, iipiv, drop = FALSE] %*% beta[iipiv]
                else 0
                if (se.fit || interval != "none") 
                  ip[, i] <- if (any(iipiv > 0L)) 
                    as.matrix(X[, iipiv, drop = FALSE] %*% Rinv[ii, 
                      , drop = FALSE])^2 %*% rep.int(res.var, 
                      p)
                  else 0
            }
            if (!is.null(terms)) {
                predictor <- predictor[, terms, drop = FALSE]
                if (se.fit) 
                  ip <- ip[, terms, drop = FALSE]
            }
        }
        else {
            predictor <- ip <- matrix(0, n, 0L)
        }
        attr(predictor, "constant") <- if (hasintercept) 
            termsconst
        else 0
    }
    if (interval != "none") {
        tfrac <- qt((1 - level)/2, df)
        hwid <- tfrac * switch(interval, confidence = sqrt(ip), 
            prediction = sqrt(ip + pred.var))
        if (type != "terms") {
            predictor <- cbind(predictor, predictor + hwid %o% 
                c(1, -1))
            colnames(predictor) <- c("fit", "lwr", "upr")
        }
        else {
            if (!is.null(terms)) 
                hwid <- hwid[, terms, drop = FALSE]
            lwr <- predictor + hwid
            upr <- predictor - hwid
        }
    }
    if (se.fit || interval != "none") {
        se <- sqrt(ip)
        if (type == "terms" && !is.null(terms)) 
            se <- se[, terms, drop = FALSE]
    }
    if (missing(newdata) && !is.null(na.act <- object$na.action)) {
        predictor <- napredict(na.act, predictor)
        if (se.fit) 
            se <- napredict(na.act, se)
    }
    if (type == "terms" && interval != "none") {
        if (missing(newdata) && !is.null(na.act)) {
            lwr <- napredict(na.act, lwr)
            upr <- napredict(na.act, upr)
        }
        list(fit = predictor, se.fit = se, lwr = lwr, upr = upr, 
            df = df, residual.scale = sqrt(res.var))
    }
    else if (se.fit) 
        list(fit = predictor, se.fit = se, df = df, residual.scale = sqrt(res.var))
    else predictor
}
<environment: namespace:stats>
> print("predict.loess"); if(is.function(try(predict.loess))) {predict.loess;} else{ NULL};
[1] "predict.loess"
NULL
> print("predict.nls"); if(is.function(try(predict.nls))) {predict.nls;} else{ NULL};
[1] "predict.nls"
NULL
> print("predict.smooth.spline"); if(is.function(try(predict.smooth.spline))) {predict.smooth.spline;} else{ NULL};
[1] "predict.smooth.spline"
NULL
> print("preplot"); if(is.function(try(preplot))) {preplot;} else{ NULL};
[1] "preplot"
function (object, ...) 
UseMethod("preplot")
<environment: namespace:stats>
> print("princomp"); if(is.function(try(princomp))) {princomp;} else{ NULL};
[1] "princomp"
function (x, ...) 
UseMethod("princomp")
<environment: namespace:stats>
> print("print.power.htest"); if(is.function(try(print.power.htest))) {print.power.htest;} else{ NULL};
[1] "print.power.htest"
NULL
> print("print.ts"); if(is.function(try(print.ts))) {print.ts;} else{ NULL};
[1] "print.ts"
function (x, calendar, ...) 
{
    x.orig <- x
    x <- as.ts(x)
    fr.x <- frequency(x)
    if (missing(calendar)) 
        calendar <- any(fr.x == c(4, 12)) && length(start(x)) == 
            2L
    Tsp <- tsp(x)
    if (is.null(Tsp)) {
        warning("series is corrupt, with no 'tsp' attribute")
        print(unclass(x))
        return(invisible(x))
    }
    nn <- 1 + round((Tsp[2L] - Tsp[1L]) * Tsp[3L])
    if (NROW(x) != nn) {
        warning(gettextf("series is corrupt: length %d with 'tsp' implying %d", 
            NROW(x), nn), domain = NA, call. = FALSE)
        calendar <- FALSE
    }
    if (!calendar) 
        header <- function(x) {
            if ((fr.x <- frequency(x)) != 1) 
                cat("Time Series:\nStart =", deparse(start(x)), 
                  "\nEnd =", deparse(end(x)), "\nFrequency =", 
                  deparse(fr.x), "\n")
            else cat("Time Series:\nStart =", format(tsp(x)[1L]), 
                "\nEnd =", format(tsp(x)[2L]), "\nFrequency =", 
                deparse(fr.x), "\n")
        }
    if (NCOL(x) == 1) {
        if (calendar) {
            if (fr.x > 1) {
                dn2 <- if (fr.x == 12) 
                  month.abb
                else if (fr.x == 4) {
                  c("Qtr1", "Qtr2", "Qtr3", "Qtr4")
                }
                else paste("p", 1L:fr.x, sep = "")
                if (NROW(x) <= fr.x && start(x)[1L] == end(x)[1L]) {
                  dn1 <- start(x)[1L]
                  dn2 <- dn2[1 + (start(x)[2L] - 2 + seq_along(x))%%fr.x]
                  x <- matrix(format(x, ...), nrow = 1L, byrow = TRUE, 
                    dimnames = list(dn1, dn2))
                }
                else {
                  start.pad <- start(x)[2L] - 1
                  end.pad <- fr.x - end(x)[2L]
                  dn1 <- start(x)[1L]:end(x)[1L]
                  x <- matrix(c(rep.int("", start.pad), format(x, 
                    ...), rep.int("", end.pad)), ncol = fr.x, 
                    byrow = TRUE, dimnames = list(dn1, dn2))
                }
            }
            else {
                tx <- time(x)
                attributes(x) <- NULL
                names(x) <- tx
            }
        }
        else {
            header(x)
            attr(x, "class") <- attr(x, "tsp") <- attr(x, "na.action") <- NULL
        }
    }
    else {
        if (calendar && fr.x > 1) {
            tm <- time(x)
            t2 <- 1 + round(fr.x * ((tm + 0.001)%%1))
            p1 <- format(floor(zapsmall(tm)))
            rownames(x) <- if (fr.x == 12) 
                paste(month.abb[t2], p1, sep = " ")
            else paste(p1, if (fr.x == 4) 
                c("Q1", "Q2", "Q3", "Q4")[t2]
            else format(t2), sep = " ")
        }
        else {
            if (!calendar) 
                header(x)
            rownames(x) <- format(time(x))
        }
        attr(x, "class") <- attr(x, "tsp") <- attr(x, "na.action") <- NULL
    }
    NextMethod("print", x, quote = FALSE, right = TRUE, ...)
    invisible(x.orig)
}
<environment: namespace:stats>
> print("printCoefmat"); if(is.function(try(printCoefmat))) {printCoefmat;} else{ NULL};
[1] "printCoefmat"
function (x, digits = max(3, getOption("digits") - 2), signif.stars = getOption("show.signif.stars"), 
    signif.legend = signif.stars, dig.tst = max(1, min(5, digits - 
        1)), cs.ind = 1:k, tst.ind = k + 1, zap.ind = integer(0), 
    P.values = NULL, has.Pvalue = nc >= 4 && substr(colnames(x)[nc], 
        1, 3) == "Pr(", eps.Pvalue = .Machine$double.eps, na.print = "NA", 
    ...) 
{
    if (is.null(d <- dim(x)) || length(d) != 2L) 
        stop("'x' must be coefficient matrix/data frame")
    nc <- d[2L]
    if (is.null(P.values)) {
        scp <- getOption("show.coef.Pvalues")
        if (!is.logical(scp) || is.na(scp)) {
            warning("option \"show.coef.Pvalues\" is invalid: assuming TRUE")
            scp <- TRUE
        }
        P.values <- has.Pvalue && scp
    }
    else if (P.values && !has.Pvalue) 
        stop("'P.values' is TRUE, but 'has.Pvalue' is not")
    if (has.Pvalue && !P.values) {
        d <- dim(xm <- data.matrix(x[, -nc, drop = FALSE]))
        nc <- nc - 1
        has.Pvalue <- FALSE
    }
    else xm <- data.matrix(x)
    k <- nc - has.Pvalue - (if (missing(tst.ind)) 
        1
    else length(tst.ind))
    if (!missing(cs.ind) && length(cs.ind) > k) 
        stop("wrong k / cs.ind")
    Cf <- array("", dim = d, dimnames = dimnames(xm))
    ok <- !(ina <- is.na(xm))
    for (i in zap.ind) xm[, i] <- zapsmall(xm[, i], digits)
    if (length(cs.ind)) {
        acs <- abs(coef.se <- xm[, cs.ind, drop = FALSE])
        if (any(ia <- is.finite(acs))) {
            digmin <- 1 + if (length(acs <- acs[ia & acs != 0])) 
                floor(log10(range(acs[acs != 0], finite = TRUE)))
            else 0
            Cf[, cs.ind] <- format(round(coef.se, max(1, digits - 
                digmin)), digits = digits)
        }
    }
    if (length(tst.ind)) 
        Cf[, tst.ind] <- format(round(xm[, tst.ind], digits = dig.tst), 
            digits = digits)
    if (any(r.ind <- !((1L:nc) %in% c(cs.ind, tst.ind, if (has.Pvalue) nc)))) 
        for (i in which(r.ind)) Cf[, i] <- format(xm[, i], digits = digits)
    ok[, tst.ind] <- FALSE
    okP <- if (has.Pvalue) 
        ok[, -nc]
    else ok
    x1 <- Cf[okP]
    dec <- getOption("OutDec")
    if (dec != ".") 
        x1 <- chartr(dec, ".", x1)
    x0 <- (xm[okP] == 0) != (as.numeric(x1) == 0)
    if (length(not.both.0 <- which(x0 & !is.na(x0)))) {
        Cf[okP][not.both.0] <- format(xm[okP][not.both.0], digits = max(1, 
            digits - 1))
    }
    if (any(ina)) 
        Cf[ina] <- na.print
    if (P.values) {
        if (!is.logical(signif.stars) || is.na(signif.stars)) {
            warning("option \"show.signif.stars\" is invalid: assuming TRUE")
            signif.stars <- TRUE
        }
        if (any(okP <- ok[, nc])) {
            pv <- as.vector(xm[, nc])
            Cf[okP, nc] <- format.pval(pv[okP], digits = dig.tst, 
                eps = eps.Pvalue)
            signif.stars <- signif.stars && any(pv[okP] < 0.1)
            if (signif.stars) {
                Signif <- symnum(pv, corr = FALSE, na = FALSE, 
                  cutpoints = c(0, 0.001, 0.01, 0.05, 0.1, 1), 
                  symbols = c("***", "**", "*", ".", " "))
                Cf <- cbind(Cf, format(Signif))
            }
        }
        else signif.stars <- FALSE
    }
    else signif.stars <- FALSE
    print.default(Cf, quote = FALSE, right = TRUE, na.print = na.print, 
        ...)
    if (signif.stars && signif.legend) 
        cat("---\nSignif. codes: ", attr(Signif, "legend"), "\n")
    invisible(x)
}
<environment: namespace:stats>
> print("profile"); if(is.function(try(profile))) {profile;} else{ NULL};
[1] "profile"
function (fitted, ...) 
UseMethod("profile")
<environment: namespace:stats>
> print("profile.nls"); if(is.function(try(profile.nls))) {profile.nls;} else{ NULL};
[1] "profile.nls"
NULL
> print("proj"); if(is.function(try(proj))) {proj;} else{ NULL};
[1] "proj"
function (object, ...) 
UseMethod("proj")
<environment: namespace:stats>
> print("prop.test"); if(is.function(try(prop.test))) {prop.test;} else{ NULL};
[1] "prop.test"
function (x, n, p = NULL, alternative = c("two.sided", "less", 
    "greater"), conf.level = 0.95, correct = TRUE) 
{
    DNAME <- deparse(substitute(x))
    if (is.table(x) && length(dim(x)) == 1L) {
        if (dim(x) != 2L) 
            stop("table 'x' should have 2 entries")
        l <- 1
        n <- sum(x)
        x <- x[1L]
    }
    else if (is.matrix(x)) {
        if (ncol(x) != 2L) 
            stop("'x' must have 2 columns")
        l <- nrow(x)
        n <- rowSums(x)
        x <- x[, 1L]
    }
    else {
        DNAME <- paste(DNAME, "out of", deparse(substitute(n)))
        if ((l <- length(x)) != length(n)) 
            stop("'x' and 'n' must have the same length")
    }
    OK <- complete.cases(x, n)
    x <- x[OK]
    n <- n[OK]
    if ((k <- length(x)) < 1L) 
        stop("not enough data")
    if (any(n <= 0)) 
        stop("elements of 'n' must be positive")
    if (any(x < 0)) 
        stop("elements of 'x' must be nonnegative")
    if (any(x > n)) 
        stop("elements of 'x' must not be greater than those of 'n'")
    if (is.null(p) && (k == 1)) 
        p <- 0.5
    if (!is.null(p)) {
        DNAME <- paste(DNAME, ", null ", ifelse(k == 1, "probability ", 
            "probabilities "), deparse(substitute(p)), sep = "")
        if (length(p) != l) 
            stop("'p' must have the same length as 'x' and 'n'")
        p <- p[OK]
        if (any((p <= 0) | (p >= 1))) 
            stop("elements of 'p' must be in (0,1)")
    }
    alternative <- match.arg(alternative)
    if (k > 2 || (k == 2) && !is.null(p)) 
        alternative <- "two.sided"
    if ((length(conf.level) != 1L) || is.na(conf.level) || (conf.level <= 
        0) || (conf.level >= 1)) 
        stop("'conf.level' must be a single number between 0 and 1")
    correct <- as.logical(correct)
    ESTIMATE <- x/n
    names(ESTIMATE) <- if (k == 1) 
        "p"
    else paste("prop", 1L:l)[OK]
    NVAL <- p
    CINT <- NULL
    YATES <- ifelse(correct && (k <= 2), 0.5, 0)
    if (k == 1) {
        z <- ifelse(alternative == "two.sided", qnorm((1 + conf.level)/2), 
            qnorm(conf.level))
        YATES <- min(YATES, abs(x - n * p))
        z22n <- z^2/(2 * n)
        p.c <- ESTIMATE + YATES/n
        p.u <- if (p.c >= 1) 
            1
        else (p.c + z22n + z * sqrt(p.c * (1 - p.c)/n + z22n/(2 * 
            n)))/(1 + 2 * z22n)
        p.c <- ESTIMATE - YATES/n
        p.l <- if (p.c <= 0) 
            0
        else (p.c + z22n - z * sqrt(p.c * (1 - p.c)/n + z22n/(2 * 
            n)))/(1 + 2 * z22n)
        CINT <- switch(alternative, two.sided = c(max(p.l, 0), 
            min(p.u, 1)), greater = c(max(p.l, 0), 1), less = c(0, 
            min(p.u, 1)))
    }
    else if ((k == 2) & is.null(p)) {
        DELTA <- ESTIMATE[1L] - ESTIMATE[2L]
        YATES <- min(YATES, abs(DELTA)/sum(1/n))
        WIDTH <- (switch(alternative, two.sided = qnorm((1 + 
            conf.level)/2), qnorm(conf.level)) * sqrt(sum(ESTIMATE * 
            (1 - ESTIMATE)/n)) + YATES * sum(1/n))
        CINT <- switch(alternative, two.sided = c(max(DELTA - 
            WIDTH, -1), min(DELTA + WIDTH, 1)), greater = c(max(DELTA - 
            WIDTH, -1), 1), less = c(-1, min(DELTA + WIDTH, 1)))
    }
    if (!is.null(CINT)) 
        attr(CINT, "conf.level") <- conf.level
    METHOD <- paste(ifelse(k == 1, "1-sample proportions test", 
        paste(k, "-sample test for ", ifelse(is.null(p), "equality of", 
            "given"), " proportions", sep = "")), ifelse(YATES, 
        "with", "without"), "continuity correction")
    if (is.null(p)) {
        p <- sum(x)/sum(n)
        PARAMETER <- k - 1
    }
    else {
        PARAMETER <- k
        names(NVAL) <- names(ESTIMATE)
    }
    names(PARAMETER) <- "df"
    x <- cbind(x, n - x)
    E <- cbind(n * p, n * (1 - p))
    if (any(E < 5)) 
        warning("Chi-squared approximation may be incorrect")
    STATISTIC <- sum((abs(x - E) - YATES)^2/E)
    names(STATISTIC) <- "X-squared"
    if (alternative == "two.sided") 
        PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
    else {
        if (k == 1) 
            z <- sign(ESTIMATE - p) * sqrt(STATISTIC)
        else z <- sign(DELTA) * sqrt(STATISTIC)
        PVAL <- pnorm(z, lower.tail = (alternative == "less"))
    }
    RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, 
        p.value = as.numeric(PVAL), estimate = ESTIMATE, null.value = NVAL, 
        conf.int = CINT, alternative = alternative, method = METHOD, 
        data.name = DNAME)
    class(RVAL) <- "htest"
    return(RVAL)
}
<environment: namespace:stats>
> print("prop.trend.test"); if(is.function(try(prop.trend.test))) {prop.trend.test;} else{ NULL};
[1] "prop.trend.test"
function (x, n, score = seq_along(x)) 
{
    method <- "Chi-squared Test for Trend in Proportions"
    dname <- paste(deparse(substitute(x)), "out of", deparse(substitute(n)))
    dname <- paste(dname, ",\n using scores:", paste(score, collapse = " "))
    x <- as.vector(x)
    n <- as.vector(n)
    score <- as.vector(score)
    freq <- x/n
    p <- sum(x)/sum(n)
    w <- n/p/(1 - p)
    a <- anova(lm(freq ~ score, weights = w))
    chisq <- a["score", "Sum Sq"]
    names(chisq) <- "X-squared"
    df <- c(df = 1)
    pval <- pchisq(chisq, 1, lower.tail = FALSE)
    rval <- list(statistic = chisq, parameter = df, p.value = as.numeric(pval), 
        method = method, data.name = dname)
    class(rval) <- "htest"
    return(rval)
}
<environment: namespace:stats>
> print("qbirthday"); if(is.function(try(qbirthday))) {qbirthday;} else{ NULL};
[1] "qbirthday"
function (prob = 0.5, classes = 365, coincident = 2) 
{
    k <- coincident
    c <- classes
    p <- prob
    if (p <= 0) 
        return(1)
    if (p >= 1) 
        return(c * (k - 1) + 1)
    N <- exp(((k - 1) * log(c) + lgamma(k + 1) + log(-log1p(-p)))/k)
    N <- ceiling(N)
    if (pbirthday(N, c, k) < prob) {
        N <- N + 1
        while (pbirthday(N, c, k) < prob) N <- N + 1
    }
    else if (pbirthday(N - 1, c, k) >= prob) {
        N <- N - 1
        while (pbirthday(N - 1, c, k) >= prob) N <- N - 1
    }
    N
}
<environment: namespace:stats>
> print("qqnorm"); if(is.function(try(qqnorm))) {qqnorm;} else{ NULL};
[1] "qqnorm"
function (y, ...) 
UseMethod("qqnorm")
<environment: namespace:stats>
> print("quade.test"); if(is.function(try(quade.test))) {quade.test;} else{ NULL};
[1] "quade.test"
function (y, ...) 
UseMethod("quade.test")
<environment: namespace:stats>
> print("quantile"); if(is.function(try(quantile))) {quantile;} else{ NULL};
[1] "quantile"
function (x, ...) 
UseMethod("quantile")
<environment: namespace:stats>
> print("r2dtable"); if(is.function(try(r2dtable))) {r2dtable;} else{ NULL};
[1] "r2dtable"
function (n, r, c) 
{
    if (length(n) == 0L || (n < 0) || is.na(n)) 
        stop("invalid argument 'n'")
    if ((length(r) <= 1L) || any(r < 0) || any(is.na(r))) 
        stop("invalid argument 'r'")
    if ((length(c) <= 1L) || any(c < 0) || any(is.na(c))) 
        stop("invalid argument 'c'")
    if (sum(r) != sum(c)) 
        stop("arguments 'r' and 'c' must have the same sums")
    .Call("R_r2dtable", as.integer(n), as.integer(r), as.integer(c), 
        PACKAGE = "base")
}
<environment: namespace:stats>
> print("read.ftable"); if(is.function(try(read.ftable))) {read.ftable;} else{ NULL};
[1] "read.ftable"
function (file, sep = "", quote = "\"", row.var.names, col.vars, 
    skip = 0) 
{
    if (is.character(file)) {
        file <- file(file, "r")
        on.exit(close(file))
    }
    if (!inherits(file, "connection")) 
        stop("'file' must be a character string or connection")
    if (!isSeekable(file)) {
        tmpf <- tempfile()
        cat(readLines(file), file = tmpf, sep = "\n")
        file <- file(tmpf, "r")
        on.exit({
            close(file)
            unlink(tmpf)
        }, add = TRUE)
    }
    z <- utils::count.fields(file, sep, quote, skip)
    n.row.vars <- z[max(which(z == max(z)))] - z[length(z)] + 
        1
    seek(file, where = 0)
    if (skip > 0) 
        readLines(file, skip)
    lines <- readLines(file)
    seek(file, where = 0)
    if (skip > 0) 
        readLines(file, skip)
    i <- which(z == n.row.vars)
    j <- i[grep("^[^[:space:]]", lines[i])]
    if ((length(j) == 1L) && (j > 1)) {
        n.col.vars <- j - 1
        col.vars <- vector("list", length = n.col.vars)
        n <- c(1, z[1:n.col.vars] - 1)
        for (k in seq.int(from = 1, to = n.col.vars)) {
            s <- scan(file, what = "", sep = sep, quote = quote, 
                nlines = 1, quiet = TRUE)
            col.vars[[k]] <- s[-1L]
            names(col.vars)[k] <- s[1L]
        }
        row.vars <- vector("list", length = n.row.vars)
        names(row.vars) <- scan(file, what = "", sep = sep, quote = quote, 
            nlines = 1, quiet = TRUE)
        z <- z[-(1:(n.col.vars + 1))]
    }
    else {
        if ((z[1L] == 1) && z[2L] == max(z)) {
            n.col.vars <- 1
            col.vars <- vector("list", length = n.col.vars)
            s <- scan(file, what = "", sep = sep, quote = quote, 
                nlines = 2, quiet = TRUE)
            names(col.vars) <- s[1L]
            s <- s[-1L]
            row.vars <- vector("list", length = n.row.vars)
            i <- 1:n.row.vars
            names(row.vars) <- s[i]
            col.vars[[1L]] <- s[-i]
            z <- z[-(1:2)]
        }
        else {
            if (missing(row.var.names)) {
                stop("'row.var.names' missing")
            }
            n.row.vars <- length(row.var.names)
            row.vars <- vector("list", length = n.row.vars)
            names(row.vars) <- as.character(row.var.names)
            if (missing(col.vars) || !is.list(col.vars)) {
                stop("'col.vars' missing or incorrect")
            }
            col.vars <- lapply(col.vars, as.character)
            n.col.vars <- length(col.vars)
            if (is.null(names(col.vars))) 
                names(col.vars) <- paste("Factor", seq_along(col.vars), 
                  sep = ".")
            else {
                nam <- names(col.vars)
                ind <- which(!nzchar(nam))
                names(col.vars)[ind] <- paste("Factor", ind, 
                  sep = ".")
            }
        }
    }
    p <- 1
    n <- integer(n.row.vars)
    for (k in seq.int(from = 1, to = n.row.vars)) {
        n[k] <- sum(z >= max(z) - k + 1)/p
        p <- p * n[k]
    }
    is.row.lab <- rep(rep(c(TRUE, FALSE), length(z)), c(rbind(z - 
        min(z) + 1, min(z) - 1)))
    s <- scan(file, what = "", sep = sep, quote = quote, quiet = TRUE)
    values <- as.numeric(s[!is.row.lab])
    tmp <- s[is.row.lab]
    len <- length(tmp)
    for (k in seq.int(from = 1, to = n.row.vars)) {
        i <- seq.int(from = 1, to = len, by = len/n[k])
        row.vars[[k]] <- unique(tmp[i])
        tmp <- tmp[seq.int(from = 2, to = len/n[k])]
        len <- length(tmp)
    }
    values <- matrix(values, nrow = prod(sapply(row.vars, length)), 
        ncol = prod(sapply(col.vars, length)), byrow = TRUE)
    structure(values, row.vars = row.vars, col.vars = col.vars, 
        class = "ftable")
}
<environment: namespace:stats>
> print("rect.hclust"); if(is.function(try(rect.hclust))) {rect.hclust;} else{ NULL};
[1] "rect.hclust"
function (tree, k = NULL, which = NULL, x = NULL, h = NULL, border = 2, 
    cluster = NULL) 
{
    if (length(h) > 1L | length(k) > 1L) 
        stop("'k' and 'h' must be a scalar")
    if (!is.null(h)) {
        if (!is.null(k)) 
            stop("specify exactly one of 'k' and 'h'")
        k <- min(which(rev(tree$height) < h))
        k <- max(k, 2)
    }
    else if (is.null(k)) 
        stop("specify exactly one of 'k' and 'h'")
    if (k < 2 | k > length(tree$height)) 
        stop(gettextf("k must be between 2 and %d", length(tree$height)), 
            domain = NA)
    if (is.null(cluster)) 
        cluster <- cutree(tree, k = k)
    clustab <- table(cluster)[unique(cluster[tree$order])]
    m <- c(0, cumsum(clustab))
    if (!is.null(x)) {
        if (!is.null(which)) 
            stop("specify exactly one of 'which' and 'x'")
        which <- x
        for (n in seq_along(x)) which[n] <- max(which(m < x[n]))
    }
    else if (is.null(which)) 
        which <- 1L:k
    if (any(which > k)) 
        stop(gettextf("all elements of 'which' must be between 1 and %d", 
            k), domain = NA)
    border <- rep(border, length.out = length(which))
    retval <- list()
    for (n in seq_along(which)) {
        rect(m[which[n]] + 0.66, par("usr")[3L], m[which[n] + 
            1] + 0.33, mean(rev(tree$height)[(k - 1):k]), border = border[n])
        retval[[n]] <- which(cluster == as.integer(names(clustab)[which[n]]))
    }
    invisible(retval)
}
<environment: namespace:stats>
> print("relevel"); if(is.function(try(relevel))) {relevel;} else{ NULL};
[1] "relevel"
function (x, ref, ...) 
UseMethod("relevel")
<environment: namespace:stats>
> print("reorder.default"); if(is.function(try(reorder.default))) {reorder.default;} else{ NULL};
[1] "reorder.default"
NULL
> print("reorder.dendrogram"); if(is.function(try(reorder.dendrogram))) {reorder.dendrogram;} else{ NULL};
[1] "reorder.dendrogram"
NULL
> print("replications"); if(is.function(try(replications))) {replications;} else{ NULL};
[1] "replications"
function (formula, data = NULL, na.action) 
{
    if (missing(data) && inherits(formula, "data.frame")) {
        data <- formula
        formula <- ~.
    }
    if (!inherits(formula, "terms")) {
        formula <- as.formula(formula)
        if (length(formula) < 3L) {
            f <- y ~ x
            f[[3L]] <- formula[[2L]]
            formula <- f
        }
        formula <- terms(formula, data = data)
    }
    if (missing(na.action)) 
        if (!is.null(tj <- attr(data, "na.action")) && is.function(tj)) 
            na.action <- tj
        else {
            naa <- getOption("na.action")
            if (!is.null(naa)) 
                na.action <- match.fun(naa)
            else na.action <- na.fail
        }
    f <- attr(formula, "factors")
    o <- attr(formula, "order")
    labels <- attr(formula, "term.labels")
    vars <- as.character(attr(formula, "variables"))[-1L]
    if (is.null(data)) {
        v <- c(as.name("data.frame"), attr(formula, "variables"))
        data <- eval(as.call(v), parent.frame())
    }
    if (!is.function(na.action)) 
        stop("na.action must be a function")
    data <- na.action(data)
    class(data) <- NULL
    n <- length(o)
    z <- vector("list", n)
    names(z) <- labels
    dummy <- numeric(.row_names_info(data, 2L))
    notfactor <- !sapply(data, function(x) inherits(x, "factor"))
    balance <- TRUE
    for (i in seq_len(n)) {
        l <- labels[i]
        if (o[i] < 1 || substring(l, 1L, 5L) == "Error") {
            z[[l]] <- NULL
            next
        }
        select <- vars[f[, i] > 0]
        if (any(nn <- notfactor[select])) {
            warning("non-factors ignored: ", paste(names(nn), 
                collapse = ", "))
            next
        }
        if (length(select)) 
            tble <- tapply(dummy, unclass(data[select]), length)
        nrep <- unique(as.vector(tble))
        if (length(nrep) > 1L) {
            balance <- FALSE
            tble[is.na(tble)] <- 0
            z[[l]] <- tble
        }
        else z[[l]] <- as.vector(nrep)
    }
    if (balance) 
        unlist(z)
    else z
}
<environment: namespace:stats>
> print("reshape"); if(is.function(try(reshape))) {reshape;} else{ NULL};
[1] "reshape"
function (data, varying = NULL, v.names = NULL, timevar = "time", 
    idvar = "id", ids = 1L:NROW(data), times = seq_along(varying[[1L]]), 
    drop = NULL, direction, new.row.names = NULL, sep = ".", 
    split = if (sep == "") {
        list(regexp = "[A-Za-z][0-9]", include = TRUE)
    } else {
        list(regexp = sep, include = FALSE, fixed = TRUE)
    }) 
{
    if (!is.character(sep) || length(sep) != 1L) 
        stop("'sep' must be a character string")
    ix2names <- function(ix) if (is.character(ix)) 
        ix
    else names(data)[ix]
    guess <- function(nms, re = split$regexp, drop = !split$include, 
        fixed = if (is.null(split$fixed)) 
            FALSE
        else split$fixed) {
        if (drop) 
            nn <- do.call("rbind", strsplit(nms, re, fixed = fixed))
        else nn <- cbind(substr(nms, 1L, regexpr(re, nms)), substr(nms, 
            regexpr(re, nms) + 1L, 10000L))
        if (ncol(nn) != 2) 
            stop("Failed to guess time-varying variables from their names")
        vn <- unique(nn[, 1])
        v.names <- split(nms, factor(nn[, 1], levels = vn))
        times <- unique(nn[, 2])
        attr(v.names, "v.names") <- vn
        tt <- tryCatch(as.numeric(times), warning = function(w) times)
        attr(v.names, "times") <- tt
        v.names
    }
    reshapeLong <- function(data, varying, v.names = NULL, timevar, 
        idvar, ids = 1L:NROW(data), times, drop = NULL, new.row.names = NULL) {
        ll <- unlist(lapply(varying, length))
        if (any(ll != ll[1L])) 
            stop("'varying' arguments must be the same length")
        if (ll[1L] != length(times)) 
            stop("'times' is wrong length")
        if (!is.null(drop)) {
            if (is.character(drop)) 
                drop <- names(data) %in% drop
            data <- data[, if (is.logical(drop)) 
                !drop
            else -drop, drop = FALSE]
        }
        undoInfo <- list(varying = varying, v.names = v.names, 
            idvar = idvar, timevar = timevar)
        if (length(idvar) > 1L) {
            repeat ({
                tempidname <- basename(tempfile("tempID"))
                if (!(tempidname %in% names(data))) 
                  break
            })
            data[, tempidname] <- interaction(data[, idvar], 
                drop = TRUE)
            idvar <- tempidname
            drop.idvar <- TRUE
        }
        else drop.idvar <- FALSE
        d <- data
        all.varying <- unlist(varying)
        d <- d[, !(names(data) %in% all.varying), drop = FALSE]
        d[, timevar] <- times[1L]
        if (is.null(v.names)) 
            v.names <- unlist(lapply(varying, function(x) x[1L]))
        for (i in seq_along(v.names)) d[, v.names[i]] <- data[, 
            varying[[i]][1L]]
        if (!(idvar %in% names(data))) 
            d[, idvar] <- ids
        rval <- d
        if (length(times) == 1L) {
            if (drop.idvar) 
                rval[, idvar] <- NULL
            return(rval)
        }
        if (is.null(new.row.names)) 
            row.names(rval) <- paste(d[, idvar], times[1L], sep = ".")
        else row.names(rval) <- new.row.names[1L:NROW(rval)]
        for (i in 2:length(times)) {
            d[, timevar] <- times[i]
            for (j in seq_along(v.names)) d[, v.names[j]] <- data[, 
                varying[[j]][i]]
            if (is.null(new.row.names)) 
                row.names(d) <- paste(d[, idvar], times[i], sep = ".")
            else row.names(d) <- new.row.names[NROW(rval) + 1L:NROW(d)]
            rval <- rbind(rval, d)
        }
        if (drop.idvar) 
            rval[, idvar] <- NULL
        attr(rval, "reshapeLong") <- undoInfo
        return(rval)
    }
    reshapeWide <- function(data, timevar, idvar, varying = NULL, 
        v.names = NULL, drop = NULL, new.row.names = NULL) {
        if (!is.null(drop)) {
            if (is.character(drop)) 
                drop <- names(data) %in% drop
            data <- data[, if (is.logical(drop)) 
                !drop
            else -drop, drop = FALSE]
        }
        undoInfo <- list(v.names = v.names, timevar = timevar, 
            idvar = idvar)
        orig.idvar <- idvar
        if (length(idvar) > 1L) {
            repeat ({
                tempidname <- basename(tempfile("tempID"))
                if (!(tempidname %in% names(data))) 
                  break
            })
            data[, tempidname] <- interaction(data[, idvar], 
                drop = TRUE)
            idvar <- tempidname
            drop.idvar <- TRUE
        }
        else drop.idvar <- FALSE
        times <- unique(data[, timevar])
        if (any(is.na(times))) 
            warning("there are records with missing times, which will be dropped.")
        undoInfo$times <- times
        if (is.null(v.names)) 
            v.names <- names(data)[!(names(data) %in% c(timevar, 
                idvar, orig.idvar))]
        if (is.null(varying)) 
            varying <- outer(v.names, times, paste, sep = sep)
        if (is.list(varying)) 
            varying <- do.call("rbind", varying)
        undoInfo$varying <- varying
        CHECK <- TRUE
        if (CHECK) {
            keep <- !(names(data) %in% c(timevar, v.names, idvar, 
                orig.idvar))
            if (any(keep)) {
                rval <- data[keep]
                tmp <- data[, idvar]
                really.constant <- unlist(lapply(rval, function(a) all(tapply(a, 
                  as.vector(tmp), function(b) length(unique(b)) == 
                    1L))))
                if (!all(really.constant)) 
                  warning(gettextf("some constant variables (%s) are really varying", 
                    paste(names(rval)[!really.constant], collapse = ",")), 
                    domain = NA)
            }
        }
        rval <- data[!duplicated(data[, idvar]), !(names(data) %in% 
            c(timevar, v.names)), drop = FALSE]
        for (i in seq_along(times)) {
            thistime <- data[data[, timevar] %in% times[i], ]
            rval[, varying[, i]] <- thistime[match(rval[, idvar], 
                thistime[, idvar]), v.names]
        }
        if (!is.null(new.row.names)) 
            row.names(rval) <- new.row.names
        if (drop.idvar) 
            rval[, idvar] <- NULL
        attr(rval, "reshapeWide") <- undoInfo
        rval
    }
    if (missing(direction)) {
        undo <- c("wide", "long")[c("reshapeLong", "reshapeWide") %in% 
            names(attributes(data))]
        if (length(undo) == 1L) 
            direction <- undo
    }
    direction <- match.arg(direction, c("wide", "long"))
    switch(direction, wide = {
        back <- attr(data, "reshapeLong")
        if (missing(timevar) && missing(idvar) && !is.null(back)) {
            reshapeWide(data, idvar = back$idvar, timevar = back$timevar, 
                varying = back$varying, v.names = back$v.names, 
                new.row.names = new.row.names)
        } else {
            reshapeWide(data, idvar = idvar, timevar = timevar, 
                varying = varying, v.names = v.names, drop = drop, 
                new.row.names = new.row.names)
        }
    }, long = {
        if (missing(varying)) {
            back <- attr(data, "reshapeWide")
            if (is.null(back)) stop("no 'reshapeWide' attribute, must specify 'varying'")
            varying <- back$varying
            idvar <- back$idvar
            timevar <- back$timevar
            v.names <- back$v.names
            times <- back$times
        }
        if (is.matrix(varying)) varying <- split(varying, row(varying))
        if (is.null(varying)) stop("'varying' must be nonempty list or vector")
        if (is.atomic(varying)) {
            varying <- ix2names(varying)
            if (missing(v.names)) varying <- guess(varying) else {
                if (length(varying)%%length(v.names)) stop("length of v.names does not evenly divide length of varying")
                ntimes <- length(varying)%/%length(v.names)
                if (missing(times)) times <- seq_len(ntimes) else if (length(times) != 
                  ntimes) stop("length of varying must be the product of length of v.names and length of times")
                varying <- split(varying, rep(v.names, ntimes))
                attr(varying, "v.names") <- v.names
                attr(varying, "times") <- times
            }
        } else varying <- lapply(varying, ix2names)
        if (missing(v.names) && !is.null(attr(varying, "v.names"))) {
            v.names <- attr(varying, "v.names")
            times <- attr(varying, "times")
        }
        reshapeLong(data, idvar = idvar, timevar = timevar, varying = varying, 
            v.names = v.names, drop = drop, times = times, ids = ids, 
            new.row.names = new.row.names)
    })
}
<environment: namespace:stats>
> print("residuals"); if(is.function(try(residuals))) {residuals;} else{ NULL};
[1] "residuals"
function (object, ...) 
UseMethod("residuals")
<environment: namespace:stats>
> print("runmed"); if(is.function(try(runmed))) {runmed;} else{ NULL};
[1] "runmed"
function (x, k, endrule = c("median", "keep", "constant"), algorithm = NULL, 
    print.level = 0) 
{
    n <- length(x)
    k <- as.integer(k)
    if (k < 0) 
        stop("'k' must be positive")
    if (k%%2 == 0) 
        warning("'k' must be odd!  Changing 'k' to ", k <- as.integer(1 + 
            2 * (k%/%2)))
    if (n == 0) {
        x <- double()
        attr(x, "k") <- k
        return(x)
    }
    if (k > n) 
        warning("'k' is bigger than 'n'!  Changing 'k' to ", 
            k <- as.integer(1 + 2 * ((n - 1)%/%2)))
    algorithm <- if (missing(algorithm)) {
        if (k < 20 || n < 300) 
            "Stuetzle"
        else "Turlach"
    }
    else {
        match.arg(algorithm, c("Stuetzle", "Turlach"))
    }
    endrule <- match.arg(endrule)
    iend <- switch(endrule, median = , keep = 0, constant = 1)
    if (print.level) 
        cat("runmed(*, endrule=", endrule, ", algorithm=", algorithm, 
            ", iend=", iend, ")\n")
    res <- switch(algorithm, Turlach = {
        .C(R_Trunmed, n, k, as.double(x), rmed = double(n), tmp1 = integer(k + 
            1), tmp2 = integer(2 * k + 1), tmp3 = double(2 * 
            k + 1), as.integer(iend), as.integer(print.level), 
            DUP = FALSE)$rmed
    }, Stuetzle = {
        .C(R_Srunmed, as.double(x), smo = double(n), n, k, as.integer(iend), 
            debug = (print.level > 0), DUP = FALSE)$smo
    })
    if (endrule == "median") 
        res <- smoothEnds(res, k = k)
    attr(res, "k") <- k
    res
}
<environment: namespace:stats>
> print("scatter.smooth"); if(is.function(try(scatter.smooth))) {scatter.smooth;} else{ NULL};
[1] "scatter.smooth"
function (x, y = NULL, span = 2/3, degree = 1, family = c("symmetric", 
    "gaussian"), xlab = NULL, ylab = NULL, ylim = range(y, prediction$y, 
    na.rm = TRUE), evaluation = 50, ...) 
{
    xlabel <- if (!missing(x)) 
        deparse(substitute(x))
    ylabel <- if (!missing(y)) 
        deparse(substitute(y))
    xy <- xy.coords(x, y, xlabel, ylabel)
    x <- xy$x
    y <- xy$y
    xlab <- if (is.null(xlab)) 
        xy$xlab
    else xlab
    ylab <- if (is.null(ylab)) 
        xy$ylab
    else ylab
    prediction <- loess.smooth(x, y, span, degree, family, evaluation)
    plot(x, y, ylim = ylim, xlab = xlab, ylab = ylab, ...)
    lines(prediction)
    invisible()
}
<environment: namespace:stats>
> print("screeplot"); if(is.function(try(screeplot))) {screeplot;} else{ NULL};
[1] "screeplot"
function (x, ...) 
UseMethod("screeplot")
<environment: namespace:stats>
> print("sd"); if(is.function(try(sd))) {sd;} else{ NULL};
[1] "sd"
function (x, na.rm = FALSE) 
{
    if (is.matrix(x)) 
        apply(x, 2, sd, na.rm = na.rm)
    else if (is.vector(x)) 
        sqrt(var(x, na.rm = na.rm))
    else if (is.data.frame(x)) 
        sapply(x, sd, na.rm = na.rm)
    else sqrt(var(as.vector(x), na.rm = na.rm))
}
<environment: namespace:stats>
> print("se.contrast"); if(is.function(try(se.contrast))) {se.contrast;} else{ NULL};
[1] "se.contrast"
function (object, ...) 
UseMethod("se.contrast")
<environment: namespace:stats>
> print("selfStart"); if(is.function(try(selfStart))) {selfStart;} else{ NULL};
[1] "selfStart"
function (model, initial, parameters, template) 
UseMethod("selfStart")
<environment: namespace:stats>
> print("setNames"); if(is.function(try(setNames))) {setNames;} else{ NULL};
[1] "setNames"
function (object, nm) 
{
    names(object) <- nm
    object
}
<environment: namespace:stats>
> print("shapiro.test"); if(is.function(try(shapiro.test))) {shapiro.test;} else{ NULL};
[1] "shapiro.test"
function (x) 
{
    DNAME <- deparse(substitute(x))
    x <- sort(x[complete.cases(x)])
    stopifnot(is.numeric(x))
    n <- length(x)
    if (n < 3 || n > 5000) 
        stop("sample size must be between 3 and 5000")
    rng <- x[n] - x[1L]
    if (rng == 0) 
        stop("all 'x' values are identical")
    if (rng < 1e-10) 
        x <- x/rng
    n2 <- n%/%2L
    sw <- .C(R_swilk, init = FALSE, as.single(x), n, n1 = n, 
        n2, a = single(n2), w = double(1), pw = double(1), ifault = integer(1L))
    if (sw$ifault && sw$ifault != 7) 
        stop(gettextf("ifault=%d. This should not happen", sw$ifault), 
            domain = NA)
    RVAL <- list(statistic = c(W = sw$w), p.value = sw$pw, method = "Shapiro-Wilk normality test", 
        data.name = DNAME)
    class(RVAL) <- "htest"
    return(RVAL)
}
<environment: namespace:stats>
> print("simulate"); if(is.function(try(simulate))) {simulate;} else{ NULL};
[1] "simulate"
function (object, nsim = 1, seed = NULL, ...) 
UseMethod("simulate")
<environment: namespace:stats>
> print("smooth"); if(is.function(try(smooth))) {smooth;} else{ NULL};
[1] "smooth"
function (x, kind = c("3RS3R", "3RSS", "3RSR", "3R", "3", "S"), 
    twiceit = FALSE, endrule = "Tukey", do.ends = FALSE) 
{
    if (!is.numeric(x)) 
        stop("attempt to smooth non-numeric values")
    if (any(is.na(x))) 
        stop("attempt to smooth NA values")
    rules <- c("copy", "Tukey")
    if (is.na(iend <- pmatch(endrule, rules))) 
        stop("wrong endrule")
    n <- length(x)
    kind <- match.arg(kind)
    if (substr(kind, 1L, 3L) == "3RS" && !do.ends) 
        iend <- -iend
    else if (kind == "S") 
        iend <- as.logical(do.ends)
    smo <- .C(paste("Rsm", kind, sep = "_"), as.double(x), y = double(n), 
        n, iend, iter = integer(1L), DUP = FALSE, PACKAGE = "stats")[c("y", 
        "iter")]
    if (any(kind == c("R", "S"))) {
        smo$iter <- as.logical(smo$iter)
        names(smo)[names(smo) == "iter"] <- "changed"
    }
    if (twiceit) {
        r <- smooth(x - smo$y, kind = kind, twiceit = FALSE, 
            endrule = endrule, do.ends = do.ends)
        smo$y <- smo$y + r
        if (!is.null(smo$iter)) 
            smo$iter <- smo$iter + attr(r, "iter")
        if (!is.null(smo$changed)) 
            smo$changed <- smo$changed || attr(r, "changed")
    }
    if (is.ts(x)) 
        smo$y <- ts(smo$y, start = start(x), frequency = frequency(x))
    structure(smo$y, kind = kind, twiced = twiceit, iter = smo$iter, 
        changed = smo$changed, endrule = if (substr(kind, 1L, 
            1L) == "3") 
            rules[iend], call = match.call(), class = c("tukeysmooth", 
            if (is.ts(x)) "ts"))
}
<environment: namespace:stats>
> print("smooth.spline"); if(is.function(try(smooth.spline))) {smooth.spline;} else{ NULL};
[1] "smooth.spline"
function (x, y = NULL, w = NULL, df, spar = NULL, cv = FALSE, 
    all.knots = FALSE, nknots = NULL, keep.data = TRUE, df.offset = 0, 
    penalty = 1, control.spar = list()) 
{
    contr.sp <- list(low = -1.5, high = 1.5, tol = 1e-04, eps = 2e-08, 
        maxit = 500, trace = getOption("verbose"))
    contr.sp[names(control.spar)] <- control.spar
    if (!all(sapply(contr.sp[1:4], is.numeric)) || contr.sp$tol < 
        0 || contr.sp$eps <= 0 || contr.sp$maxit <= 0) 
        stop("invalid 'control.spar'")
    xy <- xy.coords(x, y)
    y <- xy$y
    x <- xy$x
    if (!all(is.finite(c(x, y)))) 
        stop("missing or infinite values in inputs are not allowed")
    n <- length(x)
    w <- if (is.null(w)) 
        rep(1, n)
    else {
        if (n != length(w)) 
            stop("lengths of 'x' and 'w' must match")
        if (any(w < 0)) 
            stop("all weights should be non-negative")
        if (all(w == 0)) 
            stop("some weights should be positive")
        (w * sum(w > 0))/sum(w)
    }
    x <- signif(x, 6L)
    ux <- unique(sort(x))
    nx <- length(ux)
    if (nx <= 3L) 
        stop("need at least four unique 'x' values")
    if (nx == n) {
        ox <- TRUE
        tmp <- cbind(w, w * y, w * y^2)[order(x), ]
    }
    else {
        ox <- match(x, ux)
        tapply1 <- function(X, INDEX, FUN = NULL, ..., simplify = TRUE) {
            sapply(unname(split(X, INDEX)), FUN, ..., simplify = simplify, 
                USE.NAMES = FALSE)
        }
        tmp <- matrix(unlist(tapply1(seq_len(n), ox, function(i, 
            y, w) c(sum(w[i]), sum(w[i] * y[i]), sum(w[i] * y[i]^2)), 
            y = y, w = w)), ncol = 3, byrow = TRUE)
    }
    wbar <- tmp[, 1L]
    ybar <- tmp[, 2L]/ifelse(wbar > 0, wbar, 1)
    yssw <- sum(tmp[, 3L] - wbar * ybar^2)
    if (is.na(cv) && !missing(df)) 
        stop("'cv' must not be NA when 'df' is specified")
    CV <- !is.na(cv) && cv
    if (CV && nx < n) 
        warning("crossvalidation with non-unique 'x' values seems doubtful")
    r.ux <- ux[nx] - ux[1L]
    xbar <- (ux - ux[1L])/r.ux
    if (all.knots) {
        if (!is.null(nknots)) 
            warning("'all.knots' is TRUE; 'nknots' specification is disregarded")
        nknots <- nx
    }
    else {
        if (is.null(nknots)) 
            nknots <- n.knots(nx)
        else if (!is.numeric(nknots)) 
            stop("'nknots' must be numeric (in {1,..,n})")
        else if (nknots < 1) 
            stop("'nknots' must be at least 1")
        else if (nknots > nx) 
            stop("cannot use more inner knots than unique 'x' values")
    }
    knot <- c(rep(xbar[1], 3), if (all.knots) xbar else xbar[seq.int(1, 
        nx, length.out = nknots)], rep(xbar[nx], 3))
    nk <- nknots + 2L
    ispar <- if (is.null(spar) || missing(spar)) {
        if (contr.sp$trace) 
            -1L
        else 0L
    }
    else 1L
    spar <- if (ispar == 1L) 
        as.double(spar)
    else double(1)
    icrit <- if (is.na(cv)) 
        0L
    else if (cv) 
        2L
    else 1L
    dofoff <- df.offset
    if (!missing(df)) {
        if (df > 1 && df <= nx) {
            if (!missing(cv)) 
                warning("specified both 'df' and 'cv'; will disregard the latter")
            icrit <- 3L
            dofoff <- df
        }
        else warning("you must supply 1 < df <= n,  n = #{unique x} = ", 
            nx)
    }
    iparms <- as.integer(c(icrit, ispar, contr.sp$maxit))
    names(iparms) <- c("icrit", "ispar", "iter")
    keep.stuff <- FALSE
    ans.names <- c("coef", "ty", "lev", "spar", "parms", "crit", 
        "iparms", "ier", if (keep.stuff) "scratch")
    fit <- .Fortran(R_qsbart, as.double(penalty), as.double(dofoff), 
        x = as.double(xbar), y = as.double(ybar), w = as.double(wbar), 
        ssw = as.double(yssw), as.integer(nx), as.double(knot), 
        as.integer(nk), coef = double(nk), ty = double(nx), lev = double(if (is.na(cv)) 1L else nx), 
        crit = double(1), iparms = iparms, spar = spar, parms = unlist(contr.sp[1:4]), 
        isetup = as.integer(0), scratch = double(17L * nk + 1L), 
        ld4 = 4L, ldnk = 1L, ier = integer(1), DUP = FALSE)[ans.names]
    wbar <- tmp[, 1]
    if (is.na(cv)) 
        lev <- df <- NA
    else {
        lev <- fit$lev
        df <- sum(lev)
        if (is.na(df)) 
            stop("NA lev[]; probably smoothing parameter 'spar' way too large!")
    }
    if (fit$ier > 0L) {
        sml <- fit$spar < 0.5
        wtxt <- paste("smoothing parameter value too", if (sml) 
            "small"
        else "large")
        if (sml) {
            stop(wtxt)
        }
        else {
            fit$ty <- rep(mean(y), nx)
            df <- 1
            warning(wtxt, "\nsetting df = 1  __use with care!__")
        }
    }
    cv.crit <- if (is.na(cv)) 
        NA
    else if (cv) {
        ww <- wbar
        ww[!(ww > 0)] <- 1
        weighted.mean(((y - fit$ty[ox])/(1 - (lev[ox] * w)/ww[ox]))^2, 
            w)
    }
    else weighted.mean((y - fit$ty[ox])^2, w)/(1 - (df.offset + 
        penalty * df)/n)^2
    pen.crit <- sum(wbar * (ybar - fit$ty)^2)
    fit.object <- list(knot = knot, nk = nk, min = ux[1L], range = r.ux, 
        coef = fit$coef)
    class(fit.object) <- "smooth.spline.fit"
    object <- list(x = ux, y = fit$ty, w = wbar, yin = ybar, 
        data = if (keep.data) list(x = x, y = y, w = w), lev = lev, 
        cv.crit = cv.crit, pen.crit = pen.crit, crit = fit$crit, 
        df = df, spar = fit$spar, lambda = unname(fit$parms["low"]), 
        iparms = fit$iparms, fit = fit.object, call = match.call())
    class(object) <- "smooth.spline"
    object
}
<environment: namespace:stats>
> print("smoothEnds"); if(is.function(try(smoothEnds))) {smoothEnds;} else{ NULL};
[1] "smoothEnds"
function (y, k = 3) 
{
    med3 <- function(a, b, c) {
        m <- b
        if (a < b) {
            if (c < b) 
                m <- if (a >= c) 
                  a
                else c
        }
        else {
            if (c > b) 
                m <- if (a <= c) 
                  a
                else c
        }
        m
    }
    med.odd <- function(x, n = length(x)) {
        half <- (n + 1)%/%2
        sort(x, partial = half)[half]
    }
    k <- as.integer(k)
    if (k < 0 || k%%2 == 0) 
        stop("bandwidth 'k' must be >= 1 and odd!")
    k <- k%/%2
    if (k < 1) 
        return(y)
    n <- length(y)
    sm <- y
    if (k >= 2) {
        sm[2L] <- med3(y[1L], y[2L], y[3L])
        sm[n - 1] <- med3(y[n], y[n - 1], y[n - 2])
        if (k >= 3) {
            for (i in 3:k) {
                j <- 2 * i - 1
                sm[i] <- med.odd(y[1L:j], j)
                sm[n - i + 1] <- med.odd(y[(n + 1 - j):n], j)
            }
        }
    }
    sm[1L] <- med3(y[1L], sm[2L], 3 * sm[2L] - 2 * sm[3L])
    sm[n] <- med3(y[n], sm[n - 1], 3 * sm[n - 1] - 2 * sm[n - 
        2])
    return(sm)
}
<environment: namespace:stats>
> print("sortedXyData"); if(is.function(try(sortedXyData))) {sortedXyData;} else{ NULL};
[1] "sortedXyData"
function (x, y, data) 
UseMethod("sortedXyData")
<environment: namespace:stats>
> print("spec.ar"); if(is.function(try(spec.ar))) {spec.ar;} else{ NULL};
[1] "spec.ar"
function (x, n.freq, order = NULL, plot = TRUE, na.action = na.fail, 
    method = "yule-walker", ...) 
{
    if (!is.list(x)) {
        series <- deparse(substitute(x))
        x <- na.action(as.ts(x))
        xfreq <- frequency(x)
        nser <- NCOL(x)
        x <- ar(x, is.null(order), order, na.action = na.action, 
            method = method)
    }
    else {
        cn <- match(c("ar", "var.pred", "order"), names(x))
        if (any(is.na(cn))) 
            stop("'x' must be a time series or an ar() fit")
        series <- x$series
        xfreq <- x$frequency
        if (is.array(x$ar)) 
            nser <- dim(x$ar)[2L]
        else nser <- 1
    }
    order <- x$order
    if (missing(n.freq)) 
        n.freq <- 500
    freq <- seq.int(0, 0.5, length.out = n.freq)
    if (nser == 1) {
        coh <- phase <- NULL
        var.p <- as.vector(x$var.pred)
        spec <- if (order >= 1) {
            cs <- outer(freq, 1L:order, function(x, y) cos(2 * 
                pi * x * y)) %*% x$ar
            sn <- outer(freq, 1L:order, function(x, y) sin(2 * 
                pi * x * y)) %*% x$ar
            var.p/(xfreq * ((1 - cs)^2 + sn^2))
        }
        else rep.int(var.p/xfreq, length(freq))
    }
    else .NotYetImplemented()
    spg.out <- list(freq = freq * xfreq, spec = spec, coh = coh, 
        phase = phase, n.used = nrow(x), series = series, method = paste("AR (", 
            order, ") spectrum ", sep = ""))
    class(spg.out) <- "spec"
    if (plot) {
        plot(spg.out, ci = 0, ...)
        invisible(spg.out)
    }
    else spg.out
}
<environment: namespace:stats>
> print("spec.pgram"); if(is.function(try(spec.pgram))) {spec.pgram;} else{ NULL};
[1] "spec.pgram"
function (x, spans = NULL, kernel = NULL, taper = 0.1, pad = 0, 
    fast = TRUE, demean = FALSE, detrend = TRUE, plot = TRUE, 
    na.action = na.fail, ...) 
{
    series <- deparse(substitute(x))
    x <- na.action(as.ts(x))
    xfreq <- frequency(x)
    x <- as.matrix(x)
    N <- N0 <- nrow(x)
    nser <- ncol(x)
    if (!is.null(spans)) 
        kernel <- {
            if (is.tskernel(spans)) 
                spans
            else kernel("modified.daniell", spans%/%2)
        }
    if (!is.null(kernel) && !is.tskernel(kernel)) 
        stop("must specify 'spans' or a valid kernel")
    if (detrend) {
        t <- 1L:N - (N + 1)/2
        sumt2 <- N * (N^2 - 1)/12
        for (i in 1L:ncol(x)) x[, i] <- x[, i] - mean(x[, i]) - 
            sum(x[, i] * t) * t/sumt2
    }
    else if (demean) {
        x <- sweep(x, 2, colMeans(x), check.margin = FALSE)
    }
    x <- spec.taper(x, taper)
    u2 <- (1 - (5/8) * taper * 2)
    u4 <- (1 - (93/128) * taper * 2)
    if (pad > 0) {
        x <- rbind(x, matrix(0, nrow = N * pad, ncol = ncol(x)))
        N <- nrow(x)
    }
    NewN <- if (fast) 
        nextn(N)
    else N
    x <- rbind(x, matrix(0, nrow = (NewN - N), ncol = ncol(x)))
    N <- nrow(x)
    Nspec <- floor(N/2)
    freq <- seq.int(from = xfreq/N, by = xfreq/N, length.out = Nspec)
    xfft <- mvfft(x)
    pgram <- array(NA, dim = c(N, ncol(x), ncol(x)))
    for (i in 1L:ncol(x)) {
        for (j in 1L:ncol(x)) {
            pgram[, i, j] <- xfft[, i] * Conj(xfft[, j])/(N0 * 
                xfreq)
            pgram[1, i, j] <- 0.5 * (pgram[2, i, j] + pgram[N, 
                i, j])
        }
    }
    if (!is.null(kernel)) {
        for (i in 1L:ncol(x)) for (j in 1L:ncol(x)) pgram[, i, 
            j] <- kernapply(pgram[, i, j], kernel, circular = TRUE)
        df <- df.kernel(kernel)
        bandwidth <- bandwidth.kernel(kernel)
    }
    else {
        df <- 2
        bandwidth <- sqrt(1/12)
    }
    df <- df/(u4/u2^2)
    df <- df * (N0/N)
    bandwidth <- bandwidth * xfreq/N
    pgram <- pgram[2:(Nspec + 1), , , drop = FALSE]
    spec <- matrix(NA, nrow = Nspec, ncol = nser)
    for (i in 1L:nser) spec[, i] <- Re(pgram[1L:Nspec, i, i])
    if (nser == 1) {
        coh <- phase <- NULL
    }
    else {
        coh <- phase <- matrix(NA, nrow = Nspec, ncol = nser * 
            (nser - 1)/2)
        for (i in 1L:(nser - 1)) {
            for (j in (i + 1):nser) {
                coh[, i + (j - 1) * (j - 2)/2] <- Mod(pgram[, 
                  i, j])^2/(spec[, i] * spec[, j])
                phase[, i + (j - 1) * (j - 2)/2] <- Arg(pgram[, 
                  i, j])
            }
        }
    }
    for (i in 1L:nser) spec[, i] <- spec[, i]/u2
    spec <- drop(spec)
    spg.out <- list(freq = freq, spec = spec, coh = coh, phase = phase, 
        kernel = kernel, df = df, bandwidth = bandwidth, n.used = N, 
        orig.n = N0, series = series, snames = colnames(x), method = ifelse(!is.null(kernel), 
            "Smoothed Periodogram", "Raw Periodogram"), taper = taper, 
        pad = pad, detrend = detrend, demean = demean)
    class(spg.out) <- "spec"
    if (plot) {
        plot(spg.out, ...)
        return(invisible(spg.out))
    }
    else return(spg.out)
}
<environment: namespace:stats>
> print("spec.taper"); if(is.function(try(spec.taper))) {spec.taper;} else{ NULL};
[1] "spec.taper"
function (x, p = 0.1) 
{
    if (any(p < 0) || any(p > 0.5)) 
        stop("'p' must be between 0 and 0.5")
    a <- attributes(x)
    x <- as.matrix(x)
    nc <- ncol(x)
    if (length(p) == 1L) 
        p <- rep(p, nc)
    else if (length(p) != nc) 
        stop("length of 'p' must be 1 or equal the number of columns of 'x'")
    nr <- nrow(x)
    for (i in 1L:nc) {
        m <- floor(nr * p[i])
        if (m == 0) 
            next
        w <- 0.5 * (1 - cos(pi * seq.int(1, 2 * m - 1, by = 2)/(2 * 
            m)))
        x[, i] <- c(w, rep(1, nr - 2 * m), rev(w)) * x[, i]
    }
    attributes(x) <- a
    x
}
<environment: namespace:stats>
> print("spectrum"); if(is.function(try(spectrum))) {spectrum;} else{ NULL};
[1] "spectrum"
function (x, ..., method = c("pgram", "ar")) 
{
    switch(match.arg(method), pgram = spec.pgram(x, ...), ar = spec.ar(x, 
        ...))
}
<environment: namespace:stats>
> print("splinefun"); if(is.function(try(splinefun))) {splinefun;} else{ NULL};
[1] "splinefun"
function (x, y = NULL, method = c("fmm", "periodic", "natural", 
    "monoH.FC"), ties = mean) 
{
    x <- regularize.values(x, y, ties)
    y <- x$y
    x <- x$x
    nx <- length(x)
    if (nx == 0) 
        stop("zero non-NA points")
    method <- match.arg(method)
    if (method == "periodic" && y[1L] != y[nx]) {
        warning("spline: first and last y values differ - using y[1L] for both")
        y[nx] <- y[1L]
    }
    if (method == "monoH.FC") {
        n1 <- nx - 1L
        dy <- y[-1L] - y[-nx]
        dx <- x[-1L] - x[-nx]
        Sx <- dy/dx
        m <- c(Sx[1L], (Sx[-1L] + Sx[-n1])/2, Sx[n1])
        m <- .Call("R_monoFC_m", m, Sx, PACKAGE = "stats")
        return(splinefunH0(x = x, y = y, m = m, dx = dx))
    }
    iMeth <- match(method, c("periodic", "natural", "fmm", "monoH.FC"))
    z <- .C("spline_coef", method = as.integer(iMeth), n = as.integer(nx), 
        x = x, y = y, b = double(nx), c = double(nx), d = double(nx), 
        e = double(if (iMeth == 1) nx else 0), PACKAGE = "stats")
    rm(x, y, nx, method, iMeth, ties)
    z$e <- NULL
    function(x, deriv = 0) {
        deriv <- as.integer(deriv)
        if (deriv < 0 || deriv > 3) 
            stop("'deriv' must be between 0 and 3")
        if (deriv > 0) {
            z0 <- double(z$n)
            z[c("y", "b", "c")] <- switch(deriv, list(y = z$b, 
                b = 2 * z$c, c = 3 * z$d), list(y = 2 * z$c, 
                b = 6 * z$d, c = z0), list(y = 6 * z$d, b = z0, 
                c = z0))
            z[["d"]] <- z0
        }
        res <- .C("spline_eval", z$method, as.integer(length(x)), 
            x = as.double(x), y = double(length(x)), z$n, z$x, 
            z$y, z$b, z$c, z$d, PACKAGE = "stats")$y
        if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L])) 
            res[ind] <- ifelse(deriv == 1, z$y[1L], 0)
        res
    }
}
<environment: namespace:stats>
> print("start"); if(is.function(try(start))) {start;} else{ NULL};
[1] "start"
function (x, ...) 
UseMethod("start")
<environment: namespace:stats>
> print("stat.anova"); if(is.function(try(stat.anova))) {stat.anova;} else{ NULL};
[1] "stat.anova"
function (table, test = c("Chisq", "F", "Cp"), scale, df.scale, 
    n) 
{
    test <- match.arg(test)
    dev.col <- match("Deviance", colnames(table))
    if (is.na(dev.col)) 
        dev.col <- match("Sum of Sq", colnames(table))
    switch(test, Chisq = {
        dfs <- table[, "Df"]
        vals <- table[, dev.col]/scale * sign(dfs)
        vals[dfs %in% 0] <- NA
        vals[!is.na(vals) & vals < 0] <- NA
        cbind(table, `P(>|Chi|)` = pchisq(vals, abs(dfs), lower.tail = FALSE))
    }, F = {
        dfs <- table[, "Df"]
        Fvalue <- (table[, dev.col]/dfs)/scale
        Fvalue[dfs %in% 0] <- NA
        Fvalue[!is.na(Fvalue) & Fvalue < 0] <- NA
        cbind(table, F = Fvalue, `Pr(>F)` = pf(Fvalue, abs(dfs), 
            df.scale, lower.tail = FALSE))
    }, Cp = {
        cbind(table, Cp = table[, "Resid. Dev"] + 2 * scale * 
            (n - table[, "Resid. Df"]))
    })
}
<environment: namespace:stats>
> print("stats-deprecated"); if(is.function(try(stats-deprecated))) {stats-deprecated;} else{ NULL};
[1] "stats-deprecated"
NULL
> print("stats-package"); if(is.function(try(stats-package))) {stats-package;} else{ NULL};
[1] "stats-package"
NULL
> print("step"); if(is.function(try(step))) {step;} else{ NULL};
[1] "step"
function (object, scope, scale = 0, direction = c("both", "backward", 
    "forward"), trace = 1, keep = NULL, steps = 1000, k = 2, 
    ...) 
{
    mydeviance <- function(x, ...) {
        dev <- deviance(x)
        if (!is.null(dev)) 
            dev
        else extractAIC(x, k = 0)[2L]
    }
    cut.string <- function(string) {
        if (length(string) > 1L) 
            string[-1L] <- paste("\n", string[-1L], sep = "")
        string
    }
    re.arrange <- function(keep) {
        namr <- names(k1 <- keep[[1L]])
        namc <- names(keep)
        nc <- length(keep)
        nr <- length(k1)
        array(unlist(keep, recursive = FALSE), c(nr, nc), list(namr, 
            namc))
    }
    step.results <- function(models, fit, object, usingCp = FALSE) {
        change <- sapply(models, "[[", "change")
        rd <- sapply(models, "[[", "deviance")
        dd <- c(NA, abs(diff(rd)))
        rdf <- sapply(models, "[[", "df.resid")
        ddf <- c(NA, diff(rdf))
        AIC <- sapply(models, "[[", "AIC")
        heading <- c("Stepwise Model Path \nAnalysis of Deviance Table", 
            "\nInitial Model:", deparse(formula(object)), "\nFinal Model:", 
            deparse(formula(fit)), "\n")
        aod <- data.frame(Step = I(change), Df = ddf, Deviance = dd, 
            `Resid. Df` = rdf, `Resid. Dev` = rd, AIC = AIC, 
            check.names = FALSE)
        if (usingCp) {
            cn <- colnames(aod)
            cn[cn == "AIC"] <- "Cp"
            colnames(aod) <- cn
        }
        attr(aod, "heading") <- heading
        fit$anova <- aod
        fit
    }
    Terms <- terms(object)
    object$call$formula <- object$formula <- Terms
    md <- missing(direction)
    direction <- match.arg(direction)
    backward <- direction == "both" | direction == "backward"
    forward <- direction == "both" | direction == "forward"
    if (missing(scope)) {
        fdrop <- numeric()
        fadd <- attr(Terms, "factors")
        if (md) 
            forward <- FALSE
    }
    else {
        if (is.list(scope)) {
            fdrop <- if (!is.null(fdrop <- scope$lower)) 
                attr(terms(update.formula(object, fdrop)), "factors")
            else numeric()
            fadd <- if (!is.null(fadd <- scope$upper)) 
                attr(terms(update.formula(object, fadd)), "factors")
        }
        else {
            fadd <- if (!is.null(fadd <- scope)) 
                attr(terms(update.formula(object, scope)), "factors")
            fdrop <- numeric()
        }
    }
    models <- vector("list", steps)
    if (!is.null(keep)) 
        keep.list <- vector("list", steps)
    n <- nobs(object, use.fallback = TRUE)
    fit <- object
    bAIC <- extractAIC(fit, scale, k = k, ...)
    edf <- bAIC[1L]
    bAIC <- bAIC[2L]
    if (is.na(bAIC)) 
        stop("AIC is not defined for this model, so 'step' cannot proceed")
    nm <- 1
    if (trace) {
        cat("Start:  AIC=", format(round(bAIC, 2)), "\n", cut.string(deparse(formula(fit))), 
            "\n\n", sep = "")
        utils::flush.console()
    }
    models[[nm]] <- list(deviance = mydeviance(fit), df.resid = n - 
        edf, change = "", AIC = bAIC)
    if (!is.null(keep)) 
        keep.list[[nm]] <- keep(fit, bAIC)
    usingCp <- FALSE
    while (steps > 0) {
        steps <- steps - 1
        AIC <- bAIC
        ffac <- attr(Terms, "factors")
        scope <- factor.scope(ffac, list(add = fadd, drop = fdrop))
        aod <- NULL
        change <- NULL
        if (backward && length(scope$drop)) {
            aod <- drop1(fit, scope$drop, scale = scale, trace = trace, 
                k = k, ...)
            rn <- row.names(aod)
            row.names(aod) <- c(rn[1L], paste("-", rn[-1L], sep = " "))
            if (any(aod$Df == 0, na.rm = TRUE)) {
                zdf <- aod$Df == 0 & !is.na(aod$Df)
                change <- rev(rownames(aod)[zdf])[1L]
            }
        }
        if (is.null(change)) {
            if (forward && length(scope$add)) {
                aodf <- add1(fit, scope$add, scale = scale, trace = trace, 
                  k = k, ...)
                rn <- row.names(aodf)
                row.names(aodf) <- c(rn[1L], paste("+", rn[-1L], 
                  sep = " "))
                aod <- if (is.null(aod)) 
                  aodf
                else rbind(aod, aodf[-1, , drop = FALSE])
            }
            attr(aod, "heading") <- NULL
            nzdf <- if (!is.null(aod$Df)) 
                aod$Df != 0 | is.na(aod$Df)
            aod <- aod[nzdf, ]
            if (is.null(aod) || ncol(aod) == 0) 
                break
            nc <- match(c("Cp", "AIC"), names(aod))
            nc <- nc[!is.na(nc)][1L]
            o <- order(aod[, nc])
            if (trace) 
                print(aod[o, ])
            if (o[1L] == 1) 
                break
            change <- rownames(aod)[o[1L]]
        }
        usingCp <- match("Cp", names(aod), 0L) > 0L
        fit <- update(fit, paste("~ .", change), evaluate = FALSE)
        fit <- eval.parent(fit)
        nnew <- nobs(fit, use.fallback = TRUE)
        if (all(is.finite(c(n, nnew))) && nnew != n) 
            stop("number of rows in use has changed: remove missing values?")
        Terms <- terms(fit)
        bAIC <- extractAIC(fit, scale, k = k, ...)
        edf <- bAIC[1L]
        bAIC <- bAIC[2L]
        if (trace) {
            cat("\nStep:  AIC=", format(round(bAIC, 2)), "\n", 
                cut.string(deparse(formula(fit))), "\n\n", sep = "")
            utils::flush.console()
        }
        if (bAIC >= AIC + 1e-07) 
            break
        nm <- nm + 1
        models[[nm]] <- list(deviance = mydeviance(fit), df.resid = n - 
            edf, change = change, AIC = bAIC)
        if (!is.null(keep)) 
            keep.list[[nm]] <- keep(fit, bAIC)
    }
    if (!is.null(keep)) 
        fit$keep <- re.arrange(keep.list[seq(nm)])
    step.results(models = models[seq(nm)], fit, object, usingCp)
}
<environment: namespace:stats>
> print("stepfun"); if(is.function(try(stepfun))) {stepfun;} else{ NULL};
[1] "stepfun"
function (x, y, f = as.numeric(right), ties = "ordered", right = FALSE) 
{
    if (is.unsorted(x)) 
        stop("stepfun: 'x' must be ordered increasingly")
    n <- length(x)
    if (n < 1) 
        stop("'x' must have length >= 1")
    n1 <- n + 1L
    if (length(y) != n1) 
        stop("'y' must be one longer than 'x'")
    rval <- approxfun(x, y[-if (right) 
        n1
    else 1], method = "constant", yleft = y[1L], yright = y[n1], 
        f = f, ties = ties)
    class(rval) <- c("stepfun", class(rval))
    attr(rval, "call") <- sys.call()
    rval
}
<environment: namespace:stats>
> print("stl"); if(is.function(try(stl))) {stl;} else{ NULL};
[1] "stl"
function (x, s.window, s.degree = 0, t.window = NULL, t.degree = 1, 
    l.window = nextodd(period), l.degree = t.degree, s.jump = ceiling(s.window/10), 
    t.jump = ceiling(t.window/10), l.jump = ceiling(l.window/10), 
    robust = FALSE, inner = if (robust) 1 else 2, outer = if (robust) 15 else 0, 
    na.action = na.fail) 
{
    nextodd <- function(x) {
        x <- round(x)
        if (x%%2 == 0) 
            x <- x + 1
        as.integer(x)
    }
    deg.check <- function(deg) {
        degname <- deparse(substitute(deg))
        deg <- as.integer(deg)
        if (deg < 0 || deg > 1) 
            stop(degname, " must be 0 or 1")
        deg
    }
    x <- na.action(as.ts(x))
    if (is.matrix(x)) 
        stop("only univariate series are allowed")
    n <- length(x)
    period <- frequency(x)
    if (period < 2 || n <= 2 * period) 
        stop("series is not periodic or has less than two periods")
    periodic <- FALSE
    if (is.character(s.window)) {
        if (is.na(pmatch(s.window, "periodic"))) 
            stop("unknown string value for s.window")
        else {
            periodic <- TRUE
            s.window <- 10 * n + 1
            s.degree <- 0
        }
    }
    s.degree <- deg.check(s.degree)
    t.degree <- deg.check(t.degree)
    l.degree <- deg.check(l.degree)
    if (is.null(t.window)) 
        t.window <- nextodd(ceiling(1.5 * period/(1 - 1.5/s.window)))
    z <- .Fortran(R_stl, as.double(x), as.integer(n), as.integer(period), 
        as.integer(s.window), as.integer(t.window), as.integer(l.window), 
        s.degree, t.degree, l.degree, nsjump = as.integer(s.jump), 
        ntjump = as.integer(t.jump), nljump = as.integer(l.jump), 
        ni = as.integer(inner), no = as.integer(outer), weights = double(n), 
        seasonal = double(n), trend = double(n), double((n + 
            2 * period) * 5))
    if (periodic) {
        which.cycle <- cycle(x)
        z$seasonal <- tapply(z$seasonal, which.cycle, mean)[which.cycle]
    }
    remainder <- as.vector(x) - z$seasonal - z$trend
    y <- cbind(seasonal = z$seasonal, trend = z$trend, remainder = remainder)
    res <- list(time.series = ts(y, start = start(x), frequency = period), 
        weights = z$weights, call = match.call(), win = c(s = s.window, 
            t = t.window, l = l.window), deg = c(s = s.degree, 
            t = t.degree, l = l.degree), jump = c(s = s.jump, 
            t = t.jump, l = l.jump), inner = z$ni, outer = z$no)
    class(res) <- "stl"
    res
}
<environment: namespace:stats>
> print("summary.aov"); if(is.function(try(summary.aov))) {summary.aov;} else{ NULL};
[1] "summary.aov"
function (object, intercept = FALSE, split, expand.split = TRUE, 
    keep.zero.df = TRUE, ...) 
{
    splitInteractions <- function(split, factors, names, asgn, 
        df.names) {
        ns <- names(split)
        for (i in unique(asgn)) {
            if (i == 0 || names[i + 1L] %in% ns) 
                next
            f <- rownames(factors)[factors[, i] > 0]
            sp <- f %in% ns
            if (any(sp)) {
                if (sum(sp) > 1) {
                  old <- split[f[sp]]
                  nn <- f[sp]
                  names(nn) <- nn
                  marg <- lapply(nn, function(x) df.names[asgn == 
                    (match(x, names) - 1L)])
                  term.coefs <- strsplit(df.names[asgn == i], 
                    ":", fixed = TRUE)
                  ttc <- sapply(term.coefs, function(x) x[sp])
                  rownames(ttc) <- nn
                  splitnames <- apply(expand.grid(lapply(old, 
                    names)), 1L, function(x) paste(x, collapse = "."))
                  names(splitnames) <- splitnames
                  tmp <- sapply(nn, function(i) names(old[[i]])[match(ttc[i, 
                    ], marg[[i]])])
                  tmp <- apply(tmp, 1L, function(x) paste(x, 
                    collapse = "."))
                  new <- lapply(splitnames, function(x) match(x, 
                    tmp))
                  split[[names[i + 1L]]] <- new[sapply(new, function(x) length(x) > 
                    0L)]
                }
                else {
                  old <- split[[f[sp]]]
                  marg.coefs <- df.names[asgn == (match(f[sp], 
                    names) - 1L)]
                  term.coefs <- strsplit(df.names[asgn == i], 
                    ":", fixed = TRUE)
                  ttc <- sapply(term.coefs, function(x) x[sp])
                  new <- lapply(old, function(x) seq_along(ttc)[ttc %in% 
                    marg.coefs[x]])
                  split[[names[i + 1L]]] <- new
                }
            }
        }
        split
    }
    asgn <- object$assign[object$qr$pivot[1L:object$rank]]
    uasgn <- unique(asgn)
    nterms <- length(uasgn)
    effects <- object$effects
    if (!is.null(effects)) 
        effects <- as.matrix(effects)[seq_along(asgn), , drop = FALSE]
    rdf <- object$df.residual
    nmeffect <- c("(Intercept)", attr(object$terms, "term.labels"))
    coef <- as.matrix(object$coefficients)
    resid <- as.matrix(object$residuals)
    wt <- object$weights
    if (!is.null(wt)) 
        resid <- resid * wt^0.5
    nresp <- NCOL(resid)
    ans <- vector("list", nresp)
    if (nresp > 1) {
        names(ans) <- character(nresp)
        for (y in 1L:nresp) {
            cn <- colnames(resid)[y]
            if (is.null(cn) || cn == "") 
                cn <- y
            names(ans)[y] <- paste(" Response", cn)
        }
    }
    if (!is.null(effects) && !missing(split)) {
        ns <- names(split)
        if (!is.null(Terms <- object$terms)) {
            if (!is.list(split)) 
                stop("the 'split' argument must be a list")
            if (!all(ns %in% nmeffect)) 
                stop("unknown name(s) in the 'split' list")
        }
        if (expand.split) {
            df.names <- names(coef(object))
            split <- splitInteractions(split, attr(Terms, "factors"), 
                nmeffect, asgn, df.names)
            ns <- names(split)
        }
    }
    for (y in 1L:nresp) {
        if (is.null(effects)) {
            nterms <- 0
            df <- ss <- ms <- numeric()
            nmrows <- character()
        }
        else {
            df <- ss <- numeric()
            nmrows <- character()
            for (i in seq(nterms)) {
                ai <- (asgn == uasgn[i])
                df <- c(df, sum(ai))
                ss <- c(ss, sum(effects[ai, y]^2))
                nmi <- nmeffect[1 + uasgn[i]]
                nmrows <- c(nmrows, nmi)
                if (!missing(split) && !is.na(int <- match(nmi, 
                  ns))) {
                  df <- c(df, unlist(lapply(split[[int]], length)))
                  if (is.null(nms <- names(split[[int]]))) 
                    nms <- paste("C", seq_along(split[[int]]), 
                      sep = "")
                  ss <- c(ss, unlist(lapply(split[[int]], function(i, 
                    e) sum(e[i]^2), effects[ai, y])))
                  nmrows <- c(nmrows, paste("  ", nmi, ": ", 
                    nms, sep = ""))
                }
            }
        }
        if (rdf > 0) {
            df <- c(df, rdf)
            ss <- c(ss, sum(resid[, y]^2))
            nmrows <- c(nmrows, "Residuals")
        }
        nt <- length(df)
        ms <- ifelse(df > 0L, ss/df, NA)
        x <- list(Df = df, `Sum Sq` = ss, `Mean Sq` = ms)
        if (rdf > 0) {
            TT <- ms/ms[nt]
            TP <- pf(TT, df, rdf, lower.tail = FALSE)
            TT[nt] <- TP[nt] <- NA
            x$"F value" <- TT
            x$"Pr(>F)" <- TP
        }
        class(x) <- c("anova", "data.frame")
        attr(x, "row.names") <- format(nmrows)
        if (!keep.zero.df) 
            x <- x[df > 0, ]
        pm <- pmatch("(Intercept)", row.names(x), 0L)
        if (!intercept && pm > 0) 
            x <- x[-pm, ]
        ans[[y]] <- x
    }
    class(ans) <- c("summary.aov", "listof")
    attr(ans, "na.action") <- object$na.action
    ans
}
<environment: namespace:stats>
> print("summary.glm"); if(is.function(try(summary.glm))) {summary.glm;} else{ NULL};
[1] "summary.glm"
function (object, dispersion = NULL, correlation = FALSE, symbolic.cor = FALSE, 
    ...) 
{
    est.disp <- FALSE
    df.r <- object$df.residual
    if (is.null(dispersion)) 
        dispersion <- if (object$family$family %in% c("poisson", 
            "binomial")) 
            1
        else if (df.r > 0) {
            est.disp <- TRUE
            if (any(object$weights == 0)) 
                warning("observations with zero weight not used for calculating dispersion")
            sum((object$weights * object$residuals^2)[object$weights > 
                0])/df.r
        }
        else {
            est.disp <- TRUE
            NaN
        }
    aliased <- is.na(coef(object))
    p <- object$rank
    if (p > 0) {
        p1 <- 1L:p
        Qr <- qr.lm(object)
        coef.p <- object$coefficients[Qr$pivot[p1]]
        covmat.unscaled <- chol2inv(Qr$qr[p1, p1, drop = FALSE])
        dimnames(covmat.unscaled) <- list(names(coef.p), names(coef.p))
        covmat <- dispersion * covmat.unscaled
        var.cf <- diag(covmat)
        s.err <- sqrt(var.cf)
        tvalue <- coef.p/s.err
        dn <- c("Estimate", "Std. Error")
        if (!est.disp) {
            pvalue <- 2 * pnorm(-abs(tvalue))
            coef.table <- cbind(coef.p, s.err, tvalue, pvalue)
            dimnames(coef.table) <- list(names(coef.p), c(dn, 
                "z value", "Pr(>|z|)"))
        }
        else if (df.r > 0) {
            pvalue <- 2 * pt(-abs(tvalue), df.r)
            coef.table <- cbind(coef.p, s.err, tvalue, pvalue)
            dimnames(coef.table) <- list(names(coef.p), c(dn, 
                "t value", "Pr(>|t|)"))
        }
        else {
            coef.table <- cbind(coef.p, NaN, NaN, NaN)
            dimnames(coef.table) <- list(names(coef.p), c(dn, 
                "t value", "Pr(>|t|)"))
        }
        df.f <- NCOL(Qr$qr)
    }
    else {
        coef.table <- matrix(, 0L, 4L)
        dimnames(coef.table) <- list(NULL, c("Estimate", "Std. Error", 
            "t value", "Pr(>|t|)"))
        covmat.unscaled <- covmat <- matrix(, 0L, 0L)
        df.f <- length(aliased)
    }
    keep <- match(c("call", "terms", "family", "deviance", "aic", 
        "contrasts", "df.residual", "null.deviance", "df.null", 
        "iter", "na.action"), names(object), 0L)
    ans <- c(object[keep], list(deviance.resid = residuals(object, 
        type = "deviance"), coefficients = coef.table, aliased = aliased, 
        dispersion = dispersion, df = c(object$rank, df.r, df.f), 
        cov.unscaled = covmat.unscaled, cov.scaled = covmat))
    if (correlation && p > 0) {
        dd <- sqrt(diag(covmat.unscaled))
        ans$correlation <- covmat.unscaled/outer(dd, dd)
        ans$symbolic.cor <- symbolic.cor
    }
    class(ans) <- "summary.glm"
    return(ans)
}
<environment: namespace:stats>
> print("summary.lm"); if(is.function(try(summary.lm))) {summary.lm;} else{ NULL};
[1] "summary.lm"
function (object, correlation = FALSE, symbolic.cor = FALSE, 
    ...) 
{
    z <- object
    p <- z$rank
    rdf <- z$df.residual
    if (p == 0) {
        r <- z$residuals
        n <- length(r)
        w <- z$weights
        if (is.null(w)) {
            rss <- sum(r^2)
        }
        else {
            rss <- sum(w * r^2)
            r <- sqrt(w) * r
        }
        resvar <- rss/rdf
        ans <- z[c("call", "terms")]
        class(ans) <- "summary.lm"
        ans$aliased <- is.na(coef(object))
        ans$residuals <- r
        ans$df <- c(0L, n, length(ans$aliased))
        ans$coefficients <- matrix(NA, 0L, 4L)
        dimnames(ans$coefficients) <- list(NULL, c("Estimate", 
            "Std. Error", "t value", "Pr(>|t|)"))
        ans$sigma <- sqrt(resvar)
        ans$r.squared <- ans$adj.r.squared <- 0
        return(ans)
    }
    if (is.null(z$terms)) 
        stop("invalid 'lm' object:  no 'terms' component")
    if (!inherits(object, "lm")) 
        warning("calling summary.lm(<fake-lm-object>) ...")
    Qr <- qr.lm(object)
    n <- NROW(Qr$qr)
    if (is.na(z$df.residual) || n - p != z$df.residual) 
        warning("residual degrees of freedom in object suggest this is not an \"lm\" fit")
    p1 <- 1L:p
    r <- z$residuals
    f <- z$fitted.values
    w <- z$weights
    if (is.null(w)) {
        mss <- if (attr(z$terms, "intercept")) 
            sum((f - mean(f))^2)
        else sum(f^2)
        rss <- sum(r^2)
    }
    else {
        mss <- if (attr(z$terms, "intercept")) {
            m <- sum(w * f/sum(w))
            sum(w * (f - m)^2)
        }
        else sum(w * f^2)
        rss <- sum(w * r^2)
        r <- sqrt(w) * r
    }
    resvar <- rss/rdf
    R <- chol2inv(Qr$qr[p1, p1, drop = FALSE])
    se <- sqrt(diag(R) * resvar)
    est <- z$coefficients[Qr$pivot[p1]]
    tval <- est/se
    ans <- z[c("call", "terms")]
    ans$residuals <- r
    ans$coefficients <- cbind(est, se, tval, 2 * pt(abs(tval), 
        rdf, lower.tail = FALSE))
    dimnames(ans$coefficients) <- list(names(z$coefficients)[Qr$pivot[p1]], 
        c("Estimate", "Std. Error", "t value", "Pr(>|t|)"))
    ans$aliased <- is.na(coef(object))
    ans$sigma <- sqrt(resvar)
    ans$df <- c(p, rdf, NCOL(Qr$qr))
    if (p != attr(z$terms, "intercept")) {
        df.int <- if (attr(z$terms, "intercept")) 
            1L
        else 0L
        ans$r.squared <- mss/(mss + rss)
        ans$adj.r.squared <- 1 - (1 - ans$r.squared) * ((n - 
            df.int)/rdf)
        ans$fstatistic <- c(value = (mss/(p - df.int))/resvar, 
            numdf = p - df.int, dendf = rdf)
    }
    else ans$r.squared <- ans$adj.r.squared <- 0
    ans$cov.unscaled <- R
    dimnames(ans$cov.unscaled) <- dimnames(ans$coefficients)[c(1, 
        1)]
    if (correlation) {
        ans$correlation <- (R * resvar)/outer(se, se)
        dimnames(ans$correlation) <- dimnames(ans$cov.unscaled)
        ans$symbolic.cor <- symbolic.cor
    }
    if (!is.null(z$na.action)) 
        ans$na.action <- z$na.action
    class(ans) <- "summary.lm"
    ans
}
<environment: namespace:stats>
> print("summary.manova"); if(is.function(try(summary.manova))) {summary.manova;} else{ NULL};
[1] "summary.manova"
function (object, test = c("Pillai", "Wilks", "Hotelling-Lawley", 
    "Roy"), intercept = FALSE, tol = 1e-07, ...) 
{
    if (!inherits(object, "maov")) 
        stop("object must be of class \"manova\" or \"maov\"")
    test <- match.arg(test)
    asgn <- object$assign[object$qr$pivot[1L:object$rank]]
    uasgn <- unique(asgn)
    nterms <- length(uasgn)
    effects <- object$effects
    if (!is.null(effects)) 
        effects <- as.matrix(effects)[seq_along(asgn), , drop = FALSE]
    rdf <- object$df.residual
    nmeffect <- c("(Intercept)", attr(object$terms, "term.labels"))
    resid <- as.matrix(object$residuals)
    wt <- object$weights
    if (!is.null(wt)) 
        resid <- resid * wt^0.5
    nresp <- NCOL(resid)
    if (nresp <= 1) 
        stop("need multiple responses")
    if (is.null(effects)) {
        df <- nterms <- 0
        ss <- list(0)
        nmrows <- character()
    }
    else {
        df <- numeric(nterms)
        ss <- list(nterms)
        nmrows <- character(nterms)
        for (i in seq(nterms)) {
            ai <- (asgn == uasgn[i])
            nmrows[i] <- nmeffect[1 + uasgn[i]]
            df[i] <- sum(ai)
            ss[[i]] <- crossprod(effects[ai, , drop = FALSE])
        }
    }
    pm <- pmatch("(Intercept)", nmrows, 0L)
    if (!intercept && pm > 0) {
        nterms <- nterms - 1
        df <- df[-pm]
        nmrows <- nmrows[-pm]
        ss <- ss[-pm]
    }
    names(ss) <- nmrows
    nt <- nterms
    if (rdf > 0) {
        nt <- nterms + 1
        df[nt] <- rdf
        ss[[nt]] <- crossprod(resid)
        names(ss)[nt] <- nmrows[nt] <- "Residuals"
        ok <- df[-nt] > 0
        eigs <- array(NA, c(nterms, nresp))
        dimnames(eigs) <- list(nmrows[-nt], NULL)
        stats <- matrix(NA, nt, 5)
        dimnames(stats) <- list(nmrows, c(test, "approx F", "num Df", 
            "den Df", "Pr(>F)"))
        sc <- sqrt(diag(ss[[nt]]))
        sss <- sc^2
        for (i in seq_len(nterms)[ok]) sss <- sss + diag(ss[[i]])
        sc[sc < sqrt(sss) * 1e-06] <- 1
        D <- diag(1/sc)
        rss.qr <- qr(D %*% ss[[nt]] %*% D, tol = tol)
        if (rss.qr$rank < ncol(resid)) 
            stop(gettextf("residuals have rank %d < %d", rss.qr$rank, 
                ncol(resid)), domain = NA)
        if (!is.null(rss.qr)) 
            for (i in seq_len(nterms)[ok]) {
                A1 <- qr.coef(rss.qr, D %*% ss[[i]] %*% D)
                eigs[i, ] <- Re(eigen(A1, symmetric = FALSE)$values)
                stats[i, 1L:4] <- switch(test, Pillai = Pillai(eigs[i, 
                  ], df[i], df[nt]), Wilks = Wilks(eigs[i, ], 
                  df[i], df[nt]), `Hotelling-Lawley` = HL(eigs[i, 
                  ], df[i], df[nt]), Roy = Roy(eigs[i, ], df[i], 
                  df[nt]))
                ok <- stats[, 2] >= 0 & stats[, 3] > 0 & stats[, 
                  4] > 0
                ok <- !is.na(ok) & ok
                stats[ok, 5] <- pf(stats[ok, 2], stats[ok, 3], 
                  stats[ok, 4], lower.tail = FALSE)
            }
        x <- list(row.names = nmrows, SS = ss, Eigenvalues = eigs, 
            stats = cbind(Df = df, stats = stats))
    }
    else x <- list(row.names = nmrows, SS = ss, Df = df)
    class(x) <- "summary.manova"
    x
}
<environment: namespace:stats>
> print("summary.nls"); if(is.function(try(summary.nls))) {summary.nls;} else{ NULL};
[1] "summary.nls"
NULL
> print("summary.princomp"); if(is.function(try(summary.princomp))) {summary.princomp;} else{ NULL};
[1] "summary.princomp"
NULL
> print("supsmu"); if(is.function(try(supsmu))) {supsmu;} else{ NULL};
[1] "supsmu"
function (x, y, wt = rep(1, n), span = "cv", periodic = FALSE, 
    bass = 0) 
{
    if (span == "cv") 
        span <- 0
    n <- length(y)
    if (!n || !is.numeric(y)) 
        stop("'y' must be numeric vector")
    if (length(x) != n) 
        stop("number of observations in 'x' and 'y' must match.")
    if (length(wt) != n) 
        stop("number of weights must match number of observations.")
    if (span < 0 || span > 1) 
        stop("'span' must be between 0 and 1.")
    if (periodic) {
        iper <- 2L
        xrange <- range(x)
        if (xrange[1L] < 0 || xrange[2L] > 1) 
            stop("'x' must be between 0 and 1 for periodic smooth")
    }
    else iper <- 1L
    okay <- is.finite(x + y + wt)
    ord <- order(x[okay], y[okay])
    ord <- cumsum(!okay)[okay][ord] + ord
    xo <- x[ord]
    leno <- length(ord)
    if (leno == 0L) 
        stop("no finite observations")
    if (diff <- n - leno) 
        warning(diff, " observation(s) with NAs, NaNs and/or Infs deleted")
    .Fortran(R_setsmu)
    smo <- .Fortran(R_supsmu, as.integer(leno), as.double(xo), 
        as.double(y[ord]), as.double(wt[ord]), as.integer(iper), 
        as.double(span), as.double(bass), smo = double(leno), 
        double(n * 7L), double(1L))$smo
    dupx <- duplicated(xo)
    list(x = xo[!dupx], y = smo[!dupx])
}
<environment: namespace:stats>
> print("symnum"); if(is.function(try(symnum))) {symnum;} else{ NULL};
[1] "symnum"
function (x, cutpoints = c(0.3, 0.6, 0.8, 0.9, 0.95), symbols = if (numeric.x) c(" ", 
    ".", ",", "+", "*", "B") else c(".", "|"), legend = length(symbols) >= 
    3, na = "?", eps = 1e-05, numeric.x = is.numeric(x), corr = missing(cutpoints) && 
    numeric.x, show.max = if (corr) "1", show.min = NULL, abbr.colnames = has.colnames, 
    lower.triangular = corr && is.numeric(x) && is.matrix(x), 
    diag.lower.tri = corr && !is.null(show.max)) 
{
    if (length(x) == 0L) 
        return(noquote(if (is.null(d <- dim(x))) character() else array("", 
            dim = d)))
    has.na <- any(nax <- is.na(x))
    if (numeric.x) {
        force(corr)
        cutpoints <- sort(cutpoints)
        if (corr) 
            cutpoints <- c(0, cutpoints, 1)
        if (anyDuplicated(cutpoints) || (corr && (any(cutpoints > 
            1) || any(cutpoints < 0)))) 
            stop(if (corr) 
                gettext("'cutpoints' must be unique in 0 < cuts < 1, but are = ")
            else gettext("'cutpoints' must be unique, but are = "), 
                paste(format(cutpoints), collapse = "|"), domain = NA)
        nc <- length(cutpoints)
        minc <- cutpoints[1L]
        maxc <- cutpoints[nc]
        range.msg <- if (corr) 
            gettext("'x' must be between -1 and 1")
        else gettextf("'x' must be between %s and %s", format(minc), 
            format(maxc))
        if (corr) 
            x <- abs(x)
        else if (any(x < minc - eps, na.rm = TRUE)) 
            stop(range.msg, domain = NA)
        if (any(x > maxc + eps, na.rm = TRUE)) 
            stop(range.msg, domain = NA)
        ns <- length(symbols)
        symbols <- as.character(symbols)
        if (anyDuplicated(symbols)) 
            stop("'symbols' must be unique, but are = ", paste(symbols, 
                collapse = "|"), domain = NA)
        if (nc != ns + 1) 
            if (corr) 
                stop("number of 'cutpoints' must be one less than number of symbols")
            else stop("number of 'cutpoints' must be one more than number of symbols")
        iS <- cut(x, breaks = cutpoints, include.lowest = TRUE, 
            labels = FALSE)
        if (any(ii <- is.na(iS))) {
            iS[which(ii)[!is.na(x[ii]) & (abs(x[ii] - minc) < 
                eps)]] <- 1
        }
    }
    else {
        if (!missing(symbols) && length(symbols) != 2L) 
            stop("must have 2 'symbols' for logical 'x' argument")
        iS <- x + 1
    }
    if (has.na) {
        ans <- character(length(iS))
        if ((has.na <- is.character(na))) 
            ans[nax] <- na
        ans[!nax] <- symbols[iS[!nax]]
    }
    else ans <- symbols[iS]
    if (numeric.x) {
        if (!is.null(show.max)) 
            ans[x >= maxc - eps] <- if (is.character(show.max)) 
                show.max
            else format(maxc, dig = 1)
        if (!is.null(show.min)) 
            ans[x <= minc + eps] <- if (is.character(show.min)) 
                show.min
            else format(minc, dig = 1)
    }
    if (lower.triangular && is.matrix(x)) 
        ans[!lower.tri(x, diag = diag.lower.tri)] <- ""
    attributes(ans) <- attributes(x)
    if (is.array(ans) && (rank <- length(dim(x))) >= 2L) {
        has.colnames <- !is.null(dimnames(ans))
        if (!has.colnames) {
            dimnames(ans) <- vector("list", rank)
        }
        else {
            has.colnames <- length(dimnames(ans)[[2L]]) > 0L
        }
        if ((is.logical(abbr.colnames) || is.numeric(abbr.colnames)) && 
            abbr.colnames) {
            dimnames(ans)[[2L]] <- abbreviate(dimnames(ans)[[2L]], 
                minlength = abbr.colnames)
        }
        else if (is.null(abbr.colnames) || is.null(dimnames(ans)[[2L]])) 
            dimnames(ans)[[2L]] <- rep("", dim(ans)[2L])
        else if (!is.logical(abbr.colnames)) 
            stop("invalid 'abbr.colnames'")
    }
    if (legend) {
        legend <- c(rbind(sapply(cutpoints, format), c(sQuote(symbols), 
            "")), if (has.na) paste("\t    ## NA:", sQuote(na)))
        attr(ans, "legend") <- paste(legend[-2 * (ns + 1)], collapse = " ")
    }
    noquote(ans)
}
<environment: namespace:stats>
> print("t.test"); if(is.function(try(t.test))) {t.test;} else{ NULL};
[1] "t.test"
function (x, ...) 
UseMethod("t.test")
<environment: namespace:stats>
> print("termplot"); if(is.function(try(termplot))) {termplot;} else{ NULL};
[1] "termplot"
function (model, data = NULL, envir = environment(formula(model)), 
    partial.resid = FALSE, rug = FALSE, terms = NULL, se = FALSE, 
    xlabs = NULL, ylabs = NULL, main = NULL, col.term = 2, lwd.term = 1.5, 
    col.se = "orange", lty.se = 2, lwd.se = 1, col.res = "gray", 
    cex = 1, pch = par("pch"), col.smth = "darkred", lty.smth = 2, 
    span.smth = 2/3, ask = dev.interactive() && nb.fig < n.tms, 
    use.factor.levels = TRUE, smooth = NULL, ylim = "common", 
    ...) 
{
    which.terms <- terms
    terms <- if (is.null(terms)) 
        predict(model, type = "terms", se.fit = se)
    else predict(model, type = "terms", se.fit = se, terms = terms)
    n.tms <- ncol(tms <- as.matrix(if (se) 
        terms$fit
    else terms))
    mf <- model.frame(model)
    if (is.null(data)) 
        data <- eval(model$call$data, envir)
    if (is.null(data)) 
        data <- mf
    use.rows <- if (NROW(tms) < NROW(data)) 
        match(rownames(tms), rownames(data))
    nmt <- colnames(tms)
    cn <- parse(text = nmt)
    if (!is.null(smooth)) 
        smooth <- match.fun(smooth)
    if (is.null(ylabs)) 
        ylabs <- paste("Partial for", nmt)
    if (is.null(main)) 
        main <- ""
    else if (is.logical(main)) 
        main <- if (main) 
            deparse(model$call, 500)
        else ""
    else if (!is.character(main)) 
        stop("'main' must be TRUE, FALSE, NULL or character (vector).")
    main <- rep(main, length.out = n.tms)
    pf <- envir
    carrier <- function(term) {
        if (length(term) > 1L) 
            carrier(term[[2L]])
        else eval(term, data, enclos = pf)
    }
    carrier.name <- function(term) {
        if (length(term) > 1L) 
            carrier.name(term[[2L]])
        else as.character(term)
    }
    if (is.null(xlabs)) 
        xlabs <- unlist(lapply(cn, carrier.name))
    if (partial.resid || !is.null(smooth)) {
        pres <- residuals(model, "partial")
        if (!is.null(which.terms)) 
            pres <- pres[, which.terms, drop = FALSE]
    }
    is.fac <- sapply(nmt, function(i) is.factor(mf[, i]))
    se.lines <- function(x, iy, i, ff = 2) {
        tt <- ff * terms$se.fit[iy, i]
        lines(x, tms[iy, i] + tt, lty = lty.se, lwd = lwd.se, 
            col = col.se)
        lines(x, tms[iy, i] - tt, lty = lty.se, lwd = lwd.se, 
            col = col.se)
    }
    nb.fig <- prod(par("mfcol"))
    if (ask) {
        oask <- devAskNewPage(TRUE)
        on.exit(devAskNewPage(oask))
    }
    ylims <- ylim
    if (identical(ylims, "common")) {
        ylims <- if (!se) 
            range(tms, na.rm = TRUE)
        else range(tms + 1.05 * 2 * terms$se.fit, tms - 1.05 * 
            2 * terms$se.fit, na.rm = TRUE)
        if (partial.resid) 
            ylims <- range(ylims, pres, na.rm = TRUE)
        if (rug) 
            ylims[1L] <- ylims[1L] - 0.07 * diff(ylims)
    }
    for (i in 1L:n.tms) {
        if (identical(ylim, "free")) {
            ylims <- range(tms[, i], na.rm = TRUE)
            if (se) 
                ylims <- range(ylims, tms[, i] + 1.05 * 2 * terms$se.fit[, 
                  i], tms[, i] - 1.05 * 2 * terms$se.fit[, i], 
                  na.rm = TRUE)
            if (partial.resid) 
                ylims <- range(ylims, pres[, i], na.rm = TRUE)
            if (rug) 
                ylims[1L] <- ylims[1L] - 0.07 * diff(ylims)
        }
        if (is.fac[i]) {
            ff <- mf[, nmt[i]]
            if (!is.null(model$na.action)) 
                ff <- naresid(model$na.action, ff)
            ll <- levels(ff)
            xlims <- range(seq_along(ll)) + c(-0.5, 0.5)
            xx <- as.numeric(ff)
            if (rug) {
                xlims[1L] <- xlims[1L] - 0.07 * diff(xlims)
                xlims[2L] <- xlims[2L] + 0.03 * diff(xlims)
            }
            plot(1, 0, type = "n", xlab = xlabs[i], ylab = ylabs[i], 
                xlim = xlims, ylim = ylims, main = main[i], xaxt = "n", 
                ...)
            if (use.factor.levels) 
                axis(1, at = seq_along(ll), labels = ll, ...)
            else axis(1)
            for (j in seq_along(ll)) {
                ww <- which(ff == ll[j])[c(1, 1)]
                jf <- j + c(-0.4, 0.4)
                lines(jf, tms[ww, i], col = col.term, lwd = lwd.term, 
                  ...)
                if (se) 
                  se.lines(jf, iy = ww, i = i)
            }
        }
        else {
            xx <- carrier(cn[[i]])
            if (!is.null(use.rows)) 
                xx <- xx[use.rows]
            xlims <- range(xx, na.rm = TRUE)
            if (rug) 
                xlims[1L] <- xlims[1L] - 0.07 * diff(xlims)
            oo <- order(xx)
            plot(xx[oo], tms[oo, i], type = "l", xlab = xlabs[i], 
                ylab = ylabs[i], xlim = xlims, ylim = ylims, 
                main = main[i], col = col.term, lwd = lwd.term, 
                ...)
            if (se) 
                se.lines(xx[oo], iy = oo, i = i)
        }
        if (partial.resid) {
            if (!is.fac[i] && !is.null(smooth)) {
                smooth(xx, pres[, i], lty = lty.smth, cex = cex, 
                  pch = pch, col = col.res, col.smooth = col.smth, 
                  span = span.smth)
            }
            else points(xx, pres[, i], cex = cex, pch = pch, 
                col = col.res)
        }
        if (rug) {
            n <- length(xx)
            lines(rep.int(jitter(xx), rep.int(3, n)), rep.int(ylims[1L] + 
                c(0, 0.05, NA) * diff(ylims), n))
            if (partial.resid) 
                lines(rep.int(xlims[1L] + c(0, 0.05, NA) * diff(xlims), 
                  n), rep.int(pres[, i], rep.int(3, n)))
        }
    }
    invisible(n.tms)
}
<environment: namespace:stats>
> print("terms"); if(is.function(try(terms))) {terms;} else{ NULL};
[1] "terms"
function (x, ...) 
UseMethod("terms")
<environment: namespace:stats>
> print("terms.formula"); if(is.function(try(terms.formula))) {terms.formula;} else{ NULL};
[1] "terms.formula"
function (x, specials = NULL, abb = NULL, data = NULL, neg.out = TRUE, 
    keep.order = FALSE, simplify = FALSE, ..., allowDotAsName = FALSE) 
{
    fixFormulaObject <- function(object) {
        Terms <- terms(object)
        tmp <- attr(Terms, "term.labels")
        ind <- grep("|", tmp, fixed = TRUE)
        if (length(ind)) 
            tmp[ind] <- paste("(", tmp[ind], ")")
        if (length(ind <- attr(Terms, "offset"))) {
            tmp2 <- as.character(attr(Terms, "variables"))[-1L]
            tmp <- c(tmp, tmp2[ind])
        }
        rhs <- if (length(tmp)) 
            paste(tmp, collapse = " + ")
        else "1"
        if (!attr(terms(object), "intercept")) 
            rhs <- paste(rhs, "- 1")
        if (length(form <- formula(object)) > 2L) {
            res <- formula(paste("lhs ~", rhs))
            res[[2L]] <- form[[2L]]
            res
        }
        else formula(paste("~", rhs))
    }
    if (!is.null(data) && !is.environment(data) && !is.data.frame(data)) 
        data <- as.data.frame(data, optional = TRUE)
    terms <- .Internal(terms.formula(x, specials, data, keep.order, 
        allowDotAsName))
    if (simplify) {
        a <- attributes(terms)
        terms <- fixFormulaObject(terms)
        attributes(terms) <- a
    }
    environment(terms) <- environment(x)
    if (!inherits(terms, "formula")) 
        class(terms) <- c(oldClass(terms), "formula")
    terms
}
<environment: namespace:stats>
> print("terms.object"); if(is.function(try(terms.object))) {terms.object;} else{ NULL};
[1] "terms.object"
NULL
> print("time"); if(is.function(try(time))) {time;} else{ NULL};
[1] "time"
function (x, ...) 
UseMethod("time")
<environment: namespace:stats>
> print("toeplitz"); if(is.function(try(toeplitz))) {toeplitz;} else{ NULL};
[1] "toeplitz"
function (x) 
{
    if (!is.vector(x)) 
        stop("'x' is not a vector")
    n <- length(x)
    A <- matrix(0, n, n)
    matrix(x[abs(col(A) - row(A)) + 1], n, n)
}
<environment: namespace:stats>
> print("ts"); if(is.function(try(ts))) {ts;} else{ NULL};
[1] "ts"
function (data = NA, start = 1, end = numeric(0), frequency = 1, 
    deltat = 1, ts.eps = getOption("ts.eps"), class = if (nseries > 
        1) c("mts", "ts") else "ts", names = if (!is.null(dimnames(data))) colnames(data) else paste("Series", 
        seq(nseries))) 
{
    if (is.data.frame(data)) 
        data <- data.matrix(data)
    if (is.matrix(data)) {
        nseries <- ncol(data)
        ndata <- nrow(data)
        dimnames(data) <- list(NULL, names)
    }
    else {
        nseries <- 1
        ndata <- length(data)
    }
    if (ndata == 0) 
        stop("'ts' object must have one or more observations")
    if (missing(frequency)) 
        frequency <- 1/deltat
    else if (missing(deltat)) 
        deltat <- 1/frequency
    if (frequency > 1 && abs(frequency - round(frequency)) < 
        ts.eps) 
        frequency <- round(frequency)
    if (length(start) > 1L) {
        start <- start[1L] + (start[2L] - 1)/frequency
    }
    if (length(end) > 1L) {
        end <- end[1L] + (end[2L] - 1)/frequency
    }
    if (missing(end)) 
        end <- start + (ndata - 1)/frequency
    else if (missing(start)) 
        start <- end - (ndata - 1)/frequency
    if (start > end) 
        stop("'start' cannot be after 'end'")
    nobs <- floor((end - start) * frequency + 1.01)
    if (nobs != ndata) 
        data <- if (NCOL(data) == 1) {
            if (ndata < nobs) 
                rep(data, length.out = nobs)
            else if (ndata > nobs) 
                data[1L:nobs]
        }
        else {
            if (ndata < nobs) 
                data[rep(1L:ndata, length.out = nobs), ]
            else if (ndata > nobs) 
                data[1L:nobs, ]
        }
    attr(data, "tsp") <- c(start, end, frequency)
    if (!is.null(class) && class != "none") 
        attr(data, "class") <- class
    data
}
<environment: namespace:stats>
> print("ts.plot"); if(is.function(try(ts.plot))) {ts.plot;} else{ NULL};
[1] "ts.plot"
function (..., gpars = list()) 
{
    dots <- list(...)
    pars <- c("xlab", "ylab", "xlim", "ylim", "col", "lty", "lwd", 
        "type", "main", "sub", "log")
    m <- names(dots) %in% pars
    if (length(m)) {
        gpars <- c(gpars, dots[m])
        dots <- dots[!m]
    }
    sers <- do.call("ts.union", dots)
    if (is.null(gpars$ylab)) 
        gpars$ylab <- if (NCOL(sers) > 1) 
            ""
        else deparse(substitute(...))
    do.call("plot.ts", c(list(sers, plot.type = "single"), gpars))
}
<environment: namespace:stats>
> print("ts.union"); if(is.function(try(ts.union))) {ts.union;} else{ NULL};
[1] "ts.union"
function (..., dframe = FALSE) 
.cbind.ts(list(...), .makeNamesTs(...), dframe = dframe, union = TRUE)
<environment: namespace:stats>
> print("tsSmooth"); if(is.function(try(tsSmooth))) {tsSmooth;} else{ NULL};
[1] "tsSmooth"
function (object, ...) 
UseMethod("tsSmooth")
<environment: namespace:stats>
> print("tsdiag"); if(is.function(try(tsdiag))) {tsdiag;} else{ NULL};
[1] "tsdiag"
function (object, gof.lag, ...) 
UseMethod("tsdiag")
<environment: namespace:stats>
> print("tsp"); if(is.function(try(tsp))) {tsp;} else{ NULL};
[1] "tsp"
function (x) 
attr(x, "tsp")
<environment: namespace:stats>
> print("uniroot"); if(is.function(try(uniroot))) {uniroot;} else{ NULL};
[1] "uniroot"
function (f, interval, ..., lower = min(interval), upper = max(interval), 
    f.lower = f(lower, ...), f.upper = f(upper, ...), tol = .Machine$double.eps^0.25, 
    maxiter = 1000) 
{
    if (!missing(interval) && length(interval) != 2L) 
        stop("'interval' must be a vector of length 2")
    if (!is.numeric(lower) || !is.numeric(upper) || lower >= 
        upper) 
        stop("lower < upper  is not fulfilled")
    if (is.na(f.lower)) 
        stop("f.lower = f(lower) is NA")
    if (is.na(f.upper)) 
        stop("f.upper = f(upper) is NA")
    if (f.lower * f.upper > 0) 
        stop("f() values at end points not of opposite sign")
    val <- .Internal(zeroin2(function(arg) f(arg, ...), lower, 
        upper, f.lower, f.upper, tol, as.integer(maxiter)))
    iter <- as.integer(val[2L])
    if (iter < 0) {
        warning("_NOT_ converged in ", maxiter, " iterations")
        iter <- maxiter
    }
    list(root = val[1L], f.root = f(val[1L], ...), iter = iter, 
        estim.prec = val[3L])
}
<environment: namespace:stats>
> print("update"); if(is.function(try(update))) {update;} else{ NULL};
[1] "update"
function (object, ...) 
UseMethod("update")
<environment: namespace:stats>
> print("update.formula"); if(is.function(try(update.formula))) {update.formula;} else{ NULL};
[1] "update.formula"
function (old, new, ...) 
{
    tmp <- .Internal(update.formula(as.formula(old), as.formula(new)))
    out <- formula(terms.formula(tmp, simplify = TRUE))
    return(out)
}
<environment: namespace:stats>
> print("var.test"); if(is.function(try(var.test))) {var.test;} else{ NULL};
[1] "var.test"
function (x, ...) 
UseMethod("var.test")
<environment: namespace:stats>
> print("varimax"); if(is.function(try(varimax))) {varimax;} else{ NULL};
[1] "varimax"
function (x, normalize = TRUE, eps = 1e-05) 
{
    nc <- ncol(x)
    if (nc < 2) 
        return(x)
    if (normalize) {
        sc <- sqrt(drop(apply(x, 1L, function(x) sum(x^2))))
        x <- x/sc
    }
    p <- nrow(x)
    TT <- diag(nc)
    d <- 0
    for (i in 1L:1000L) {
        z <- x %*% TT
        B <- t(x) %*% (z^3 - z %*% diag(drop(rep(1, p) %*% z^2))/p)
        sB <- La.svd(B)
        TT <- sB$u %*% sB$vt
        dpast <- d
        d <- sum(sB$d)
        if (d < dpast * (1 + eps)) 
            break
    }
    z <- x %*% TT
    if (normalize) 
        z <- z * sc
    dimnames(z) <- dimnames(x)
    class(z) <- "loadings"
    list(loadings = z, rotmat = TT)
}
<environment: namespace:stats>
> print("vcov"); if(is.function(try(vcov))) {vcov;} else{ NULL};
[1] "vcov"
function (object, ...) 
UseMethod("vcov")
<environment: namespace:stats>
> print("weighted.mean"); if(is.function(try(weighted.mean))) {weighted.mean;} else{ NULL};
[1] "weighted.mean"
function (x, w, ...) 
UseMethod("weighted.mean")
<environment: namespace:stats>
> print("weighted.residuals"); if(is.function(try(weighted.residuals))) {weighted.residuals;} else{ NULL};
[1] "weighted.residuals"
function (obj, drop0 = TRUE) 
{
    w <- weights(obj)
    r <- residuals(obj, type = "deviance")
    if (drop0 && !is.null(w)) {
        if (is.matrix(r)) 
            r[w != 0, , drop = FALSE]
        else r[w != 0]
    }
    else r
}
<environment: namespace:stats>
> print("weights"); if(is.function(try(weights))) {weights;} else{ NULL};
[1] "weights"
function (object, ...) 
UseMethod("weights")
<environment: namespace:stats>
> print("wilcox.test"); if(is.function(try(wilcox.test))) {wilcox.test;} else{ NULL};
[1] "wilcox.test"
function (x, ...) 
UseMethod("wilcox.test")
<environment: namespace:stats>
> print("window"); if(is.function(try(window))) {window;} else{ NULL};
[1] "window"
function (x, ...) 
UseMethod("window")
<environment: namespace:stats>
> 
